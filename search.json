[{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"设权值为的答案为，对应OGF为，集合对应的OGF为\n考虑，枚举二叉树左右子树的方案数和根的值，可得\n均大于0,所以只有为空树的一种情况即，可得\n ，代入和 ，可得 \n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\n\n","tags":["Generating Functions"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"设个点的简单有标号无向图的数目为,对应为\n个点的简单有标号无向连通图的数目为,对应为\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\n所以，答案即为\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\n\n","tags":["Generating Functions"]}]