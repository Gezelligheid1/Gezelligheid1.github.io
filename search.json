[{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"设权值为的答案为，对应OGF为，集合对应的OGF为\n考虑，枚举二叉树左右子树的方案数和根的值，可得\n均大于0,所以只有为空树的一种情况即，可得\n ，代入和 ，可得 \n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\n\n","tags":["Generating Functions"]},{"title":"快速沃尔什变换/快速莫比乌斯变换","url":"/2022/04/10/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%20%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/","content":"笔者对快速沃尔什变换/快速莫比乌斯变换的理解也只是刚学阶段，本文只是写写自己的理解和一些其他博客略去的证明。(还没写完的部分可能会咕咕咕一段时间再写)\n前置知识：卷积\n对于多项式卷积，其思想是对于两个多项式，首先经过转换为点值表示得到，令，再对作一次转化为数组即为答案。\n那么类比多项式卷积，位运算卷积也可以类似定义，第项和第项的乘积贡献到第项，则，此处对应某种位运算，那么只需要构造一种转换满足就能实现时间复杂度的位运算卷积(论构造手为什么是神)，具体构造方法可以由数学推导得出+真值表+矩阵求逆得出，由于笔者处于初学阶段，暂不去推构造证明\n以下只讲与、或、异或三种位运算卷积且序列长度为的幂\n与\n\n构造这样就可以在时间求出和的乘积，现在只需快速求出变换和\n设序列长度为，下标范围为，由于和位运算的特殊性，考虑对按位分治，设\n设是下标为的序列，是下标为的序列，如果已经求出了和，那么只要计算和相互的贡献就能求出\n对于，有，考虑二进制表示，则在二进制表示上比多一个最高位的，即，因此对于任意若满足，也一定满足，又和构成双射，那么对于，在上恰好对有一次贡献，在上不变，因此可以推出下式：在区间上为，在区间上为那么的分治就完成了\n再对序列做就能得到答案序列经过变换后的序列\n对于，即为的反演，考虑矩阵行变换后可得(这部分矩阵证明反演笔者也不知道是否合理，凭感觉写的)\n那么可以推出下式：在区间上为，在区间上为就能得到最终的答案序列\nvoid mul(int n){    for (int i = 0; i &lt; n; i++)        a[i] = a[i] * b[i] % mod;}void AND(ll *f, ll x, int n){    for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1)        for (int i = 0; i &lt; n; i += o)            for (int j = 0; j &lt; k; j++)                f[i + j] = (f[i + j] + f[i + j + k] * x) % mod;}void FWT_AND(){    AND(a, 1, n), AND(b, 1, n), mul(n), AND(a, mod - 1, n)}\n\n剩下的部分咕咕咕\n","tags":["math FWT FMT"]},{"title":"洛谷P4389 付公主的背包","url":"/2022/04/03/%E6%B4%9B%E8%B0%B7P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","content":"设商品体积为的为，\n则所求答案为\n麦克劳林公式展开后可得 \n枚举倍数后可得系数，再求一次多项式即可得到答案，时间复杂度\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }        poly exp(int n)//需要保证f[0]=1        {            poly a{1};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * (poly{1} - a.ln(k) + modxk(k))).modxk(k);            }            return a.modxk(n);        }#undef T    };}using namespace polybase;int cnt[N];ll inv[N];int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        scanf(\"%d\", &amp;x), cnt[x]++;    for (int i = 1; i &lt;= m; i++)        inv[i] = fpow(i, mod - 2);    poly F(m + 1);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; i * j &lt;= m; j++)            F[i * j] = (F[i * j] + inv[j] * cnt[i]) % mod;    F = F.exp(m + 1);    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\n","tags":["Generating Functions"]},{"title":"洛谷P4491 [HAOI2018]染色","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4491%20%5BHAOI2018%5D%E6%9F%93%E8%89%B2/","content":"设为钦定种颜色，每种颜色恰好出现了次的方案数，设为恰好种颜色，每种颜色恰好出现了次的方案数\n考虑钦定k种颜色能得到的方案数，可得\n\n\n阶乘预处理后即可时间内算出\n然后考虑和之间的关系，有\n二项式反演后可得\n差卷积后乘上对应值即可得出答案，总复杂度\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 10000005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    int s;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    poly W(m + 1);    for (int i = 0; i &lt;= m; i++)        scanf(\"%d\", &amp;W[i]);    poly F(m + 1);    for (int i = min(n / s, m); i &gt;= 0; i--)        F[i] = fac[m] * ifac[m - i] % mod * fac[n] % mod * fpow(ifac[s], i) % mod *               ifac[n - i * s] % mod * fpow(m - i, n - i * s) % mod;    poly H(m + 1);    for (int i = 0; i &lt;= m; i++)        H[m - i] = (i &amp; 1 ? mod - 1 : 1) * ifac[i] % mod;    poly G = F * H;    ll ans = 0;    for (int i = 0; i &lt;= m; i++)        ans = (ans + G[m + i] * ifac[i] % mod * W[i]) % mod;    cout &lt;&lt; ans;    return 0;}\n","tags":["Generating Functions"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"设个点的简单有标号无向图的数目为,对应为\n个点的简单有标号无向连通图的数目为,对应为\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\n所以，答案即为\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\n\n","tags":["Generating Functions"]}]