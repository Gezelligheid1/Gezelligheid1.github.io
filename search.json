[{"title":"2022-2023赛季VP记录","url":"/2022/10/15/2022-2023%E8%B5%9B%E5%AD%A3VP%E8%AE%B0%E5%BD%95/","content":"\r\n19哈尔滨：8题933罚时，正式榜rk7，去除打星rk4，cf上截至vp结束rk35，C题机时不足赛后20分钟通过，正式大量VP的开端。\r\n\r\n19徐州：7题1349罚时，正式榜rk15，去除打星rk13，vjudge上截至vp结束rk20，未过银牌题M，本场因掉网和首次使用vjudge\r\nvp导致体验糟糕，机时上也很混乱，对队友的pollard_rho板子不熟悉导致浪费了很多时间，总体罚时爆炸。\r\n19拉美：8题991罚时，cf上截至vp结束rk120，还剩半个多小时的时候觉得没什么想法就先解散吃饭了，F题中期两个多小时没开出来我背大锅，被杜老师(DDOSvoid)n+2爆杀。\r\n19秦皇岛：6题996罚时，正式榜rk18，去除打星rk15，cf上截至vp结束rk81，有不少失误，加上博弈苦手的原因一度大脑宕机，导致罚时过高。\r\n20秦皇岛：5题319罚时，gym上无银牌假题C，正式榜rk73，去除打星rk61，cf上截至vp结束rk76，出金牌题实力不够，hash姿势不足。\r\n19SEERC：4题520罚时，cf上截至vp结束rk292，寄穿。 2015-2016 Petrozavodsk Winter Training Camp, Moscow\r\nSU Trinity\r\nContest：6题653罚时，cf上截至vp结束rk67，C题背景描述与输入描述不符合，D题实际应算没过，G题又是构造苦手，过题人数非常多的构造未出。\r\n2019 Petrozavodsk Winter Camp, Yandex Cup:\r\n3题426罚时，cf上截至vp结束rk86，跟娱乐一样乱打+被贪心题卡死\r\n22桂林：6题862罚时，cf上截至vp结束rk86，正式榜rk56，去除打星rk47，G题队友没睡够状态不好，D题自己推到最后一步时候把一个会的结论应该是一元GF形式推错写成了二元，寄寄寄，场上推式子天天犯病。\r\n20银川：6题916罚时，cf上截至vp结束rk29，正式榜rk28，去除打星rk27，CD浪费过多时间想和写错误做法，C想了两小时优化打表，最后一小时反应过来是多项式，D写了个200行LCT最后发现反例否定了这种做法，非常逆风。\r\n22威海：7题704罚时，cf上截至vp结束rk48，正式榜rk35，去除打星rk34，2小时44分钟签完7题，然后K题没有想太深就开始写一个极其麻烦的做法，到最后都没有调出来，赛后发现这种做法漏了一种情况+方案数算错了，应该想得再深入一些再动键盘。 2022-2023 ICPC NERC (NEERC), North-Western Russia\r\nRegional Contest (Northern\r\nSubregionals)：6题410罚时，cf上截至vp结束rk57，赛后一分钟内过了F，又被杜老师n+2爆杀了。\r\n22广州：5题559罚时，cf上截至vp结束rk59，正式榜rk37，去除打星rk29。\r\n21EC：6题624罚时，cf上截至vp结束rk18，正式榜rk22，去除打星rk21。\r\n22绵阳：4题215罚时，cf上截至vp结束rk154，正式榜rk105，去除打星rk99。 COMPFEST 13 - Finals Online Mirror (Unrated, ICPC\r\nRules, Teams Preferred)：9题972罚时，cf上截至vp结束rk49。\r\nCOMPFEST 14 - Preliminary Online Mirror (Unrated, ICPC Rules, Teams\r\nPreferred)：7题485罚时，cf上截至vp结束rk133，正式大量vp的结尾。\r\n"},{"title":"2020牛客暑期多校训练营（第五场）C-Easy","url":"/2022/06/16/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89C-Easy/","content":"\r\n2020牛客暑期多校训练营（第五场）C-Easy\r\n设所对应的二元生成函数为，则答案为\r\n由基本生成函数知识可知\r\n\r\n考虑 \r\n则\r\n因此\r\n时间复杂度\r\n","tags":["Generating Functions","Combinatorics"]},{"title":"2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest Problem H. Hans Zimmer","url":"/2022/11/01/2015-2016%20Petrozavodsk%20Winter%20Training%20Camp,%20Moscow%20SU%20Trinity%20Contest%20Problem%20H.%20Hans%20Zimmer/","content":"\r\n引理1： 长为的线段随机切刀分成条线段，最短线段长度期望为，第短线段长度为\r\n\r\n考虑一个直观等价的事实，随机切刀等价于个随机变量满足，最短段为(具体证明不会。。)\r\n另一个比较直观的引理2(证明不会，概率论太差了呜呜呜)：\r\n\r\n再一个比较直观的引理3：\r\n\r\n证明(终于有我会的了)：\r\n分部积分法\r\n那么最短线段的期望长度:\r\n引理\r\n最长线段的期望长度(容斥做法)：\r\n\r\n第短线段的递推做法(容斥做法不会呜呜呜)：\r\n考虑第2短的线段期望长度，相当于给都减去，答案就是此时的最短线段期望长度+原先最短线段期望长度。\r\n\r\n由此可以数学归纳法求出 \r\n回到原题，此时可以枚举确定横纵切的刀数 答案为：\r\n\r\n精度上用函数解决即可\r\n","tags":["Math","Integral","Expectation"]},{"title":"2022多校多项式做题记录","url":"/2022/07/26/2022%E5%A4%9A%E6%A0%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\r\n牛客多校1：H题\r\nFly，基础不牢没学过完全背包转二进制01背包，中档题，挺可惜。\r\n杭电多校1：1010\r\nwalk，容斥+矩阵维护多项式，压轴难度，完全没思路，补题见Blog。\r\n牛客多校2：E题 Falfa with\r\nSubstring，经典二项式反演，例题难度，场切。\r\n杭电多校2：无多项式。\r\n牛客多校3：I题Ice Drinking，压轴难度，数的touchard同余性质以及快速求5000个级别的第二类数，不会求这5000个斯特林数，比较可惜的是只差这一步，而这一步在翻混凝土数学的时候没去翻二阶欧拉数，二阶欧拉数能与转换，差临门一脚，可惜。\r\nPS：东京大学队伍有个神秘科技可以求单次的斯特林数，令人震惊\r\n\r\n杭电多校3：1001 Equipment\r\nUpgrade，cdq分治fft优化期望dp，场切，中档题难度，但是过题人数和牛客多校2的E题差不多，人均会多项式？\r\n牛客多校4：C Easy Counting Problem，中档题，场切，但是选择了枚举而不是背包导致需要卡常\r\n杭电多校4：无多项式。\r\n牛客多校5：著名锅场，无多项式。\r\n杭电多校5：1007 Count\r\nSet，普通分治fft，签到题难度，场切，270个队会多项式就很离谱。\r\n杭电多校6：1003 Find the Number of\r\nPaths，金牌题难度，会，但是没开，一整场卡了四道签到导致时间上寄了，所以另一道置换群模板题也没时间开。\r\n","tags":["record"]},{"title":"2022杭电多校一1010 hdoj7147 Walk","url":"/2022/07/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%801010%20hdoj7147%20Walk/","content":" 的分界线分别为,\r\n对于下一层的纵坐标\r\n，，， 称满足上述条件为合法情况，不满足上述条件为不合法情况。\r\n设恰好有层不合法的方案数为，设恰好有i层合法的方案数为。\r\n考虑容斥求，钦定最后层（即到层）不合法，前层合法。（容斥部分感谢ywx的讲解和点化）\r\n那么从钦定最后层不合法和前层合法开始，当前情况数为，此时只钦定了前层和最后层，第层和第层之间的关系并未确定，可能第层和第层仍然构成不合法情况，那么就要把这种情况减去，也就是减掉，同理仍然有第层和第层可能构成不合法情况，但被减去了，所以要加上，一步步下去，可得如下式子\r\n\r\n合并后可得\r\n\r\n所以对应的生成函数和对应的生成函数之间的关系为  接下来考虑如何求\r\n连续层不合法，那么会使得\r\n设，那么需要相隔至少个数之后才能选，那么可以每选择一个数使得减，即线性变换，因此考虑矩阵\r\n设为输入的个权值\r\n时不需要偏移，所以矩阵为\r\n\r\n时偏移为格\r\n\r\n时偏移为格\r\n\r\n以时的矩阵为例进行解释，之后能选的数是，那么i移动就只能从第三列移动到一列之后才能加，在移动两格的过程中，和就没有被选在之后，而选择之后又需要停两次才能选，若不选则仍然停留在立即能选的状态，所以该矩阵的转移就是\r\n\r\n写出来就是的矩阵\r\n最后带回原式做一个多项式求逆即可\r\nstruct matrix{    poly a[4][4];    static constexpr int n = 3;    friend matrix operator*(const matrix &amp;u, const matrix &amp;v)    {        matrix ans;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                for (int k = 1; k &lt;= n; k++)                    ans.a[i][j] = ans.a[i][j] + u.a[i][k] * v.a[k][j];        return ans;    }    poly *operator[](const int i)    {        return this-&gt;a[i];    }} s[N];matrix solve(int l, int r){    if (l == r)return s[l];    int m = (l + r) &gt;&gt; 1;    return solve(l, m) * solve(m + 1, r);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)    {        scanf(\"%d\", &amp;w);        if (i &lt; 16)            s[i][1][1] = poly{1, w};        else if (i &lt; 65536)            s[i][1][1] = s[i][2][1] = poly{1}, s[i][1][2] = poly{0, w};        else            s[i][1][1] = s[i][2][1] = s[i][3][2] = poly{1}, s[i][1][3] = poly{0, w};    }    matrix A = solve(1, m);    poly F = A[1][1] + A[1][2] + A[1][3];    for (int i = 1; i &lt; F.size(); i += 2)        F[i] = mod - F[i];    cout &lt;&lt; F.inv(n + 1)[n] &lt;&lt; endl;    return 0;}\r\n","tags":["Generating Functions","Matrix"]},{"title":"2022杭电多校六1003 hdoj7199 Find the Number of Paths","url":"/2022/08/05/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E5%85%AD1003%20hdoj7199%20Find%20the%20Number%20of%20Paths/","content":"\r\n设为已经走了步，当前在点的方案数，易知方程为\r\n\r\n式子不太方便，考虑令新标号等于原标号 则式子变为\r\n\r\n考虑生成函数形式，设为所对应的生成函数 则\r\n\r\n根据高中知识，构造 则\r\n\r\n就可以快速求出和\r\n时间复杂度，但常数巨大\r\n主函数核心代码就十行\r\nint main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;k);        poly A(n);        for (int i = 1; i &lt;= n - 1; i++)            scanf(\"%lld\", &amp;A[i]);        poly F = A.integ().exp(k + 1);        poly G0 = F &lt;&lt; (n - 1);        poly Gk(n);        for (int i = 0; i &lt; n; i++)            Gk[i] = G0[i + k] * fac[i + k] % mod * ifac[i] % mod;        poly H = Gk * F.inv(n);        for (int i = n - 1; i &gt;= 0; i--)            printf(\"%lld%c\", H[i], \" \\n\"[i == 0]);    }    return 0;}\r\n","tags":["Generating Functions","Math"]},{"title":"2022杭电多校七1007 hdoj7217 Counting Good Arrays","url":"/2022/09/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%831007%20hdoj7217%20Counting%20Good%20Arrays/","content":"\r\n题意：对于一个数列，满足数列长度不超过，数列最大值不超过，且对于所有，满足的方案数\r\n设为数组长度为，最后一个数为的方案数，那么答案是\r\n\r\n首先固定观察性质，可以发现对于不同的质因子，在分配时并不相互影响，所以是一个关于的积性函数那么我们只要求\r\n对于，相当于对所有，把个因子可重复得分给个位置（最后一个位置固定为），即可重组合数，所以对于单个的方案数是\r\n\r\n一个简单的生成函数证明是考虑每个位置的因子个数，对于一个位置，方案数为任意个的方案数都是，那么一个位置的生成函数是，个的位置对应的生成函数就是，方案数就是\r\n\r\n那么对于所有的方案数就是 \r\n现在求出了，就可以通过筛求出关于的前缀和，这里预处理质数处的总和时，可以发现虽然不能像单项式那样子计算，但实际是质数个数乘上（一句只要求质数处的和，一语惊醒梦中人），剩余部分就是普通的操作\r\n求出了固定下的关于的前缀和，对再做一次前缀和就能得到答案所需的式子，此时太大了，但是！！！我们发现上面有一个式子\r\n\r\n在时就是一个关于的多项式，又因为是积性函数，所以也是一个多项式，并且项数是级别的，那么我们就可以通过拉格朗日插值计算得到最终的答案，复杂度\r\n比较怪的是这题，网络赛在长度n不需要求前缀和时，虽然那题并不需要插值（用插值就啦）\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;const ll mod = 1e9 + 7;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;namespace interpolate {    ll f[N], pre[N], suf[N];    ll lagrange(ll *f, int n, ll x)    {        if (x &lt;= n)return f[x];        ll ans = 0;        pre[0] = x % mod;        for (int i = 1; i &lt;= n; i++)            pre[i] = pre[i - 1] * (x - i + mod) % mod;        suf[n + 1] = 1;        for (int i = n; i; i--)            suf[i] = suf[i + 1] * (x - i + mod) % mod;        for (int i = 1; i &lt;= n; i++)        {            ll res = ifac[i] * ifac[n - i] % mod * pre[i - 1] % mod * suf[i + 1] % mod * f[i] % mod;            if ((n - i) &amp; 1)res = mod - res;            ans += res;            if (ans &gt;= mod)ans -= mod;        }        return ans;    }}using namespace interpolate;int vis[N];ll prime[N];int cnt;void Prime(int n){    cnt = 0;//多次时别忘了    for (int i = 2; i &lt;= n; i++)    {        if (!vis[i])prime[++cnt] = i;        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)        {            vis[i * prime[j]] = 1;            if (i % prime[j] == 0)break;        }    }}ll w[N], num_p[N], g[N];int id1[N], id2[N];int sz, t;ll limit;inline int getid(ll x){    if (x &lt;= sz)return id1[x];    else return id2[limit / x];}void init(ll n){    limit = n;    sz = sqrt(n) + 5;    Prime(sz);    t = 0;//多次时别忘了，也可以设置成局部变量    for (ll l = 1, r; l &lt;= n; l = r + 1)    {        r = n / (n / l);        w[++t] = n / l;        num_p[t] = w[t] - 1;        if (w[t] &lt;= sz)id1[w[t]] = t;        else id2[n / w[t]] = t;    }    for (int i = 1; i &lt;= cnt; i++)        for (int j = 1; j &lt;= t &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j++)        {            int id = getid(w[j] / prime[i]);            num_p[j] = (num_p[j] - (num_p[id] - (i - 1)) % mod + mod) % mod;//质数个数        }}ll S(ll n, int j, int r){    if (prime[j] &gt; n)return 0;    ll ans = (num_p[getid(n)] - j + mod) * r % mod;    for (int i = j + 1; i &lt;= cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++)        for (ll e = 1, sp = prime[i]; sp &lt;= n; sp *= prime[i], e++)            ans = (ans + C(e + r - 1, e) * (S(n / sp, i, r) + (e &gt; 1))) % mod;    return ans;}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        init(m);        for (int i = 1; i &lt;= 35; i++)            f[i] = (S(m, 0, i) + 1) % mod, f[i] = (f[i] + f[i - 1]) % mod;        printf(\"%lld\\n\", lagrange(f, 35, n));    }    return 0;}\r\n","tags":["Math","Combination","Min25"]},{"title":"2022牛客多校三 D Directed","url":"/2022/08/25/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E4%B8%89%20D%20Directed/","content":"\r\n结论：结点走到父亲的期望步数为\r\n证明：设为走到父亲期望步数，为结点的度数，有 \r\n若为叶子结点\r\n可以发现和成一次函数关系，待定系数后解得\r\n\r\n那么不考虑无向边变成有向边的影响，答案就是\r\n到的链\r\n接下来考虑无向边变为有向边且方向指向根结点的影响，设从起点到终点的这条链上的结点都被染色过，对于任意一个结点，\r\n若到父亲这条边变成有向边，当且仅当到目标结点的路径中除了和这条边被染色，其他边都不被染色才会产生的贡献。\r\n记结点的被染色祖先里距离最近的祖先为，\r\n考虑这种情况的概率，设和之间距离为，概率为，而的范围是到这条链上的结点，所以这部分贡献和是\r\n\r\n求解每个的贡献即可，时间复杂度\r\nconst int N = 2000005;int n, m, k;int a[N], vis[N], d[N], f[N], sz[N];vector&lt;int&gt; vec[N];const ll mod = 998244353;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;ll ans;void dfs1(int u, int fa){    f[u] = fa;    d[u] = d[fa] + 1;    sz[u] = 1;    for (auto v:vec[u])    {        if (v == fa)continue;        dfs1(v, u);        sz[u] += sz[v];    }}ll inv;void dfs2(int u, int ancient){    if (u != 1)        ans = (ans - (C(n - d[u] + d[ancient], k) - C(n - 1 - d[u] + d[2], k)) * inv % mod * 2 * sz[u] % mod + mod) % mod;    for (auto v:vec[u])    {        if (v == f[u])continue;        if (vis[u])            dfs2(v, u);        else dfs2(v, ancient);    }}int main(){    int p, q, u, v, w, x, y, z, T;    int s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    inv = fpow(C(n - 1, k), mod - 2);    for (int i = 1; i &lt; n; i++)        scanf(\"%d%d\", &amp;u, &amp;v), vec[u].emplace_back(v), vec[v].emplace_back(u);    dfs1(1, 0);    vis[1] = 1;    for (int u = s; u != 1; u = f[u])        vis[u] = 1, ans += 2 * sz[u] - 1;    ans %= mod;    dfs2(1, 0);    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Expectation"]},{"title":"2022牛客多校八 G Lexicographic Comparison","url":"/2022/09/04/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E5%85%AB%20G%20Lexicographic%20Comparison/","content":" 平衡树维护置换环\r\n的数据结构真的锻炼能力，平衡树能力++\r\nconst int N = 100005;int n, m, k;namespace Splay {    int c[N], son[N][2], f[N], sz[N], minid[N];#define ls son[x][0]#define rs son[x][1]    inline int cmp(int x, int y)    {        if (!x || !y)return x | y;        else return x &lt; y ? x : y;    }    inline void pushup(int x)    {        sz[x] = sz[ls] + sz[rs] + 1;        minid[x] = cmp(x, cmp(minid[ls], minid[rs]));    }    inline int get(int x) { return x == son[f[x]][1]; }    inline void connect(int x, int y, int d)    {        if (x)son[x][d] = y;        if (y)f[y] = x;    }    inline void rotate(int x)    {        int fa = f[x], ffa = f[fa], p = get(x), q = get(fa);        connect(fa, son[x][p ^ 1], p);        connect(x, fa, p ^ 1);        connect(ffa, x, q);        pushup(fa), pushup(x);    }    void splay(int x, int ed)    {        for (int fa; fa = f[x], fa != ed; rotate(x))            if (f[fa] != ed)rotate(get(fa) == get(x) ? fa : x);    }    inline int get_minid(int x)    {        splay(x, 0);        return minid[x];    }    int getlast(int x)    {        splay(x, 0);        while (son[x][1])            x = son[x][1];        splay(x, 0);        return x;    }    inline int kth(int x, int rk)    {        splay(x, 0);        while (1)        {            if (sz[ls] &gt;= rk)                x = ls;            else            {                rk -= sz[ls] + 1;                if (!rk)return x;                x = rs;            }        }    }    void movefront(int x)    {        splay(x, 0);        if (!ls)return;        int r = getlast(x);        int y = ls;        ls = 0;        pushup(x);        son[r][1] = y;        f[y] = r;        pushup(r);        splay(x, 0);    }#undef ls#undef rs}using namespace Splay;int p[N], circle_sz[N];set&lt;int&gt; S1[N], S2;int SZ;void print(int x){    if (son[x][0])print(son[x][0]);    printf(\"%d \", x);    if (son[x][1])print(son[x][1]);}inline void add(int x){    splay(x, 0);    circle_sz[minid[x]] = sz[x];    if (sz[x] &lt;= SZ)S1[sz[x]].insert(minid[x]);    else S2.insert(minid[x]);}inline void del(int x){    splay(x, 0);    if (sz[x] &lt;= SZ)S1[sz[x]].erase(minid[x]);    else S2.erase(minid[x]);}void merge(int x, int y){    if (get_minid(x) &gt; get_minid(y))swap(x, y);    del(x), del(y);    movefront(x), movefront(p[y]);    if (x != p[x])    {        splay(x, 0), splay(p[x], x);        son[p[x]][0] = p[y];        f[p[y]] = p[x];        pushup(p[x]);        splay(p[x], 0);    }    else    {        son[x][1] = p[y];        f[p[y]] = x;        pushup(x);        splay(x, 0);    }    add(x);}void divide(int x, int y){    del(x);    movefront(x);    if (sz[x] == 2)    {        splay(x, 0);        son[x][1] = 0;        f[y] = 0;        pushup(x);    }    else    {        if (x == p[y])swap(x, y);        assert(x != p[y]);        splay(x, 0), splay(p[y], x);        int z = son[p[y]][0];        son[p[y]][0] = 0;        f[z] = 0;        pushup(p[y]);        splay(p[y], 0);    }    add(x), add(y);}int main(){    int q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;q);        for (int i = 1; i &lt;= n; i++)            son[i][0] = son[i][1] = 0, S1[i].clear();        S2.clear();        fill(f, f + n + 1, 0);        fill(sz + 1, sz + n + 1, 1);        iota(minid + 1, minid + n + 1, 1);        iota(c + 1, c + n + 1, 1);        iota(p + 1, p + n + 1, 1);        SZ = sqrt(n);        char s[10];        while (q--)        {            ll x, y;            scanf(\"%s%lld%lld\", s, &amp;x, &amp;y);            if (s[0] == 's' &amp;&amp; s[5] == 'a')                swap(c[x], c[y]);            else if (s[0] == 's' &amp;&amp; s[5] == 'p')            {                if (x == y)continue;                if (get_minid(x) != get_minid(y))                    merge(x, y);                else                    divide(x, y);                swap(p[x], p[y]);            }            else            {                ll dif = abs(x - y);                int id = n + 1;                for (int i = 1; i &lt;= SZ; i++)                    if (!S1[i].empty() &amp;&amp; dif % i)                        id = min(id, *S1[i].begin());                for (auto x:S2)                    if (dif % circle_sz[x])                        id = min(id, x);                if (id == n + 1)puts(\"=\");                else                {                    x = (x - 1) % circle_sz[id] + 1;                    y = (y - 1) % circle_sz[id] + 1;                    movefront(id);                    x = kth(id, x);                    y = kth(id, y);                    if (c[x] &lt; c[y])puts(\"&lt;\");                    else puts(\"&gt;\");                }            }        }    }    return 0;}\r\n","tags":["Splay"]},{"title":"CF1716F Bags with Balls 生成函数递推初探","url":"/2022/08/05/CF1716F%20Bags%20with%20Balls%20%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%80%92%E6%8E%A8%E5%88%9D%E6%8E%A2/","content":"\r\n斯特林数展开可以更轻松得推出所求答案，这里用生成函数推导\r\n\r\nconst int N = 2005;int n, m, k;ll f[N][N];const ll mod = 998244353; ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;} int main(){    int p, q, u, v, w, x, y, z, T;    f[0][0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        for (int j = 1; j &lt;= i; j++)            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);        ll ans = 0, now = 1;        for (int i = 0; i &lt;= min(n, k); i++)        {            ans = (ans + now * f[k][i] % mod * fpow(m, n - i) % mod * fpow((m + 1) / 2, i)) % mod;            now = now * (n - i) % mod;        }        printf(\"%lld\\n\", ans);    }    return 0;}\r\n","tags":["Generating Functions","Stirling"]},{"title":"AtCoder Regular Contest 115 E - LEQ and NEQ","url":"/2022/07/29/AtCoder%20Regular%20Contest%20115%20E%20-%20LEQ%20and%20NEQ/","content":"\r\n题意：给定个数，求个数满足下列条件的方案数：  数据范围： \r\n类似杭电多校1多项式题的容斥，但是此时由于的值是不固定的，所以只能写成形式，设为前i个序列的答案，枚举钦定最后个不合法，则有\r\n\r\n单调栈求出作为最小值的左边界，从转移到时只会影响一段后缀，用线段树维护即可，时间复杂度也可以用笛卡尔树做到\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 500005;int n, m, k;ll a[N];int stk[N], L[N];ll lazy[N &lt;&lt; 2];struct point{    ll sum, f;} c[N &lt;&lt; 2];const ll mod = 998244353;inline void pushup(int k){    c[k].sum = (c[k &lt;&lt; 1].sum + c[k &lt;&lt; 1 | 1].sum) % mod;    c[k].f = (c[k &lt;&lt; 1].f + c[k &lt;&lt; 1 | 1].f) % mod;}const ll inf = 1e9;inline void pushdown(int k){    if (lazy[k] != inf)    {        lazy[k &lt;&lt; 1] = lazy[k &lt;&lt; 1 | 1] = lazy[k];        c[k &lt;&lt; 1].sum = c[k &lt;&lt; 1].f * lazy[k] % mod;        c[k &lt;&lt; 1 | 1].sum = c[k &lt;&lt; 1 | 1].f * lazy[k] % mod;        lazy[k] = inf;    }}void update(int L, int R, int l, int r, int k, ll v){    if (L &lt;= l &amp;&amp; r &lt;= R)    {        c[k].sum = v * c[k].f % mod;        lazy[k] = v;        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (L &lt;= m)update(L, R, l, m, k &lt;&lt; 1, v);    if (R &gt; m)update(L, R, m + 1, r, k &lt;&lt; 1 | 1, v);    pushup(k);}void insert(int l, int r, int k, int x, ll v, ll f){    if (l == r)    {        c[k] = {v * f % mod, f};        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (x &lt;= m)insert(l, m, k &lt;&lt; 1, x, v, f);    else insert(m + 1, r, k &lt;&lt; 1 | 1, x, v, f);    pushup(k);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        scanf(\"%lld\", &amp;a[i]);    fill(lazy, lazy + n * 4, inf);    int top = 0;    for (int i = n; i; i--)    {        while (top &amp;&amp; a[stk[top]] &gt;= a[i])            L[stk[top--]] = i;        stk[++top] = i;    }    insert(0, n, 1, 0, 1, 1);    for (int i = 1; i &lt;= n; i++)    {        update(L[i], i - 1, 0, n, 1, mod - a[i] % mod);        if (i == n)cout &lt;&lt; (i &amp; 1 ? mod - 1 : 1) * c[1].sum % mod;        insert(0, n, 1, i, a[i], c[1].sum);    }    return 0;}\r\n","tags":["Inclusion-Exclusion Principle","DP","Data Structure"]},{"title":"ACM之旅","url":"/2022/12/16/ACM%E4%B9%8B%E6%97%85/","content":"\r\n临时赶工的质量，随便看看吧\r\n2020.12.16-2022.12.16\r\n一转眼，我也到了退役的日子，今年的日子相比去年总是过得飞快，些许是更忙碌的原因，两年的ACM之旅为我带来了什么？扎实的码力，志同道合的伙伴，抑或是不健康的作息。一年前自己和队友在集训室看着学长们退役的情景仍然历历在目，想不到这么快就到了我们身上，甚至也复刻了去年7队的遗憾。\r\n2020年12月16日，我在最后一轮选拔赛中因老刘的网开一面成功进入到集训队，此后便是扎身于训练当中，起初一直只刷cf，直到5月在debug杯上被坐在旁边的阿敏n+3之后开始转向洛谷学习算法，此后确实实力大涨，在校赛中成功存活下来(反转了，阿敏不幸地短暂离开了集训队)。\r\n多校前和lmsh,soxsx组成了LSP steaming\r\nbuns(蒸馒头/杭电12队)，一个oier(lmsh)和两个零基础，20场多校之后排名全校rk11，之后由于线上赛的原因获得了上海站的参赛资格，此后开始了一周三场的vp，这支队伍从一开始磨合度就非常良好，也经常能够封榜后出题翻盘，再加上三个人码风非常相似，所以经常能在赛中打出combo，会出现两个人甚至三个人合写一份代码的情况，也会出现一个人写一半写不下去了另一个人能接着写的情况，所以越vp越强，vp到赛前一周的状态，那时候是LSP\r\nsteaming buns 2021年最巅峰的时期，三个人都爆发出了cf\r\nrating(当时队里三个1600，max rating\r\n1800+1800+1900)完全不匹配的实力，尤其是lmsh，借用今年和starry聊天时的描述就是lmsh成为了一个非常典型的oi选手，那个星期的lmsh在我认知中是他整个ACM生涯最强的时间段，那一周里不仅在策略上说不要让机子空下来，又在调节气氛和解决题目上起到了中流砥柱的作用，soxsx则承担了很大一部分的构造和模拟，soxsx的特点是思考问题相对学术化，经常会迸发出意想不到的灵感，而我在场上中后期经常会成为那个21开题的1，当lmsh和soxsx一起讨论题目卡住时(有时这俩会纠结于一些奇奇怪怪的地方，甚至和题目关系不大)偶尔会突然迸发出灵感解决掉自己手上的题。就这样，三个人轮流迸发出灵感，在那段时间三人打满5h的场里基本都是能达到银牌水平，后来我对当时lmsh和soxsx的评价是进入化境。\r\n2021年11月27日，上海站热身赛来临，凭借还不错的状态拿到了校内rk1(众所周知热身赛不能体现真实实力)。\r\n2021年11月28日，上海站正式赛来临，也是lmsh那一年的封神一战，那天主办方要求早上8点就到达比赛场地(但比赛时间是12:00-17:00)，所以带着半梦半醒的状态赶往了实验室，到那之后便是无事可干，后面的学长在玩单机游戏，而我因为电脑上没装什么游戏所以开始敲起了某场div2f的线段树，两个队友则在罚坐，我敲到一半敲不下去，lmsh让我不要敲了放空一下脑子，此后便是三人的罚坐时间(提前罚坐了场上就不会罚坐了)。\r\n直到12点比赛终于开始了，一上来两个人秒了D和E，第三道G是数学+树形dp，我推出了公式，然后lmsh听到我会公式，所以写了个calc接口给我，我稍微调了一下就过了，一波配合非常良好的combo。然后是I题，我当时并不会dp，但是一眼看出了是dp题，队里dp专精手lmsh想了一下两发就把这题过了，然后就去开了M题，一道二分图构造或者猜公式的题，开了许久没有猜出正确的结论，转向了非常困难的H题，kruskal重构树，但当时我们队并没有人学过这个算法，此时lmsh站了出来，在纸上写了一堆草稿+讲了我和soxsx完全听不懂的做法，然后上机写起了代码，留下了一脸懵逼的我和soxsx，lmsh写完wa了一发之后我看soxsx仍然处于懵逼状态就选择了自己造了一组数据，恰好找出了lmsh代码上的问题，第二发提交通过了H，此后转向了K题，构造，三个人想出了一些特殊情况之后我开始上机写暴力验证小数据，但我还没调出暴力时soxsx和lmsh突然就把所有的构造方式都想出来了，然后soxsx上机一发通过了这题，此后是90分钟的罚坐时间，B题多项式，但当时没人学过，lmsh想了一下发现不太可做，我想出了J题的一半，也知道要用bitset，但差了临门一脚，和lmsh讨论了一下无果之后三人开始合力冲M，soxsx用随机模拟的方式模拟出了n=3的情况，但到赛后发现是猜的多项式最高次有问题，所以后面公式一直猜的不对，此后也没有再过题，以rk71(校内rk3)结束上海站，也让我们创造了2021-2022赛季校内同级别队伍的最好成绩。\r\n回想起夺银的那天，去学校美食城的时候整个人也是容光焕发的样子，那一天的成绩确实振奋人心。\r\n此后一个月开始摆烂，不怎么刷题天天打游戏和水群，某一天突然发觉自己仍然有着对金牌的渴望，就又开始刷起了题的同时进入了2022年。\r\n如果说2021年是成功的一年，那么2022年可以说是失败的一年。\r\n寒假里，某算法群由于ay的出现和cupids_bow的疯狂刷题行为加剧了大家的精神内耗，所以我的状态大概就是起床玩会儿手机，吃完午饭开始上机学算法写代码，写到差不多晚上吃饭的时间，回来继续写，晚上有比赛就参加比赛，大概一周6-7天都是这个状态，也因此实力大涨时隔半年重新回到了紫名。3月左右开始了也许是整个生涯最歪的决定————学习多项式，只能说多项式是个高投入低收益的东西，在有其他知识面缺陷的情况下并不太值得花几个月的精力去学习。\r\n四月的时候由于lmsh和soxsx不知道连续摆了多久，都没能通过省赛选拔，我和zn_com,2020hduyz组成了一支临时队伍slow\r\ntime down参加省赛，但在磨合度上并不输LSP steaming\r\nbuns，大概有些默契本就天生形成，赛前的vp各种打穿，尤其是17th\r\nzjcpc，甚至以vp打赢了正式参赛的五点共圆，良好的化学反应和成绩让我们对省赛有着很大把握，可惜正式赛当天，队伍三个人轮流犯病，我和zn_com前期题出现非常大的罚时失误，导致签到题贡献了200分钟罚时，我在201分钟和zn_com打出combo解决第八题之后2020hduyz立即上机开始写第九题，可惜他没完全听懂zn_com的做法导致99分钟没能写完那题，最后差102分钟罚时夺金。\r\n省赛过后的下一星期就是天梯赛，当时我cf达到了历史新高的2000+，由于cf的出色表现老刘把我放在了2队里，那次天梯赛明显变难，模拟题的增多再加上陈越写的松针题面属实不行，所以前面浪费了很多时间，在达到227分左右时只剩下15分钟了，当时也不知道再写个暴力就能拿20多分从而夺金，所以很快就上手写正解，但是没能调出来，最后以230分收场拿下个人二等团队一等。\r\n天梯赛结束之后，由于老刘认为队里4个大二银牌oier(一共就4个oier+2个零基础)达不到金牌水平，所以他们被迫强制退役(至今认为这个决策不合理)，在上海站天神下凡的lmsh也恰好在点杀名单当中(但老刘并不知道具体情况，他对我们队的判断是上半年集体vp打得并不好，实际上是我们队都有课导致经常打一半就少一两个人，所以会出现签到题一整场没人签，中后期题却写掉了的情况，比如台北场)，此后lmsh开始去华为算法岗实习。\r\n2022年5月，我的思维达到了整个生涯最强的时期，并且在5月14日同时也是进队514天时场切2400分题目cf上黄(20届零基础仅三人上黄)，rating2165，那时候遇到2300及以下的思维题总是能想一会儿就出做法，处于整个生涯的思维巅峰状态。\r\n\r\n上黄之后cf就不太怎么关注了，cf刷题力度确实也弱了下来，在疯狂刷洛谷当中，整个人开始陷入套路化，从一个思维选手逐渐转变成了一个套路选手，但思维是油，算法是车，车离开了油终究会跑不动，所以也从黄掉回了紫，也为之后的失败埋下了伏笔。\r\n暑假和void_f,soxsx组成了Oceanic\r\nGlow(杭电11队)，先来讲讲新队友void_f(perdu)，借用和starry聊天时的话语，void_f是一个非常不典型的oier。他会在一些奇怪的地方突然拓展思路，但一旦思路错误会整个人陷入进去并且队友也会跟着陷入进去。\r\nsoxsx也许是突然失去了对acm的热情，整个人开始投入到课内当中(是我课内实验的救星)，第二年除了学了计算几何之外并没有怎么做题，做题水平除了计算几何之外和2021年没什么区别，也是20届零基础里唯一一个没上过紫的，两年加起来刷了1000题，所以第二年的懈怠程度甚至让我在私聊时忍不住喷过一次。\r\n我在暑假里一度失了智，思维能力大不如黄名时期，多校时一度开不出多项式以外的中期题，那时就晚上拼了命的写题，一点两点刷题是常态，但并没有得到什么好的效果。\r\n但最致命的是打法上的冲突导致磨合非常困难，这也是在组队时完全没想到的，我一共经历了三支队伍，唯有这一支，在磨合和默契程度上都大不如以前的队伍，三个人很多时候沟通并不到位，甚至在换位置这件事上也有体现，曾经的队伍三个人的位置在赛中会随便坐，但这支并不会这样，导致很多时候三个人像各打各的，形成一种三人单挑的局面。void_f原来队伍的打法和我们上赛季队伍的打法非常不同，导致整个暑假里我尝试调整了两次策略，但效果其实都不是很好，磨合问题其实到退役都没能解决得非常良好。\r\n虽然有种种问题，但三个人终究实力还是有保证，所以偶尔即使沟通不足也能打出上限，比如多校打出两次校内rk3，但更多的是由于磨合和沟通以及自身实力原因打出非常抽象的下限，比如校内rk8/9/10，导致多校校内排名从rk4掉到rk7(区域赛打完连rk7都没了)，并且亲手丢失一次参加ccpc的机会。\r\n网络赛后我靠着爆刷了一波斜率优化dp补足了dp方面，两年来第一次顿悟dp。\r\n此后开始进入到大量vp阶段，可参考2022-2023赛季VP记录博客，可以发现又是开局猛后期萎，貌似成了这支队伍的通病，越vp越发现自己思维越来越差只会套路，队伍甚至开始卡死在签到题，今年的比赛里唯一一场vp金牌区是2021-2022\r\nec-final，rk21，也vp了今年所有的CCPC，三银一铜，为了练签到专门练了两套comfest，但第二套直接死在了签到，最后一周的三场vp里有两场死在了签到，只打好了一场，Oceanic\r\nGlow的问题开始愈发明显，却不知道如何解决，也直接导致了icpc的失利。\r\n2022年11月13日，西安站来临，三个人没有一个人状态是正常的，签到失误也非常严重，soxsx甚至没写出签到最后我上机调出来，在2队7题时我们队甚至只有3题，两个多小时才签完6题之后三个人又开始了互演时刻，我和soxsx开A开到只剩1h我把代码写完时发现题目读错了，void_f练了一个暑假的网络流却没能切出B，三个人灾难性表现直接导致整把崩盘，甚至没打赢学弟，以铜牌结束比赛，论赛场表现肯定会被去年上海的LSP\r\nsteaming buns吊起来打。\r\n2022年11月27日，济南站来临，也是离夺金最近的一次，但架不住犯病，那天脑子一样由于睡眠不足昏昏沉沉，做题时A这种非常擅长的题目都能算错复杂度并且少优化一个地方，同时伴随的是决策问题，void_f一开始就想到了我没加的那个优化，但是我似乎没有听进去，void_f转而和soxsx开E，void_f出现了上述提到的问题，思路歪了的同时带着soxsx一起陷了进去，后来soxsx突然灵光一现做了出来(模型非常典，也许换黄名时期的我能一眼看出来)，10分钟后我也突然发现A的优化，从而做出A，但此时已经过去127分钟了(所以正确的决策应是soxsx单独开E，我和void_f开A)，然后void_f和soxsx读完长篇大论的D后很快想出了正解，我也很快想出了C的一个解法，写了一发发现是错误的，没考虑子树相对顺序，所以开始和soxsx想C，讨论出了一个非常难写的背包回退写法，在浪费了非常多时间之后终于调出了C，交上去还被卡了时间和空间，卡完常后终于通过，此时过去了268分钟，只剩半小时开G，但是，此时其实仍然有翻盘希望，void_f很早就想出了线段树维护swap操作，soxsx也很快想出了swap次数不会多，相当于两个人拼起来就是正解，但并没有进行充分交流，soxsx选择用不够快的码速敲了一遍题面代码去验了一遍，验出结论是正确时只剩5分钟，宣告济南站以rk58遗憾打银。\r\n最后的结果是和金牌线同题数，差233分钟罚时夺金，也就是要么写签到题A题和E题时不犯病浪费那么长时间，要么写C题时不犯病，要么G题soxsx和void_f加强一下沟通，然后直接上手写，任意做到一个都能夺金，可惜的是一个都没能做到，也成为了多校校内前八支队伍里唯一一支没有夺金的队伍。\r\n整体回想一下三场区域赛，只有大二时期的上海站打得像顺风局，大三的两把都是逆风局，问题出在哪呢，我自己确实也有很大问题，大二时期非常注重思维，思维越练越强，大三开始学了一些useless的算法，思维变得套路化，从思维选手变成了套路选手，导致非常吃题目风格，队伍上的问题相对更大一些，交流并不像前两支队伍一样充分，即使到了结束都没能磨合好这个问题，再加上场上脑子犯病，三个机会里把握一个就能夺金，没把握住也确实可惜。\r\n回想一下整个生涯，两年时间，codeforces、洛谷等等平台再加上组队赛，刷了至少3000道题目，洛谷上蓝紫黑题加起来接近600题，大二区域赛银，省赛银，天梯赛个人二等，大三区域赛银，貌似自己总是拿不到最好的成绩，也许是运气不足，也许是实力不够，也许是训练方法有误。\r\n\r\nACM生涯也到此结束，终于迎来了大学里第一个能休息的假期，不用再没日没夜地敲代码，倒也不错。接下来的计划大概就是寒假里尽量恢复一下实力cf回个黄，实在做不到也就算了，再做一个nonebot，然后背背八股带上lmsh一起跑路投简历下学期去实习了，希望进Iscream2001实习的公司，由于这学期期末考试变成了下学期开学考，所以额外空降的计划就是寒假好好补一下落下的课程，至于下学期的天梯赛和省赛，就看队友的意愿了，毕竟区域赛结束，也宣告ACM告一段落，自己也随之退役了。\r\n"},{"title":"C++多态","url":"/2023/03/13/C++%E5%A4%9A%E6%80%81/","content":"\r\n见到一篇好博客：https://blog.csdn.net/qq_52670477/article/details/121419019\r\n《深度探索C++对象模型》：\r\n\"一个pointer或一个reference之所以支持多态，是因为它们并不引发内存任何“与类型有关的内存委托操作；\r\n会受到改变的。只有它们所指向内存的大小和解释方式 而已\"\r\n1、指针和引用并不涉及内存中对象的类型转换，只改变内存的地址和大小\r\n2、直接调用赋值=会发生转型，\r\n虚函数\r\n虚函数重写\r\n#include &lt;bits/stdc++.h&gt;class A&#123;public:    virtual void foo() &#123; std::cout &lt;&lt; &quot;A&quot; &lt;&lt; std::endl; &#125;&#125;;class B : public A&#123;public:    virtual void foo() &#123; std::cout &lt;&lt; &quot;B&quot; &lt;&lt; std::endl; &#125;&#125;;class C : public B&#123;public:    virtual void foo() &#123; std::cout &lt;&lt; &quot;C&quot; &lt;&lt; std::endl; &#125;&#125;;class D : public A&#123;public:    virtual void foo() &#123; std::cout &lt;&lt; &quot;D&quot; &lt;&lt; std::endl; &#125;&#125;;void fun(A &amp;p)&#123;    p.foo();&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    A a;    B b;    C c;    D d;    A *pa = &amp;a;    B *pb = &amp;b;    C *pc = &amp;c;    D *pd = &amp;d;    pa-&gt;foo();    pb-&gt;foo();    pc-&gt;foo();    pd-&gt;foo();    pa-&gt;foo();    pa = pb;    pa-&gt;foo();    pa = pc;    pa-&gt;foo();    pa = pd;    pa-&gt;foo();    fun(a);    fun(b);    fun(c);    fun(d);    return 0;&#125;\r\n输出： ABCDABCDABCD\r\n若把fun函数参数中的引用去掉 void fun(A p)&#123;    p.foo();&#125;\r\n调用fun(a),fun(b),fun(c),fun(d)的输出会变成 AAAA\r\n虚函数重写只是重写函数的实现，继承的是父类的接口定义(声明)，不会重写函数的缺省参数。\r\n#include &lt;bits/stdc++.h&gt;class A&#123;public:    virtual void foo(int val = 0) &#123; std::cout &lt;&lt; &quot;A&quot; &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;&#125;;class B : public A&#123;public:    virtual void foo(int val = 1) &#123; std::cout &lt;&lt; &quot;B&quot; &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;&#125;;class C : public B&#123;public:    virtual void foo(int val = 2) &#123; std::cout &lt;&lt; &quot;C&quot; &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;&#125;;class D : public A&#123;public:    virtual void foo(int val = 3) &#123; std::cout &lt;&lt; &quot;D&quot; &lt;&lt; &quot; &quot; &lt;&lt; val &lt;&lt; std::endl; &#125;&#125;;void fun(A &amp;p)&#123;    p.foo();&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    A a;    B b;    C c;    D d;    fun(a);    fun(b);    fun(c);    fun(d);    return 0;&#125;\r\n输出: A 0B 0C 0D 0\r\n虚函数重写的例外：\r\n协变\r\n虚函数要求返回值类型相同、函数名相同以及参数列表完全相同，但是协变是个例外，子类重写基类虚函数时，与基类虚函数返回值类型可以不同。但是返回值类型也必须满足父子关系。\r\nfather和son的foo函数返回值类型对调就会报错。\r\n#include &lt;bits/stdc++.h&gt;class A&#123;&#125;;class B : public A&#123;&#125;;class father&#123;public:    virtual A *foo()    &#123;        std::cout &lt;&lt; &quot;father&quot; &lt;&lt; std::endl;        return new A;    &#125;&#125;;class son:public father&#123;public:    virtual B *foo()    &#123;        std::cout &lt;&lt; &quot;son&quot; &lt;&lt; std::endl;        return new B;    &#125;&#125;;void fun(father &amp;p)&#123;    p.foo();&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    father p;    son q;    fun(p);    fun(q);    return 0;&#125;\r\n析构函数的重写(基类与派生类析构函数的名字不同)\r\n如果基类的析构函数为虚函数，此时子类的析构函数只要定义，无论是否添加virtual关键字，都与基类的析构函数构成重写。\r\n虽然基类与派生类析构函数名字不同，但是编译器对析构函数的名字进行了特殊的处理，基类和派生类的析构函数构成隐藏。编译后析构函数的名称同一处理成destructor()，其目的是为了实现析构函数的多态。\r\n这也就导致了一个问题，基类与派生类的析构函数名字相同，那指向派生类的基类指针调用的就是基类的析构函数：\r\n#include &lt;bits/stdc++.h&gt;class A&#123;public:    ~A() &#123; std::cout &lt;&lt; &quot;A&quot; &lt;&lt; std::endl; &#125;&#125;;class B : public A&#123;public:    ~B() &#123; std::cout &lt;&lt; &quot;B&quot; &lt;&lt; std::endl; &#125;&#125;;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    A *pa = new A;    A *pb = new B;    delete pa;    delete pb;    return 0;&#125;\r\n输出:\r\nAA\r\n#include &lt;bits/stdc++.h&gt;class A&#123;public:    virtual ~A() &#123; std::cout &lt;&lt; &quot;A&quot; &lt;&lt; std::endl; &#125;&#125;;class B : public A&#123;public:    ~B() override &#123; std::cout &lt;&lt; &quot;B&quot; &lt;&lt; std::endl; &#125;&#125;;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    A *pa = new A;    A *pb = new B;    delete pa;    delete pb;    return 0;&#125;\r\n输出：\r\nABA\r\n所以，为了不出现内存泄漏的问题，基类的析构函数要加virtual，由于派生类的虚函数不加virtual关键字也可以构成重写，这样在delete就能够实现多态的正确调用析构函数。\r\nC++11 override 和 final\r\noverride：检查派生类虚函数是否重写了基类某个虚函数，如果没有重写编译报错\r\nfinal：修饰虚函数，表示该虚函数不能再被重写\r\n抽象类\r\n在虚函数的后面写上=0，则这个函数为纯虚函数，包含纯虚函数的类叫做抽象类(也叫接口类)，抽象类不能实例化出对象。\r\n派生类继承后也不能实例化出对象，只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。\r\n实现继承：\r\n普通函数的继承是一种实现继承，派生类继承了基类函数的实现，可以使用该函数。\r\n接口继承：\r\n虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态。\r\n建议： 所以如果不实现多态，就不要把函数定义成虚函数。\r\n虚函数表\r\n虚函数表指针 #include &lt;iostream&gt;class A&#123;public:    long long n;    virtual void foo() const &#123;&#125;;    virtual void fun() &#123;&#125;;    virtual void fun1() &#123;&#125;;    virtual void fun2() &#123;&#125;;    virtual void fun3() &#123;&#125;;&#125;;class B&#123;public:    int n;    B()    &#123;    &#125;;    void print() &#123;&#125;;&#125;;inline void fun(const A&amp; a)&#123;    a.foo();&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    A a;    B b;    std::cout &lt;&lt; sizeof(a) &lt;&lt; &quot; &quot; &lt;&lt; sizeof(b) &lt;&lt; std::endl;    return 0;&#125;\r\n\r\n虚函数表指针指向虚表首部地址，虚表存放虚函数，虚表本质是一个存虚函数指针的指针数组。\r\n虚表指针在构造函数阶段（初始化列表）填入到对象中，虚表则是在编译时就生成好了。\r\n虚表里面放的是虚函数地址，虚函数和普通函数一样，编译完成以后，都是放在代码段中。\r\n一个类中所有的虚函数，都会放在虚表中。\r\n子类会将父类的虚表拷贝一份，然后用重写的虚函数地址覆盖掉原来虚表中的函数地址，因此虚函数的重写，也叫虚函数的覆盖。\r\n"},{"title":"NOI2018 屠龙勇士","url":"/2022/07/03/NOI2018%20%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/","content":"\r\n题目所求即为对所有有\r\n\r\n考虑以下同余方程的合并 \r\n\r\n\r\n令\r\n则\r\n设\r\n则通解，，可通过求解\r\n，注意此处不需要乘上系数\r\n\r\n最初添加一个方程即可做到\r\n此时可求出满足同余方程的答案，对于条件扫一遍处理即可 #include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;ll t[N], sword[N];ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if (!b)    {        x = 1;        y = 0;        return a;    }    ll gcd = exgcd(b, a % b, x, y);    ll t = x;    x = y;    y = t - a / b * y;    return gcd;}ll excrt(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;b, vector&lt;ll&gt; &amp;p){    assert(a.size() == b.size() &amp;&amp; a.size() == p.size());    ll A = 0, P = 1;    for (int i = 0; i &lt; a.size(); i++)    {        ll x, y;        ll p1 = P, p2 = p[i];        ll a1 = A, a2 = a[i];        ll b1 = 1, b2 = b[i];        ll m1 = p1 * b2, m2 = p2 * b1;        ll d = exgcd(m1, m2, x, y);        if ((-a1 * b2 + a2 * b1) % d)return -1;        ll lcm = p[i] / d * P;        __int128 k1 = ((__int128) -a1 * b2 + a2 * b1) / d % lcm * x % lcm;        A = (a1 + k1 * p1) % lcm;        P = lcm;    }    A = (A % P + P) % P;    for (int i = 0; i &lt; a.size(); i++)    {        ll now = (a[i] + b[i] - 1) / b[i];        if (A &lt; now)            A += (now - A + P - 1) / P * P;    }    return A;}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        vector&lt;ll&gt; a(n), b(n), p(n);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;a[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;p[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;t[i]);        multiset&lt;ll&gt; st;        for (int i = 0; i &lt; m; i++)            scanf(\"%lld\", &amp;sword[i]), st.insert(sword[i]);        for (int i = 0; i &lt; n; i++)        {            auto p = st.upper_bound(a[i]);            if (p == st.begin())                b[i] = *p;            else b[i] = *--p;            st.erase(p);            st.insert(t[i]);        }        printf(\"%lld\\n\", excrt(a, b, p));    }    return 0;}\r\n","tags":["Number Theory"]},{"title":"C++智能指针","url":"/2023/02/18/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"\r\nauto_ptr\r\nauto_ptr的语义实现，个人体会及注意事项已写在注释中\r\n//auto_ptr的语义实现template&lt;class T&gt;class smart_ptr//不能出现两个smart_ptr的ptr指向同一个地址，否则析构会重复delete{private:    T *ptr;public:    explicit smart_ptr(T *ptr = nullptr) : ptr(ptr) {}    smart_ptr(smart_ptr &amp;rhs)//rhs的ptr变为空    {        ptr = rhs.release();    }    smart_ptr &amp;operator=(smart_ptr &amp;rhs)//赋值之后rhs的ptr为空    {        if (ptr == rhs.get())return *this;//自赋值问题        smart_ptr(rhs).swap(*this);        return *this;    }    ~smart_ptr()    {        delete ptr;    }    T *release()    {        T *_ptr = ptr;        ptr = nullptr;        return _ptr;    }    void swap(smart_ptr &amp;rhs)    {        std::swap(ptr, rhs.ptr);    }    T *get() const { return ptr; }    T &amp;operator*() const { return *ptr; };//空指针访问会报错    T *operator-&gt;() const { return ptr; }    explicit operator bool() const { return ptr; }//用于bool表达式};int main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    smart_ptr&lt;int&gt; A(new int(1)), B(new int(2));    std::cout &lt;&lt; A.get() &lt;&lt; \" \" &lt;&lt; B.get() &lt;&lt; std::endl;    std::cout &lt;&lt; *A &lt;&lt; \" \" &lt;&lt; *B &lt;&lt; std::endl;    A = B;    std::cout &lt;&lt; A.get() &lt;&lt; \" \" &lt;&lt; B.get() &lt;&lt; std::endl;    std::cout &lt;&lt; *A &lt;&lt; std::endl;    A = A;    std::cout &lt;&lt; A.get() &lt;&lt; \" \" &lt;&lt; *A &lt;&lt; std::endl;    return 0;}\r\nshared_ptr\r\nshared_ptr简单版(非线程安全)语义实现\r\n可以使用abi::__cxa_demangle函数得到类的类型从而提高理解\r\n默认赋值运算符为浅拷贝，刚好shared_ptr实现就是基于浅拷贝原理\r\n#include &lt;bits/stdc++.h&gt;#include &lt;cxxabi.h&gt;class shape{public:    virtual ~shape() { std::cout &lt;&lt; \"~shape()\" &lt;&lt; std::endl; }};class circle : public shape{public:    ~circle() { std::cout &lt;&lt; \"~circle()\" &lt;&lt; std::endl; }};class shared_count{private:    int cnt;public:    shared_count() : cnt(1) {}    void add_count() { cnt++; }    int sub_count() { return --cnt; }    int use_count() const { return cnt; }};template&lt;class T&gt;class Shared_ptr{private:    T *ptr;    shared_count *shared_count_ptr;public:    explicit Shared_ptr(T *ptr = nullptr) : ptr(ptr)    {        if (ptr)            shared_count_ptr = new shared_count;    }    Shared_ptr(const Shared_ptr &amp;rhs) : ptr(rhs.ptr)    {        if (ptr)        {            rhs.shared_count_ptr-&gt;add_count();            shared_count_ptr = rhs.shared_count_ptr;        }    }    template&lt;class U&gt; friend    class Shared_ptr;    template&lt;class U&gt;    Shared_ptr(const Shared_ptr&lt;U&gt; &amp;rhs):ptr(rhs.ptr)//隐式转换情况    {        if (ptr)        {            rhs.shared_count_ptr-&gt;add_count();            shared_count_ptr = rhs.shared_count_ptr;        }    }    template&lt;class U&gt;    Shared_ptr(const Shared_ptr&lt;U&gt; &amp;rhs, T *another_ptr):ptr(another_ptr)    {        if (ptr)        {            rhs.shared_count_ptr-&gt;add_count();            shared_count_ptr = rhs.shared_count_ptr;        }    }    template&lt;class U&gt;    Shared_ptr(Shared_ptr&lt;U&gt; &amp;&amp;rhs):ptr(rhs.ptr)//此处并不被编译器视为移动构造函数    {        if (ptr)        {            shared_count_ptr = rhs.shared_count_ptr;            rhs.ptr = nullptr;        }    }    ~Shared_ptr()    {        if (ptr &amp;&amp; shared_count_ptr-&gt;sub_count() == 0)        {            delete ptr;            delete shared_count_ptr;        }    }    Shared_ptr &amp;operator=(Shared_ptr rhs) noexcept    {        rhs.swap(*this);        return *this;    }    void swap(Shared_ptr &amp;rhs)    {        std::swap(ptr, rhs.ptr);        std::swap(shared_count_ptr, rhs.shared_count_ptr);    }    int use_count() const    {        return ptr ? shared_count_ptr-&gt;use_count() : 0;    }    T *get() const    {        return ptr;    }    T &amp;operator*() noexcept { return *ptr; }    T *operator-&gt;() noexcept { return ptr; }    explicit operator bool() const noexcept { return ptr; }};template&lt;class T&gt;Shared_ptr&lt;T&gt; swap(const Shared_ptr&lt;T&gt; &amp;lhs, const Shared_ptr&lt;T&gt; &amp;rhs)noexcept{    lhs.swap(rhs);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; static_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = static_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; reinterpret_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = reinterpret_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; const_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = const_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; dynamic_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = dynamic_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}int main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    Shared_ptr&lt;circle&gt; p1(new circle);    std::cout &lt;&lt; \"use count of p1 = \" &lt;&lt; p1.use_count() &lt;&lt; std::endl;    Shared_ptr&lt;shape&gt; p2;    std::cout &lt;&lt; \"use count of p2 = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl;    std::cout &lt;&lt; abi::__cxa_demangle(typeid(p1).name(), 0, 0, 0) &lt;&lt; std::endl;    p2 = p1;    std::cout &lt;&lt; \"use count of p2 = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl;    if (p1)        std::cout &lt;&lt; \"p1 is not empty\" &lt;&lt; std::endl;    Shared_ptr&lt;circle&gt; p4 = p1;    std::cout &lt;&lt; \"use count of p4 = \" &lt;&lt; p4.use_count() &lt;&lt; std::endl;    p4 = p1;//注意171行调用拷贝构造函数,173行调用赋值重载运算符    Shared_ptr&lt;circle&gt; p3 = dynamic_pointer_cast&lt;circle&gt;(p2);//默认赋值运算符为浅拷贝    std::cout &lt;&lt; \"use count of p3 = \" &lt;&lt; p3.use_count() &lt;&lt; std::endl;    return 0;}\r\n","tags":["C++"]},{"title":"P3746 组合数问题 循环卷积","url":"/2022/07/13/P3746%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%20%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/","content":"\r\n给定四个整数 ，求\r\n\r\n\r\n转化为循环卷积\r\nconst int N = 300005;int n, m, k;ll mod;using poly = vector&lt;ll&gt;;poly operator*(const poly &amp;a, const poly &amp;b){    poly c(k);    for (int i = 0; i &lt; a.size(); i++)        for (int j = 0; j &lt; b.size(); j++)            c[(i + j) % k] = (c[(i + j) % k] + a[i] * b[j]) % mod;    return c;}poly fpow(poly x, ll r){    poly ans{1};    while (r)    {        if (r &amp; 1)ans = ans * x;        r &gt;&gt;= 1;        x = x * x;    }    return ans;}int main(){    int p, q, u, v, w, x, y, z, T;    int r;    cin &gt;&gt; n &gt;&gt; mod &gt;&gt; k &gt;&gt; r;    poly F{1, 1};    cout &lt;&lt; fpow(F, 1ll * n * k)[r];    return 0;}\r\n","tags":["Generating Functions","FFT"]},{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"\r\n设权值为的答案为，对应OGF为，集合对应的OGF为\r\n考虑，枚举二叉树左右子树的方案数和根的值，可得\r\n\r\n均大于0,所以只有为空树的一种情况即，可得\r\n\r\n，代入和 ，可得 \r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"P5293 [HNOI2019]白兔之舞","url":"/2022/07/05/P5293%20%5BHNOI2019%5D%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/","content":"\r\n设为白兔跳了次终点为的方案数 \r\n可以用矩阵优化，则跳次可以用矩阵表示为,为行向量，初始只有第列为1，为输入矩阵\r\n设，那么最终在第个点结束的答案为，即行向量的第列\r\n接下来求方案数 单位根反演\r\n令 可通过矩阵预处理得出，为次单位根，可通过求原根之后求出\r\n算法变换\r\n差卷积即可 ll get_r(){    vector&lt;int&gt; vec;    ll now = mod - 1;    for (int i = 2; i * i &lt;= now; i++)    {        if (now % i)continue;        vec.emplace_back(i);        while (now % i == 0)now /= i;    }    for (int g = 2;; g++)    {        bool flag = true;        for (auto p:vec)            if (fpow(g, (mod - 1) / p) == 1)            {                flag = false;                break;            }        if (flag)return g;    }}ll wk[N];int main(){    ll p, q, u, v, x, y, z, T;    ll L;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; mod;    matrix Z;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            scanf(\"%lld\", &amp;Z.a[i][j]);    ll r = get_r();    ll w = fpow(r, (mod - 1) / k);    wk[0] = 1;    for (int i = 1; i &lt; k; i++)        wk[i] = wk[i - 1] * w % mod;    poly h(k);    for (int i = 0; i &lt; k; i++)    {        matrix f;        f.a[1][x] = 1;        f = f * (Z * wk[i] + matrix::E()).fpow(L);        h[i] = f.a[1][y];    }    poly F(2 * k - 1), G(k);    for (int i = 0; i &lt; k; i++)        G[i] = h[i] * fpow(w, 1ll * i * (i - 1) / 2) % mod;    for (int i = 0; i &lt; 2 * k - 1; i++)        F[i] = fpow(fpow(w, mod - 2), 1ll * i * (i - 1) / 2);    F = F * G.rev();    const ll invk = fpow(k, mod - 2);    for (int i = 0; i &lt; k; i++)        printf(\"%lld\\n\", fpow(w, 1ll * i * (i - 1) / 2) * invk % mod * F[k - 1 + i] % mod);    return 0;}\r\n","tags":["Generating Functions","Bluestein"]},{"title":"STL容器的一些细节问题","url":"/2023/02/27/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/","content":"\r\nvector通常保证强异常安全性\r\n当 push_back、insert、reserve、resize\r\n等函数导致内存重分配时，或当insert、erase 导致元素位置移动时，vector\r\n会试图把元素“移动”到新的内存区域。vector通常会保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector通常会使用拷贝构造函数。因此对于拷贝代价较高的自定义元素类型，我们应定义移动构造函数，并标其为noexcept，或只在容器内放置对象的只能指针。\r\n考虑以下一段代码\r\nclass Obj1{public:    Obj1()    {        std::cout &lt;&lt; \"Obj1()\\n\";    }    Obj1(const Obj1 &amp;)    {        std::cout &lt;&lt; \"Obj1(const Obj1&amp;)\\n\";    }    Obj1(Obj1 &amp;&amp;)    {        std::cout &lt;&lt; \"Obj1(Obj1&amp;&amp;)\\n\";    }};class Obj2{public:    Obj2()    {        std::cout &lt;&lt; \"Obj2()\\n\";    }    Obj2(const Obj2 &amp;)    {        std::cout &lt;&lt; \"Obj2(const Obj2&amp;)\\n\";    }    Obj2(Obj2 &amp;&amp;) noexcept    {        std::cout &lt;&lt; \"Obj2(Obj2&amp;&amp;)\\n\";    }};\r\nint main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::vector&lt;Obj1&gt; vec1;    vec1.reserve(2);    vec1.emplace_back();    vec1.emplace_back();    vec1.emplace_back();    std::cout &lt;&lt; std::endl;    std::vector&lt;Obj2&gt; vec2;    vec2.reserve(2);    vec2.emplace_back();    vec2.emplace_back();    vec2.emplace_back();    return 0;}\r\n输出: Obj1()Obj1()Obj1()Obj1(const Obj1&amp;)Obj1(const Obj1&amp;)Obj2()Obj2()Obj2()Obj2(Obj2&amp;&amp;)Obj2(Obj2&amp;&amp;)\r\nObj1和Obj2仅仅相差了一个noexcept，但这个小小的差异会导致vector是否会移动对象，这点非常重要。\r\n将main函数中的代码稍微更改一下\r\nint main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::vector&lt;Obj1&gt; vec1;    vec1.reserve(2);    vec1.push_back(Obj1());//这种写法会被clangd检查建议优化，这里只是刚好需要这种写法。    vec1.push_back(Obj1());    vec1.push_back(Obj1());    std::cout &lt;&lt; std::endl;    std::vector&lt;Obj2&gt; vec2;    vec2.reserve(2);    vec2.push_back(Obj2());    vec2.push_back(Obj2());    vec2.push_back(Obj2());    return 0;}\r\n输出： Obj1()Obj1(Obj1&amp;&amp;)Obj1()Obj1(Obj1&amp;&amp;)Obj1()Obj1(Obj1&amp;&amp;)Obj1(const Obj1&amp;)Obj1(const Obj1&amp;)Obj2()Obj2(Obj2&amp;&amp;)Obj2()Obj2(Obj2&amp;&amp;)Obj2()Obj2(Obj2&amp;&amp;)Obj2(Obj2&amp;&amp;)Obj2(Obj2&amp;&amp;)\r\n可以看出由于Obj1()/Obj2()只是个临时对象，即使移动时出现异常也不会有什么损失，因此push_back时会调用移动构造函数，但对于vector内部元素移动的情况，如果出现异常可能会导致vector的状态彻底混乱了，所以在不保证不出现异常的情况下会调用拷贝构造函数。\r\nstack/queue为什么pop函数返回值为void\r\n在《C++ Concurrency In Action》书中有一段描述：\r\n\r\n\r\n\r\n假设有一个stack&lt;vector&gt;，vector是一个动态容器，当你拷贝一个vector时，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以vector的拷贝构造函数可能会抛出一个std::bad_alloc异常。当vector中存有大量元素时，这种情况发生的可能性更大。当pop()函数返回“弹出值”时(也就是从栈中将这个值移除)，会有一个潜在的问题：这个值被返回到调用函数的时候，栈才被改变；但当拷贝数据的时候，调用函数抛出一个异常会怎么样？如果事情真的发生了，要弹出的数据将会丢失；它的确从栈上移出了，但是拷贝失败了！std::stack的设计人员将这个操作分为两个部分：先获取顶部元素(top())，然后从栈中移除元素(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足时，应用可能会释放一些内存，然后再进行尝试。\r\n\r\n\r\n\r\nC++98里没有移动构造的概念，返回数据类型可能会出现异常安全问题，这是C++98时设计的接口。\r\n","tags":["C++"]},{"title":"字面量运算符、静态断言","url":"/2023/03/03/%E5%AD%97%E9%9D%A2%E9%87%8F%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E9%9D%99%E6%80%81%E6%96%AD%E8%A8%80/","content":"\r\n字面量运算符\r\n字面量运算符只能以_开头，仅允许包括const char*, long double, unsigned\r\nlong long int, char等在内的形参列表\r\n#include &lt;bits/stdc++.h&gt;class length&#123;private:    double value;public:    enum unit    &#123;        meter,        kilometer,        millimeter,        centimeter,        inch,        foot,        yard,        mile    &#125;;    static constexpr double factors[] = &#123;            1.0, 1000.0, 1e-3, 1e-2, 0.0254, 0.3048, 0.9144, 1609.344    &#125;;    explicit length(double v, unit u = meter)    &#123;        value = v * factors[u];    &#125;    friend length operator+(length lhs, length rhs)    &#123;        return length(lhs.value + rhs.value);    &#125;    double get() const noexcept &#123; return value; &#125;&#125;;length operator &quot;&quot; _m(long double v)&#123;    return length(v, length::meter);&#125;length operator &quot;&quot; _cm(long double v)&#123;    return length(v, length::centimeter);&#125;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::cout &lt;&lt; (1.0_m + 10.0_cm).get() &lt;&lt; std::endl;    return 0;&#125;\r\n静态断言\r\n在编译期对表达式进行判断\r\n\r\n\r\n\r\n\r\n","tags":["C++"]},{"title":"左偏红黑树实现","url":"/2023/04/05/%E5%B7%A6%E5%81%8F%E7%BA%A2%E9%BB%91%E6%A0%91%E5%AE%9E%E7%8E%B0/","content":"\r\n以下为洛谷P3369和LibreOJ#104普通平衡树的AC代码\r\n洛谷P6136 【模板】普通平衡树（数据加强版）也已AC\r\n#include &lt;bits/stdc++.h&gt;template&lt;class Key, class Compare=std::less&lt;Key&gt;&gt;class RB_Tree{private:    enum class Node_Color    {        BLACK = 0, RED = 1    };    struct Node    {        Key key;        Node *left{nullptr}, *right{nullptr}, *father{nullptr};        Node_Color color;        size_t node_cnt{1}, size;        Node() = default;        Node(Key key, Node_Color color, size_t size, Node *father)                : key(key), color(color), size(size), father(father) {}    } *root{nullptr};    Compare cmp;    using KeyType = Key;    void Destroy_Tree(Node *root) const    {        if (root != nullptr)        {            Destroy_Tree(root-&gt;left);            Destroy_Tree(root-&gt;right);            delete root;        }    }    bool is_red(const Node *u) const { return u == nullptr ? false : u-&gt;color == Node_Color::RED; }    size_t size(const Node *u) const { return u == nullptr ? 0 : u-&gt;size; }    Node *rotate_left(Node *u) const    {        // left rotate a red link        //          &lt;u&gt;                   &lt;v&gt;        //        /    \\\\               //    \\        //       *      &lt;v&gt;    ==&gt;     &lt;u&gt;     *        //             /   \\          /   \\        //            *     *        *     *        assert(is_red(u-&gt;right));        Node *v = u-&gt;right;        u-&gt;right = v-&gt;left;        v-&gt;left = u;        if (u-&gt;right)u-&gt;right-&gt;father = u;        v-&gt;father = u-&gt;father;        u-&gt;father = v;        v-&gt;color = u-&gt;color;        u-&gt;color = Node_Color::RED;        v-&gt;size = u-&gt;size;        u-&gt;size = size(u-&gt;left) + size(u-&gt;right) + u-&gt;node_cnt;        return v;    }    Node *rotate_right(Node *u) const    {        // right rotate a red link        //            &lt;u&gt;               &lt;v&gt;        //          //    \\           /    \\\\        //         &lt;v&gt;     *   ==&gt;   *      &lt;u&gt;        //        /   \\                    /   \\        //       *     *                  *     *        assert(is_red(u-&gt;left));        Node *v = u-&gt;left;        u-&gt;left = v-&gt;right;        v-&gt;right = u;        if (u-&gt;left)u-&gt;left-&gt;father = u;        v-&gt;father = u-&gt;father;        u-&gt;father = v;        v-&gt;color = u-&gt;color;        u-&gt;color = Node_Color::RED;        v-&gt;size = u-&gt;size;        u-&gt;size = size(u-&gt;left) + size(u-&gt;right) + u-&gt;node_cnt;        return v;    }    void Negate_Node_Color(Node *u) const    {        u-&gt;color = u-&gt;color == Node_Color::RED ? Node_Color::BLACK : Node_Color::RED;    }    void color_flip(Node *u) const    {        Negate_Node_Color(u);        Negate_Node_Color(u-&gt;left);        Negate_Node_Color(u-&gt;right);    }    Node *get_key_node(const KeyType &amp;key) const;    Node *insert(Node *root, const KeyType &amp;key, Node *father) const;    Node *fix_up(Node *root) const;    const KeyType &amp;get_min_key(Node *root) const;    size_t get_min_node_cnt(Node *root) const;    Node *delete_min_node(Node *root);    Node *delete_arbitrary_node(Node *root, const KeyType &amp;key);    Node *move_red_left(Node *root);    Node *move_red_right(Node *root);    void Print_Tree(Node *root, int indent) const;    Node *left_node(Node *u) const;//直接前驱    Node *right_node(Node *u) const;//直接后继public:    ~RB_Tree() { Destroy_Tree(root); }    size_t size() const { return root == nullptr ? 0 : root-&gt;size; };    void insert(const KeyType &amp;key);    bool erase(const KeyType &amp;key);    size_t count(const KeyType &amp;key) const;    void Print_Tree() const//脑袋逆时针旋转90度看输出    {        Print_Tree(root, 0);        std::cout &lt;&lt; std::endl;    }    size_t get_rank(const KeyType &amp;x) const;    const KeyType &amp;kth(size_t rank) const;    const KeyType &amp;predecessor(const KeyType &amp;key);//前驱    const KeyType &amp;successor(const KeyType &amp;key);//后继};template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::get_key_node(const KeyType &amp;key) const{    Node *u = root;    while (u != nullptr)    {        if (key == u-&gt;key)return u;        else if (cmp(key, u-&gt;key))u = u-&gt;left;        else u = u-&gt;right;    }    return nullptr;}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::fix_up(Node *root) const{    if (is_red(root-&gt;right) &amp;&amp; !is_red(root-&gt;left))        root = rotate_left(root);    if (is_red(root-&gt;left) &amp;&amp; is_red(root-&gt;left-&gt;left))        root = rotate_right(root);    if (is_red(root-&gt;left) &amp;&amp; is_red(root-&gt;right))        color_flip(root);    root-&gt;size = size(root-&gt;left) + size(root-&gt;right) + root-&gt;node_cnt;    return root;}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::insert(Node *root, const KeyType &amp;key, Node *father) const{    if (root == nullptr)return new Node(key, Node_Color::RED, 1, father);    if (root-&gt;key == key)        root-&gt;node_cnt++;    else if (cmp(key, root-&gt;key))//key &lt; root-&gt;key        root-&gt;left = insert(root-&gt;left, key, root);    else        root-&gt;right = insert(root-&gt;right, key, root);    return fix_up(root);}template&lt;class Key, class Compare&gt;void RB_Tree&lt;Key, Compare&gt;::insert(const KeyType &amp;key){    root = insert(root, key, nullptr);    root-&gt;color = Node_Color::BLACK;}template&lt;class Key, class Compare&gt;size_t RB_Tree&lt;Key, Compare&gt;::count(const KeyType &amp;key) const{    Node *u = root;    while (u != nullptr)    {        if (key == u-&gt;key)return u-&gt;node_cnt;        else if (cmp(key, u-&gt;key))u = u-&gt;left;        else u = u-&gt;right;    }    return 0;}template&lt;class Key, class Compare&gt;const typename RB_Tree&lt;Key, Compare&gt;::KeyType &amp;RB_Tree&lt;Key, Compare&gt;::get_min_key(Node *root) const{    while (root-&gt;left != nullptr)        root = root-&gt;left;    return root-&gt;key;}template&lt;class Key, class Compare&gt;size_t RB_Tree&lt;Key, Compare&gt;::get_min_node_cnt(Node *root) const{    while (root-&gt;left != nullptr)        root = root-&gt;left;    return root-&gt;node_cnt;}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::move_red_left(Node *root){    color_flip(root);    if (is_red(root-&gt;right-&gt;left))//根据原理此时貌似不会出现root-&gt;right为空指针的情况    {        root-&gt;right = rotate_right(root-&gt;right);        root = rotate_left(root);        color_flip(root);    }    return root;}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::move_red_right(Node *root){    color_flip(root);    if (is_red(root-&gt;left-&gt;left))    {        root = rotate_right(root);        color_flip(root);    }    return root;}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::delete_min_node(Node *root){    if (root-&gt;left == nullptr)    {        delete root;        return nullptr;    }    if (!is_red(root-&gt;left) &amp;&amp; !is_red(root-&gt;left-&gt;left))        root = move_red_left(root);    root-&gt;left = delete_min_node(root-&gt;left);    return fix_up(root);}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::delete_arbitrary_node(Node *root, const KeyType &amp;key){    if (cmp(key, root-&gt;key))//key &lt; root-&gt;key    {        if (!is_red(root-&gt;left) &amp;&amp; !is_red(root-&gt;left-&gt;left))            root = move_red_left(root);        root-&gt;left = delete_arbitrary_node(root-&gt;left, key);    }    else    {        if (is_red(root-&gt;left))root = rotate_right(root);//向右走要保证root或者root-&gt;rc是红色节点        if (key == root-&gt;key &amp;&amp; root-&gt;right == nullptr)        {            delete root;            return nullptr;        }        //否则以右子树里最小值替代        if (!is_red(root-&gt;right) &amp;&amp; !is_red(root-&gt;right-&gt;left))            root = move_red_right(root);        if (key == root-&gt;key)        {            root-&gt;key = get_min_key(root-&gt;right);            root-&gt;node_cnt = get_min_node_cnt(root-&gt;right);            root-&gt;right = delete_min_node(root-&gt;right);        }        else            root-&gt;right = delete_arbitrary_node(root-&gt;right, key);    }    return fix_up(root);}template&lt;class Key, class Compare&gt;bool RB_Tree&lt;Key, Compare&gt;::erase(const KeyType &amp;key){    Node *u = get_key_node(key);    if (u == nullptr)return false;    else if (u-&gt;node_cnt &gt; 1)    {        u-&gt;node_cnt--;        while (u)        {            u-&gt;size = size(u-&gt;left) + size(u-&gt;right) + u-&gt;node_cnt;            u = u-&gt;father;        }        return true;    }    else    {        root = delete_arbitrary_node(root, key);        if (root != nullptr)root-&gt;color = Node_Color::BLACK;        return true;    }}template&lt;class Key, class Compare&gt;size_t RB_Tree&lt;Key, Compare&gt;::get_rank(const KeyType &amp;key) const{    int rank = 1;    Node *u = root;    while (u != nullptr)    {        if (cmp(key, u-&gt;key))u = u-&gt;left;        else        {            rank += size(u-&gt;left);            if (key == u-&gt;key)return rank;            rank += u-&gt;node_cnt;            u = u-&gt;right;        }    }    return rank;}template&lt;class Key, class Compare&gt;const typename RB_Tree&lt;Key, Compare&gt;::KeyType &amp;RB_Tree&lt;Key, Compare&gt;::kth(size_t rank) const{    Node *u = root;    while (u != nullptr)    {        if (size(u-&gt;left) &gt;= rank)            u = u-&gt;left;        else        {            rank -= size(u-&gt;left);            if (rank &lt;= u-&gt;node_cnt)return u-&gt;key;            rank -= u-&gt;node_cnt;            u = u-&gt;right;        }    }    throw std::runtime_error(\"rank &gt; size(root)\");}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::left_node(Node *u) const{    if (u-&gt;left == nullptr)    {        while (u-&gt;father &amp;&amp; u-&gt;father-&gt;left == u)            u = u-&gt;father;        u = u-&gt;father;    }    else    {        u = u-&gt;left;        while (u-&gt;right)            u = u-&gt;right;    }    return u;}template&lt;class Key, class Compare&gt;typename RB_Tree&lt;Key, Compare&gt;::Node *RB_Tree&lt;Key, Compare&gt;::right_node(Node *u) const{    if (u-&gt;right == nullptr)    {        while (u-&gt;father &amp;&amp; u-&gt;father-&gt;right == u)            u = u-&gt;father;        u = u-&gt;father;    }    else    {        u = u-&gt;right;        while (u-&gt;left)            u = u-&gt;left;    }    return u;}template&lt;class Key, class Compare&gt;const typename RB_Tree&lt;Key, Compare&gt;::KeyType &amp;RB_Tree&lt;Key, Compare&gt;::predecessor(const KeyType &amp;key){    Node *u = root, *final_node = nullptr;    while (u != nullptr)    {        final_node = u;        if (cmp(u-&gt;key, key))u = u-&gt;right;        else u = u-&gt;left;//key == u-&gt;key向左走    }    if (cmp(final_node-&gt;key, key))        return final_node-&gt;key;    else        return left_node(final_node)-&gt;key;//注意key == final_node-&gt;key情况}template&lt;class Key, class Compare&gt;const typename RB_Tree&lt;Key, Compare&gt;::KeyType &amp;RB_Tree&lt;Key, Compare&gt;::successor(const KeyType &amp;key){    Node *u = root, *final_node = nullptr;    while (u != nullptr)    {        final_node = u;        if (cmp(key, u-&gt;key))u = u-&gt;left;        else u = u-&gt;right;//key == u-&gt;key向右走    }    if (cmp(key, final_node-&gt;key))        return final_node-&gt;key;    else        return right_node(final_node)-&gt;key;}template&lt;class Key, class Compare&gt;void RB_Tree&lt;Key, Compare&gt;::Print_Tree(Node *root, int indent) const{    if (root == nullptr)return;    Print_Tree(root-&gt;right, indent + 4);    std::cout &lt;&lt; std::string(indent, '-') &lt;&lt; root-&gt;key &lt;&lt; '\\n';    Print_Tree(root-&gt;left, indent + 4);}int main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    RB_Tree&lt;int&gt; st;    int n;    std::cin &gt;&gt; n;    while (n--)    {        int op, x;        std::cin &gt;&gt; op &gt;&gt; x;        switch (op)        {            case 1:                st.insert(x);                break;            case 2:                st.erase(x);                break;            case 3:                std::cout &lt;&lt; st.get_rank(x) &lt;&lt; '\\n';                break;            case 4:                std::cout &lt;&lt; st.kth(x) &lt;&lt; '\\n';                break;            case 5:                std::cout &lt;&lt; st.predecessor(x) &lt;&lt; '\\n';                break;            case 6:                std::cout &lt;&lt; st.successor(x) &lt;&lt; '\\n';                break;            default:                assert(0);        }    }    return 0;}\r\n","tags":["Data Structure"]},{"title":"洛谷P4389 付公主的背包","url":"/2022/04/03/%E6%B4%9B%E8%B0%B7P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","content":"\r\n设商品体积为的为， \r\n则所求答案为\r\n麦克劳林公式展开后可得 \r\n枚举倍数后可得系数，再求一次多项式即可得到答案，时间复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }        poly exp(int n)//需要保证f[0]=1        {            poly a{1};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * (poly{1} - a.ln(k) + modxk(k))).modxk(k);            }            return a.modxk(n);        }#undef T    };}using namespace polybase;int cnt[N];ll inv[N];int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        scanf(\"%d\", &amp;x), cnt[x]++;    for (int i = 1; i &lt;= m; i++)        inv[i] = fpow(i, mod - 2);    poly F(m + 1);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; i * j &lt;= m; j++)            F[i * j] = (F[i * j] + inv[j] * cnt[i]) % mod;    F = F.exp(m + 1);    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"快速沃尔什变换/快速莫比乌斯变换","url":"/2022/04/10/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%20%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/","content":"\r\n笔者对快速沃尔什变换/快速莫比乌斯变换的理解也只是刚学阶段，本文只是写写自己的理解和一些其他博客略去的证明。(还没写完的部分可能会咕咕咕一段时间再写)\r\n前置知识：卷积\r\n对于多项式卷积，其思想是对于两个多项式，首先经过转换为点值表示得到，令，再对作一次转化为数组即为答案。\r\n那么类比多项式卷积，位运算卷积也可以类似定义，第项和第项的乘积贡献到第项，则，此处对应某种位运算，那么只需要构造一种转换满足就能实现时间复杂度的位运算卷积(论构造手为什么是神)，具体构造方法可以由数学推导得出+真值表+矩阵求逆得出，由于笔者处于初学阶段，暂不去推构造证明\r\n以下只讲与、或、异或三种位运算卷积且序列长度为的幂\r\n与\r\n\r\n\r\n构造  这样就可以在时间求出和的乘积，现在只需快速求出变换和\r\n设序列长度为，下标范围为，由于和位运算的特殊性，考虑对按位分治，设\r\n设是下标为的序列，是下标为的序列，如果已经求出了和，那么只要计算和相互的贡献就能求出\r\n对于，有，考虑二进制表示，则在二进制表示上比多一个最高位的，即，因此对于任意若满足，也一定满足，又和构成双射，那么对于，在上恰好对有一次贡献，在上不变，因此可以推出下式：\r\n在区间上为，在区间上为 那么的分治就完成了\r\n再对序列做就能得到答案序列经过变换后的序列\r\n对于，即为的反演，考虑矩阵\r\n 行变换后可得  (这部分矩阵证明反演笔者也不知道是否合理，凭感觉写的)\r\n那么可以推出下式： 在区间上为，在区间上为 就能得到最终的答案序列\r\nvoid mul(int n){    for (int i = 0; i &lt; n; i++)        a[i] = a[i] * b[i] % mod;}void AND(ll *f, ll x, int n){    for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1)        for (int i = 0; i &lt; n; i += o)            for (int j = 0; j &lt; k; j++)                f[i + j] = (f[i + j] + f[i + j + k] * x) % mod;}void FWT_AND(){    AND(a, 1, n), AND(b, 1, n), mul(n), AND(a, mod - 1, n)}\r\n剩下的部分咕咕咕\r\n","tags":["Math","FWT","FMT"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"\r\n设个点的简单有标号无向图的数目为,对应为\r\n个点的简单有标号无向连通图的数目为,对应为\r\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\r\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\r\n所以，答案即为\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"洛谷P4491 [HAOI2018]染色","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4491%20%5BHAOI2018%5D%E6%9F%93%E8%89%B2/","content":"\r\n设为钦定种颜色，每种颜色恰好出现了次的方案数，设为恰好种颜色，每种颜色恰好出现了次的方案数\r\n考虑钦定k种颜色能得到的方案数，可得\r\n\r\n阶乘预处理后即可时间内算出\r\n然后考虑和之间的关系，有 \r\n二项式反演后可得 \r\n差卷积后乘上对应值即可得出答案，总复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 10000005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    int s;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    poly W(m + 1);    for (int i = 0; i &lt;= m; i++)        scanf(\"%d\", &amp;W[i]);    poly F(m + 1);    for (int i = min(n / s, m); i &gt;= 0; i--)        F[i] = fac[m] * ifac[m - i] % mod * fac[n] % mod * fpow(ifac[s], i) % mod *               ifac[n - i * s] % mod * fpow(m - i, n - i * s) % mod;    poly H(m + 1);    for (int i = 0; i &lt;= m; i++)        H[m - i] = (i &amp; 1 ? mod - 1 : 1) * ifac[i] % mod;    poly G = F * H;    ll ans = 0;    for (int i = 0; i &lt;= m; i++)        ans = (ans + G[m + i] * ifac[i] % mod * W[i]) % mod;    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"返回值","url":"/2023/03/03/%E8%BF%94%E5%9B%9E%E5%80%BC/","content":"\r\n\r\n起初没有理解这段话，之后顿悟到表达式结果需要是prvalue才能调用移动构造函数，也就是说是一个字面值或者不具名的临时对象。此后写了以下代码\r\n#include &lt;bits/stdc++.h&gt;template&lt;class T&gt;class info&#123;private:    T x;public:    explicit info(T x = 0) : x(x) &#123; std::cout &lt;&lt; 777 &lt;&lt; std::endl; &#125;    info(const info &amp;rhs) : x(rhs.x) &#123; std::cout &lt;&lt; 444 &lt;&lt; std::endl; &#125;    info(info &amp;&amp;rhs) noexcept: x(rhs.x)    &#123;        rhs.x = 0;        std::cout &lt;&lt; 555 &lt;&lt; std::endl;    &#125;    friend info operator+(const info &amp;lhs, const info &amp;rhs)    &#123;        info c;        c.x = lhs.x + rhs.x;        return c;    &#125;    T get() const noexcept &#123; return x; &#125;&#125;;int main()&#123;    std::ios::sync_with_stdio(false);    std::cin.tie(0);    info a(1), b(2);    info c = a + b;    std::cout &lt;&lt; c.get() &lt;&lt; std::endl;    return 0;&#125;\r\n输出： 7777777775553\r\n输出时一度发现没有555，后来查到是编译器默认开启返回值优化(RVO)，添加编译命令\"-fno-elide-constructors\"关闭返回值优化后得到想要的答案。\r\n","tags":["C++"]},{"title":"转置原理和多项式多点求值","url":"/2022/06/09/%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86%E5%92%8C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/","content":"这篇博客背后是阅读十数篇博客和高强度悟道\r\n矩阵的初等变换和初等矩阵:\r\n三种矩阵初等变换\r\n\r\n交换矩阵两行(列)\r\n对一行(列)乘\r\n将第行乘加给第行\r\n\r\n对单位矩阵实施一次初等变换得到的矩阵称为初等矩阵。\r\n一种初等变换对应一个初等矩阵\r\n一个可逆矩阵可分为多个初等矩阵相乘\r\n转置原理：\r\n转置定理：如果，可得\r\n线性算法的转置：\r\n\r\n已知矩阵，输入向量，向量为左乘的运算结果，求解的算法为线性算法\r\n称与互为转置\r\n若矩阵可逆，可分为若干个初等矩阵相乘 此时若算法较难求出，可先求解的优化方法即 的优化方法，求出的优化方法后以相反的运算顺序即可求出的优化方法，具体原理可以参考其他博客，笔者高强度悟道才理解此处\r\n\r\n多项式乘法\r\n对于一个多项式次多项式和次多项式,令，可知将看作向量，看作矩阵\r\n以举例，考虑矩阵形式：\r\n 该线性算法转置为  即，可见加法卷积的转置为减法卷积，加法卷积的转置标记为\r\n多项式多点求值\r\n给定一个次多项式，现在请你对于，求出 。\r\n不妨都将长度扩充到，长度不够的地方补充0，以下令\r\n考虑该算法的矩阵形式  求点值的过程为线性变换，矩阵A为范德蒙德矩阵，可分为若干个初等矩阵扩充为n阶方阵后运算得到，并不影响推导(应该吧)。\r\n考虑该算法的转置，易知\r\n 该式可用分治快速求出 令分子为，分母为，则\r\n\r\n以上为转置算法的解\r\n接下来考虑原算法，可知与多项式无关，可视为列向量，对应转置算法为\r\n\r\n线段树预处理数组\r\n由转置原理的第三条和多项式乘法的转置可知自顶向下求解，顶部求出\r\n由转置算法中分子的运算过程可得原算法的逆过程： \r\n叶子节点即为答案\r\n\r\n该算法常数小且易于实现，难点在于高强度悟道\r\n这篇博客中有很多东西并没有讲清楚，许多细节以笔者的水平难以表达出来，同时笔者对线代的理解非常浅显，暂时先写成这样\r\n以下是笔者写的递归代码\r\nconst int N = 100005;int n, m, k;poly mulT(const poly &amp;a){    if (a.empty())return poly();    return (T * a.rev()) &gt;&gt; (a.size() - 1);}poly a, F;poly c[N &lt;&lt; 2], h[N &lt;&lt; 2];int len;void build(int l, int r, int k){    if (l == r)c[k] = poly{1, mod - a[l]};    else    {        int m = (l + r) &gt;&gt; 1;        build(l, m, k &lt;&lt; 1);        build(m + 1, r, k &lt;&lt; 1 | 1);        c[k] = c[k &lt;&lt; 1] * c[k &lt;&lt; 1 | 1];    }}void solve(int l, int r, int k){    if (l == r)return;    else    {        int m = (l + r) &gt;&gt; 1;        h[k &lt;&lt; 1] = h[k].mulT(c[k &lt;&lt; 1 | 1]).modxk(m - l + 1);        h[k &lt;&lt; 1 | 1] = h[k].mulT(c[k &lt;&lt; 1]).modxk(r - m);        solve(l, m, k &lt;&lt; 1);        solve(m + 1, r, k &lt;&lt; 1 | 1);    }}void print(int l, int r, int k){    if (l == r)    {        if (l &lt; m)            printf(\"%lld\\n\", h[k][0]);    }    else    {        int m = (l + r) &gt;&gt; 1;        print(l, m, k &lt;&lt; 1);        print(m + 1, r, k &lt;&lt; 1 | 1);    }}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    F.resize(n + 1);    for (int i = 0; i &lt;= n; i++)        scanf(\"%lld\", &amp;F[i]);    a.resize(m);    for (int i = 0; i &lt; m; i++)        scanf(\"%d\", &amp;a[i]);    len = max(n + 1, m);    F.resize(len), a.resize(len);    build(0, len - 1, 1);    h[1] = F.mulT(c[1].inv(len));    solve(0, len - 1, 1);    print(0, len - 1, 1);    return 0;}\r\n","tags":["Generating Functions","Matrix","Poly"]}]