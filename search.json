[{"title":"2020牛客暑期多校训练营（第五场）C-Easy","url":"/2022/06/16/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89C-Easy/","content":"\r\n2020牛客暑期多校训练营（第五场）C-Easy\r\n设所对应的二元生成函数为，则答案为\r\n由基本生成函数知识可知\r\n\r\n考虑 \r\n则\r\n因此\r\n时间复杂度\r\n","tags":["Generating Functions","Combinatorics"]},{"title":"2022-2023赛季VP记录","url":"/2022/10/15/2022-2023%E8%B5%9B%E5%AD%A3VP%E8%AE%B0%E5%BD%95/","content":"\r\n19哈尔滨：8题933罚时，正式榜rk7，去除打星rk4，cf上截至vp结束rk35，C题机时不足赛后20分钟通过，正式大量VP的开端。\r\n\r\n19徐州：7题1349罚时，正式榜rk15，去除打星rk13，vjudge上截至vp结束rk20，未过银牌题M，本场因掉网和首次使用vjudge\r\nvp导致体验糟糕，机时上也很混乱，对队友的pollard_rho板子不熟悉导致浪费了很多时间，总体罚时爆炸。\r\n19拉美：8题991罚时，cf上截至vp结束rk120，还剩半个多小时的时候觉得没什么想法就先解散吃饭了，F题中期两个多小时没开出来我背大锅，被杜老师(DDOSvoid)n+2爆杀。\r\n19秦皇岛：6题996罚时，正式榜rk18，去除打星rk15，cf上截至vp结束rk81，有不少失误，加上博弈苦手的原因一度大脑宕机，导致罚时过高。\r\n20秦皇岛：5题319罚时，gym上无银牌假题C，正式榜rk73，去除打星rk61，cf上截至vp结束rk76，出金牌题实力不够，hash姿势不足。\r\n19SEERC：4题520罚时，cf上截至vp结束rk292，寄穿。 2015-2016 Petrozavodsk Winter Training Camp, Moscow\r\nSU Trinity\r\nContest：6题653罚时，cf上截至vp结束rk67，C题背景描述与输入描述不符合，D题实际应算没过，G题又是构造苦手，过题人数非常多的构造未出。\r\n2019 Petrozavodsk Winter Camp, Yandex Cup:\r\n3题426罚时，cf上截至vp结束rk86，跟娱乐一样乱打+被贪心题卡死\r\n22桂林：6题862罚时，cf上截至vp结束rk86，正式榜rk56，去除打星rk47，G题队友没睡够状态不好，D题自己推到最后一步时候把一个会的结论应该是一元GF形式推错写成了二元，寄寄寄，场上推式子天天犯病。\r\n20银川：6题916罚时，cf上截至vp结束rk29，正式榜rk28，去除打星rk27，CD浪费过多时间想和写错误做法，C想了两小时优化打表，最后一小时反应过来是多项式，D写了个200行LCT最后发现反例否定了这种做法，非常逆风。\r\n22威海：7题704罚时，cf上截至vp结束rk48，正式榜rk35，去除打星rk34，2小时44分钟签完7题，然后K题没有想太深就开始写一个极其麻烦的做法，到最后都没有调出来，赛后发现这种做法漏了一种情况+方案数算错了，应该想得再深入一些再动键盘。 2022-2023 ICPC NERC (NEERC), North-Western Russia\r\nRegional Contest (Northern\r\nSubregionals)：6题410罚时，cf上截至vp结束rk57，赛后一分钟内过了F，又被杜老师n+2爆杀了。\r\n22广州：5题559罚时，cf上截至vp结束rk59，正式榜rk37，去除打星rk29。\r\n21EC：6题624罚时，cf上截至vp结束rk18，正式榜rk22，去除打星rk21。\r\n22绵阳：4题215罚时，cf上截至vp结束rk154，正式榜rk105，去除打星rk99。 COMPFEST 13 - Finals Online Mirror (Unrated, ICPC\r\nRules, Teams Preferred)：9题972罚时，cf上截至vp结束rk49。\r\nCOMPFEST 14 - Preliminary Online Mirror (Unrated, ICPC Rules, Teams\r\nPreferred)：7题485罚时，cf上截至vp结束rk133，正式大量vp的结尾。\r\n"},{"title":"2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest Problem H. Hans Zimmer","url":"/2022/11/01/2015-2016%20Petrozavodsk%20Winter%20Training%20Camp,%20Moscow%20SU%20Trinity%20Contest%20Problem%20H.%20Hans%20Zimmer/","content":"\r\n引理1： 长为的线段随机切刀分成条线段，最短线段长度期望为，第短线段长度为\r\n\r\n考虑一个直观等价的事实，随机切刀等价于个随机变量满足，最短段为(具体证明不会。。)\r\n另一个比较直观的引理2(证明不会，概率论太差了呜呜呜)：\r\n\r\n再一个比较直观的引理3：\r\n\r\n证明(终于有我会的了)：\r\n分部积分法\r\n那么最短线段的期望长度:\r\n引理\r\n最长线段的期望长度(容斥做法)：\r\n\r\n第短线段的递推做法(容斥做法不会呜呜呜)：\r\n考虑第2短的线段期望长度，相当于给都减去，答案就是此时的最短线段期望长度+原先最短线段期望长度。\r\n\r\n由此可以数学归纳法求出 \r\n回到原题，此时可以枚举确定横纵切的刀数 答案为：\r\n\r\n精度上用函数解决即可\r\n","tags":["Math","Integral","Expectation"]},{"title":"2022多校多项式做题记录","url":"/2022/07/26/2022%E5%A4%9A%E6%A0%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\r\n牛客多校1：H题\r\nFly，基础不牢没学过完全背包转二进制01背包，中档题，挺可惜。\r\n杭电多校1：1010\r\nwalk，容斥+矩阵维护多项式，压轴难度，完全没思路，补题见Blog。\r\n牛客多校2：E题 Falfa with\r\nSubstring，经典二项式反演，例题难度，场切。\r\n杭电多校2：无多项式。\r\n牛客多校3：I题Ice Drinking，压轴难度，数的touchard同余性质以及快速求5000个级别的第二类数，不会求这5000个斯特林数，比较可惜的是只差这一步，而这一步在翻混凝土数学的时候没去翻二阶欧拉数，二阶欧拉数能与转换，差临门一脚，可惜。\r\nPS：东京大学队伍有个神秘科技可以求单次的斯特林数，令人震惊\r\n\r\n杭电多校3：1001 Equipment\r\nUpgrade，cdq分治fft优化期望dp，场切，中档题难度，但是过题人数和牛客多校2的E题差不多，人均会多项式？\r\n牛客多校4：C Easy Counting Problem，中档题，场切，但是选择了枚举而不是背包导致需要卡常\r\n杭电多校4：无多项式。\r\n牛客多校5：著名锅场，无多项式。\r\n杭电多校5：1007 Count\r\nSet，普通分治fft，签到题难度，场切，270个队会多项式就很离谱。\r\n杭电多校6：1003 Find the Number of\r\nPaths，金牌题难度，会，但是没开，一整场卡了四道签到导致时间上寄了，所以另一道置换群模板题也没时间开。\r\n","tags":["record"]},{"title":"2022杭电多校七1007 hdoj7217 Counting Good Arrays","url":"/2022/09/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%831007%20hdoj7217%20Counting%20Good%20Arrays/","content":"\r\n题意：对于一个数列，满足数列长度不超过，数列最大值不超过，且对于所有，满足的方案数\r\n设为数组长度为，最后一个数为的方案数，那么答案是\r\n\r\n首先固定观察性质，可以发现对于不同的质因子，在分配时并不相互影响，所以是一个关于的积性函数那么我们只要求\r\n对于，相当于对所有，把个因子可重复得分给个位置（最后一个位置固定为），即可重组合数，所以对于单个的方案数是\r\n\r\n一个简单的生成函数证明是考虑每个位置的因子个数，对于一个位置，方案数为任意个的方案数都是，那么一个位置的生成函数是，个的位置对应的生成函数就是，方案数就是\r\n\r\n那么对于所有的方案数就是 \r\n现在求出了，就可以通过筛求出关于的前缀和，这里预处理质数处的总和时，可以发现虽然不能像单项式那样子计算，但实际是质数个数乘上（一句只要求质数处的和，一语惊醒梦中人），剩余部分就是普通的操作\r\n求出了固定下的关于的前缀和，对再做一次前缀和就能得到答案所需的式子，此时太大了，但是！！！我们发现上面有一个式子\r\n\r\n在时就是一个关于的多项式，又因为是积性函数，所以也是一个多项式，并且项数是级别的，那么我们就可以通过拉格朗日插值计算得到最终的答案，复杂度\r\n比较怪的是这题，网络赛在长度n不需要求前缀和时，虽然那题并不需要插值（用插值就啦）\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;const ll mod = 1e9 + 7;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;namespace interpolate {    ll f[N], pre[N], suf[N];    ll lagrange(ll *f, int n, ll x)    {        if (x &lt;= n)return f[x];        ll ans = 0;        pre[0] = x % mod;        for (int i = 1; i &lt;= n; i++)            pre[i] = pre[i - 1] * (x - i + mod) % mod;        suf[n + 1] = 1;        for (int i = n; i; i--)            suf[i] = suf[i + 1] * (x - i + mod) % mod;        for (int i = 1; i &lt;= n; i++)        {            ll res = ifac[i] * ifac[n - i] % mod * pre[i - 1] % mod * suf[i + 1] % mod * f[i] % mod;            if ((n - i) &amp; 1)res = mod - res;            ans += res;            if (ans &gt;= mod)ans -= mod;        }        return ans;    }}using namespace interpolate;int vis[N];ll prime[N];int cnt;void Prime(int n){    cnt = 0;//多次时别忘了    for (int i = 2; i &lt;= n; i++)    {        if (!vis[i])prime[++cnt] = i;        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)        {            vis[i * prime[j]] = 1;            if (i % prime[j] == 0)break;        }    }}ll w[N], num_p[N], g[N];int id1[N], id2[N];int sz, t;ll limit;inline int getid(ll x){    if (x &lt;= sz)return id1[x];    else return id2[limit / x];}void init(ll n){    limit = n;    sz = sqrt(n) + 5;    Prime(sz);    t = 0;//多次时别忘了，也可以设置成局部变量    for (ll l = 1, r; l &lt;= n; l = r + 1)    {        r = n / (n / l);        w[++t] = n / l;        num_p[t] = w[t] - 1;        if (w[t] &lt;= sz)id1[w[t]] = t;        else id2[n / w[t]] = t;    }    for (int i = 1; i &lt;= cnt; i++)        for (int j = 1; j &lt;= t &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j++)        {            int id = getid(w[j] / prime[i]);            num_p[j] = (num_p[j] - (num_p[id] - (i - 1)) % mod + mod) % mod;//质数个数        }}ll S(ll n, int j, int r){    if (prime[j] &gt; n)return 0;    ll ans = (num_p[getid(n)] - j + mod) * r % mod;    for (int i = j + 1; i &lt;= cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++)        for (ll e = 1, sp = prime[i]; sp &lt;= n; sp *= prime[i], e++)            ans = (ans + C(e + r - 1, e) * (S(n / sp, i, r) + (e &gt; 1))) % mod;    return ans;}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        init(m);        for (int i = 1; i &lt;= 35; i++)            f[i] = (S(m, 0, i) + 1) % mod, f[i] = (f[i] + f[i - 1]) % mod;        printf(\"%lld\\n\", lagrange(f, 35, n));    }    return 0;}\r\n","tags":["Math","Combination","Min25"]},{"title":"2022杭电多校六1003 hdoj7199 Find the Number of Paths","url":"/2022/08/05/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E5%85%AD1003%20hdoj7199%20Find%20the%20Number%20of%20Paths/","content":"\r\n设为已经走了步，当前在点的方案数，易知方程为\r\n\r\n式子不太方便，考虑令新标号等于原标号 则式子变为\r\n\r\n考虑生成函数形式，设为所对应的生成函数 则\r\n\r\n根据高中知识，构造 则\r\n\r\n就可以快速求出和\r\n时间复杂度，但常数巨大\r\n主函数核心代码就十行\r\nint main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;k);        poly A(n);        for (int i = 1; i &lt;= n - 1; i++)            scanf(\"%lld\", &amp;A[i]);        poly F = A.integ().exp(k + 1);        poly G0 = F &lt;&lt; (n - 1);        poly Gk(n);        for (int i = 0; i &lt; n; i++)            Gk[i] = G0[i + k] * fac[i + k] % mod * ifac[i] % mod;        poly H = Gk * F.inv(n);        for (int i = n - 1; i &gt;= 0; i--)            printf(\"%lld%c\", H[i], \" \\n\"[i == 0]);    }    return 0;}\r\n","tags":["Generating Functions","Math"]},{"title":"2022杭电多校一1010 hdoj7147 Walk","url":"/2022/07/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%801010%20hdoj7147%20Walk/","content":" 的分界线分别为,\r\n对于下一层的纵坐标\r\n，，， 称满足上述条件为合法情况，不满足上述条件为不合法情况。\r\n设恰好有层不合法的方案数为，设恰好有i层合法的方案数为。\r\n考虑容斥求，钦定最后层（即到层）不合法，前层合法。（容斥部分感谢ywx的讲解和点化）\r\n那么从钦定最后层不合法和前层合法开始，当前情况数为，此时只钦定了前层和最后层，第层和第层之间的关系并未确定，可能第层和第层仍然构成不合法情况，那么就要把这种情况减去，也就是减掉，同理仍然有第层和第层可能构成不合法情况，但被减去了，所以要加上，一步步下去，可得如下式子\r\n\r\n合并后可得\r\n\r\n所以对应的生成函数和对应的生成函数之间的关系为  接下来考虑如何求\r\n连续层不合法，那么会使得\r\n设，那么需要相隔至少个数之后才能选，那么可以每选择一个数使得减，即线性变换，因此考虑矩阵\r\n设为输入的个权值\r\n时不需要偏移，所以矩阵为\r\n\r\n时偏移为格\r\n\r\n时偏移为格\r\n\r\n以时的矩阵为例进行解释，之后能选的数是，那么i移动就只能从第三列移动到一列之后才能加，在移动两格的过程中，和就没有被选在之后，而选择之后又需要停两次才能选，若不选则仍然停留在立即能选的状态，所以该矩阵的转移就是\r\n\r\n写出来就是的矩阵\r\n最后带回原式做一个多项式求逆即可\r\nstruct matrix{    poly a[4][4];    static constexpr int n = 3;    friend matrix operator*(const matrix &amp;u, const matrix &amp;v)    {        matrix ans;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                for (int k = 1; k &lt;= n; k++)                    ans.a[i][j] = ans.a[i][j] + u.a[i][k] * v.a[k][j];        return ans;    }    poly *operator[](const int i)    {        return this-&gt;a[i];    }} s[N];matrix solve(int l, int r){    if (l == r)return s[l];    int m = (l + r) &gt;&gt; 1;    return solve(l, m) * solve(m + 1, r);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)    {        scanf(\"%d\", &amp;w);        if (i &lt; 16)            s[i][1][1] = poly{1, w};        else if (i &lt; 65536)            s[i][1][1] = s[i][2][1] = poly{1}, s[i][1][2] = poly{0, w};        else            s[i][1][1] = s[i][2][1] = s[i][3][2] = poly{1}, s[i][1][3] = poly{0, w};    }    matrix A = solve(1, m);    poly F = A[1][1] + A[1][2] + A[1][3];    for (int i = 1; i &lt; F.size(); i += 2)        F[i] = mod - F[i];    cout &lt;&lt; F.inv(n + 1)[n] &lt;&lt; endl;    return 0;}\r\n","tags":["Generating Functions","Matrix"]},{"title":"2022牛客多校三 D Directed","url":"/2022/08/25/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E4%B8%89%20D%20Directed/","content":"\r\n结论：结点走到父亲的期望步数为\r\n证明：设为走到父亲期望步数，为结点的度数，有 \r\n若为叶子结点\r\n可以发现和成一次函数关系，待定系数后解得\r\n\r\n那么不考虑无向边变成有向边的影响，答案就是\r\n到的链\r\n接下来考虑无向边变为有向边且方向指向根结点的影响，设从起点到终点的这条链上的结点都被染色过，对于任意一个结点，\r\n若到父亲这条边变成有向边，当且仅当到目标结点的路径中除了和这条边被染色，其他边都不被染色才会产生的贡献。\r\n记结点的被染色祖先里距离最近的祖先为，\r\n考虑这种情况的概率，设和之间距离为，概率为，而的范围是到这条链上的结点，所以这部分贡献和是\r\n\r\n求解每个的贡献即可，时间复杂度\r\nconst int N = 2000005;int n, m, k;int a[N], vis[N], d[N], f[N], sz[N];vector&lt;int&gt; vec[N];const ll mod = 998244353;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;ll ans;void dfs1(int u, int fa){    f[u] = fa;    d[u] = d[fa] + 1;    sz[u] = 1;    for (auto v:vec[u])    {        if (v == fa)continue;        dfs1(v, u);        sz[u] += sz[v];    }}ll inv;void dfs2(int u, int ancient){    if (u != 1)        ans = (ans - (C(n - d[u] + d[ancient], k) - C(n - 1 - d[u] + d[2], k)) * inv % mod * 2 * sz[u] % mod + mod) % mod;    for (auto v:vec[u])    {        if (v == f[u])continue;        if (vis[u])            dfs2(v, u);        else dfs2(v, ancient);    }}int main(){    int p, q, u, v, w, x, y, z, T;    int s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    inv = fpow(C(n - 1, k), mod - 2);    for (int i = 1; i &lt; n; i++)        scanf(\"%d%d\", &amp;u, &amp;v), vec[u].emplace_back(v), vec[v].emplace_back(u);    dfs1(1, 0);    vis[1] = 1;    for (int u = s; u != 1; u = f[u])        vis[u] = 1, ans += 2 * sz[u] - 1;    ans %= mod;    dfs2(1, 0);    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Expectation"]},{"title":"2022牛客多校八 G Lexicographic Comparison","url":"/2022/09/04/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E5%85%AB%20G%20Lexicographic%20Comparison/","content":" 平衡树维护置换环\r\n的数据结构真的锻炼能力，平衡树能力++\r\nconst int N = 100005;int n, m, k;namespace Splay {    int c[N], son[N][2], f[N], sz[N], minid[N];#define ls son[x][0]#define rs son[x][1]    inline int cmp(int x, int y)    {        if (!x || !y)return x | y;        else return x &lt; y ? x : y;    }    inline void pushup(int x)    {        sz[x] = sz[ls] + sz[rs] + 1;        minid[x] = cmp(x, cmp(minid[ls], minid[rs]));    }    inline int get(int x) { return x == son[f[x]][1]; }    inline void connect(int x, int y, int d)    {        if (x)son[x][d] = y;        if (y)f[y] = x;    }    inline void rotate(int x)    {        int fa = f[x], ffa = f[fa], p = get(x), q = get(fa);        connect(fa, son[x][p ^ 1], p);        connect(x, fa, p ^ 1);        connect(ffa, x, q);        pushup(fa), pushup(x);    }    void splay(int x, int ed)    {        for (int fa; fa = f[x], fa != ed; rotate(x))            if (f[fa] != ed)rotate(get(fa) == get(x) ? fa : x);    }    inline int get_minid(int x)    {        splay(x, 0);        return minid[x];    }    int getlast(int x)    {        splay(x, 0);        while (son[x][1])            x = son[x][1];        splay(x, 0);        return x;    }    inline int kth(int x, int rk)    {        splay(x, 0);        while (1)        {            if (sz[ls] &gt;= rk)                x = ls;            else            {                rk -= sz[ls] + 1;                if (!rk)return x;                x = rs;            }        }    }    void movefront(int x)    {        splay(x, 0);        if (!ls)return;        int r = getlast(x);        int y = ls;        ls = 0;        pushup(x);        son[r][1] = y;        f[y] = r;        pushup(r);        splay(x, 0);    }#undef ls#undef rs}using namespace Splay;int p[N], circle_sz[N];set&lt;int&gt; S1[N], S2;int SZ;void print(int x){    if (son[x][0])print(son[x][0]);    printf(\"%d \", x);    if (son[x][1])print(son[x][1]);}inline void add(int x){    splay(x, 0);    circle_sz[minid[x]] = sz[x];    if (sz[x] &lt;= SZ)S1[sz[x]].insert(minid[x]);    else S2.insert(minid[x]);}inline void del(int x){    splay(x, 0);    if (sz[x] &lt;= SZ)S1[sz[x]].erase(minid[x]);    else S2.erase(minid[x]);}void merge(int x, int y){    if (get_minid(x) &gt; get_minid(y))swap(x, y);    del(x), del(y);    movefront(x), movefront(p[y]);    if (x != p[x])    {        splay(x, 0), splay(p[x], x);        son[p[x]][0] = p[y];        f[p[y]] = p[x];        pushup(p[x]);        splay(p[x], 0);    }    else    {        son[x][1] = p[y];        f[p[y]] = x;        pushup(x);        splay(x, 0);    }    add(x);}void divide(int x, int y){    del(x);    movefront(x);    if (sz[x] == 2)    {        splay(x, 0);        son[x][1] = 0;        f[y] = 0;        pushup(x);    }    else    {        if (x == p[y])swap(x, y);        assert(x != p[y]);        splay(x, 0), splay(p[y], x);        int z = son[p[y]][0];        son[p[y]][0] = 0;        f[z] = 0;        pushup(p[y]);        splay(p[y], 0);    }    add(x), add(y);}int main(){    int q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;q);        for (int i = 1; i &lt;= n; i++)            son[i][0] = son[i][1] = 0, S1[i].clear();        S2.clear();        fill(f, f + n + 1, 0);        fill(sz + 1, sz + n + 1, 1);        iota(minid + 1, minid + n + 1, 1);        iota(c + 1, c + n + 1, 1);        iota(p + 1, p + n + 1, 1);        SZ = sqrt(n);        char s[10];        while (q--)        {            ll x, y;            scanf(\"%s%lld%lld\", s, &amp;x, &amp;y);            if (s[0] == 's' &amp;&amp; s[5] == 'a')                swap(c[x], c[y]);            else if (s[0] == 's' &amp;&amp; s[5] == 'p')            {                if (x == y)continue;                if (get_minid(x) != get_minid(y))                    merge(x, y);                else                    divide(x, y);                swap(p[x], p[y]);            }            else            {                ll dif = abs(x - y);                int id = n + 1;                for (int i = 1; i &lt;= SZ; i++)                    if (!S1[i].empty() &amp;&amp; dif % i)                        id = min(id, *S1[i].begin());                for (auto x:S2)                    if (dif % circle_sz[x])                        id = min(id, x);                if (id == n + 1)puts(\"=\");                else                {                    x = (x - 1) % circle_sz[id] + 1;                    y = (y - 1) % circle_sz[id] + 1;                    movefront(id);                    x = kth(id, x);                    y = kth(id, y);                    if (c[x] &lt; c[y])puts(\"&lt;\");                    else puts(\"&gt;\");                }            }        }    }    return 0;}\r\n","tags":["Splay"]},{"title":"ACM之旅","url":"/2022/12/16/ACM%E4%B9%8B%E6%97%85/","content":"\r\n临时赶工的质量，随便看看吧\r\n2020.12.16-2022.12.16\r\n一转眼，我也到了退役的日子，今年的日子相比去年总是过得飞快，些许是更忙碌的原因，两年的ACM之旅为我带来了什么？扎实的码力，志同道合的伙伴，抑或是不健康的作息。一年前自己和队友在集训室看着学长们退役的情景仍然历历在目，想不到这么快就到了我们身上，甚至也复刻了去年7队的遗憾。\r\n2020年12月16日，我在最后一轮选拔赛中因老刘的网开一面成功进入到集训队，此后便是扎身于训练当中，起初一直只刷cf，直到5月在debug杯上被坐在旁边的阿敏n+3之后开始转向洛谷学习算法，此后确实实力大涨，在校赛中成功存活下来(反转了，阿敏不幸地短暂离开了集训队)。\r\n多校前和lmsh,soxsx组成了LSP steaming\r\nbuns(蒸馒头/杭电12队)，一个oier(lmsh)和两个零基础，20场多校之后排名全校rk11，之后由于线上赛的原因获得了上海站的参赛资格，此后开始了一周三场的vp，这支队伍从一开始磨合度就非常良好，也经常能够封榜后出题翻盘，再加上三个人码风非常相似，所以经常能在赛中打出combo，会出现两个人甚至三个人合写一份代码的情况，也会出现一个人写一半写不下去了另一个人能接着写的情况，所以越vp越强，vp到赛前一周的状态，那时候是LSP\r\nsteaming buns 2021年最巅峰的时期，三个人都爆发出了cf\r\nrating(当时队里三个1600，max rating\r\n1800+1800+1900)完全不匹配的实力，尤其是lmsh，借用今年和starry聊天时的描述就是lmsh成为了一个非常典型的oi选手，那个星期的lmsh在我认知中是他整个ACM生涯最强的时间段，那一周里不仅在策略上说不要让机子空下来，又在调节气氛和解决题目上起到了中流砥柱的作用，soxsx则承担了很大一部分的构造和模拟，soxsx的特点是思考问题相对学术化，经常会迸发出意想不到的灵感，而我在场上中后期经常会成为那个21开题的1，当lmsh和soxsx一起讨论题目卡住时(有时这俩会纠结于一些奇奇怪怪的地方，甚至和题目关系不大)偶尔会突然迸发出灵感解决掉自己手上的题。就这样，三个人轮流迸发出灵感，在那段时间三人打满5h的场里基本都是能达到银牌水平，后来我对当时lmsh和soxsx的评价是进入化境。\r\n2021年11月27日，上海站热身赛来临，凭借还不错的状态拿到了校内rk1(众所周知热身赛不能体现真实实力)。\r\n2021年11月28日，上海站正式赛来临，也是lmsh那一年的封神一战，那天主办方要求早上8点就到达比赛场地(但比赛时间是12:00-17:00)，所以带着半梦半醒的状态赶往了实验室，到那之后便是无事可干，后面的学长在玩单机游戏，而我因为电脑上没装什么游戏所以开始敲起了某场div2f的线段树，两个队友则在罚坐，我敲到一半敲不下去，lmsh让我不要敲了放空一下脑子，此后便是三人的罚坐时间(提前罚坐了场上就不会罚坐了)。\r\n直到12点比赛终于开始了，一上来两个人秒了D和E，第三道G是数学+树形dp，我推出了公式，然后lmsh听到我会公式，所以写了个calc接口给我，我稍微调了一下就过了，一波配合非常良好的combo。然后是I题，我当时并不会dp，但是一眼看出了是dp题，队里dp专精手lmsh想了一下两发就把这题过了，然后就去开了M题，一道二分图构造或者猜公式的题，开了许久没有猜出正确的结论，转向了非常困难的H题，kruskal重构树，但当时我们队并没有人学过这个算法，此时lmsh站了出来，在纸上写了一堆草稿+讲了我和soxsx完全听不懂的做法，然后上机写起了代码，留下了一脸懵逼的我和soxsx，lmsh写完wa了一发之后我看soxsx仍然处于懵逼状态就选择了自己造了一组数据，恰好找出了lmsh代码上的问题，第二发提交通过了H，此后转向了K题，构造，三个人想出了一些特殊情况之后我开始上机写暴力验证小数据，但我还没调出暴力时soxsx和lmsh突然就把所有的构造方式都想出来了，然后soxsx上机一发通过了这题，此后是90分钟的罚坐时间，B题多项式，但当时没人学过，lmsh想了一下发现不太可做，我想出了J题的一半，也知道要用bitset，但差了临门一脚，和lmsh讨论了一下无果之后三人开始合力冲M，soxsx用随机模拟的方式模拟出了n=3的情况，但到赛后发现是猜的多项式最高次有问题，所以后面公式一直猜的不对，此后也没有再过题，以rk71(校内rk3)结束上海站，也让我们创造了2021-2022赛季校内同级别队伍的最好成绩。\r\n回想起夺银的那天，去学校美食城的时候整个人也是容光焕发的样子，那一天的成绩确实振奋人心。\r\n此后一个月开始摆烂，不怎么刷题天天打游戏和水群，某一天突然发觉自己仍然有着对金牌的渴望，就又开始刷起了题的同时进入了2022年。\r\n如果说2021年是成功的一年，那么2022年可以说是失败的一年。\r\n寒假里，某算法群由于ay的出现和cupids_bow的疯狂刷题行为加剧了大家的精神内耗，所以我的状态大概就是起床玩会儿手机，吃完午饭开始上机学算法写代码，写到差不多晚上吃饭的时间，回来继续写，晚上有比赛就参加比赛，大概一周6-7天都是这个状态，也因此实力大涨时隔半年重新回到了紫名。3月左右开始了也许是整个生涯最歪的决定————学习多项式，只能说多项式是个高投入低收益的东西，在有其他知识面缺陷的情况下并不太值得花几个月的精力去学习。\r\n四月的时候由于lmsh和soxsx不知道连续摆了多久，都没能通过省赛选拔，我和zn_com,2020hduyz组成了一支临时队伍slow\r\ntime down参加省赛，但在磨合度上并不输LSP steaming\r\nbuns，大概有些默契本就天生形成，赛前的vp各种打穿，尤其是17th\r\nzjcpc，甚至以vp打赢了正式参赛的五点共圆，良好的化学反应和成绩让我们对省赛有着很大把握，可惜正式赛当天，队伍三个人轮流犯病，我和zn_com前期题出现非常大的罚时失误，导致签到题贡献了200分钟罚时，我在201分钟和zn_com打出combo解决第八题之后2020hduyz立即上机开始写第九题，可惜他没完全听懂zn_com的做法导致99分钟没能写完那题，最后差102分钟罚时夺金。\r\n省赛过后的下一星期就是天梯赛，当时我cf达到了历史新高的2000+，由于cf的出色表现老刘把我放在了2队里，那次天梯赛明显变难，模拟题的增多再加上陈越写的松针题面属实不行，所以前面浪费了很多时间，在达到227分左右时只剩下15分钟了，当时也不知道再写个暴力就能拿20多分从而夺金，所以很快就上手写正解，但是没能调出来，最后以230分收场拿下个人二等团队一等。\r\n天梯赛结束之后，由于老刘认为队里4个大二银牌oier(一共就4个oier+2个零基础)达不到金牌水平，所以他们被迫强制退役(至今认为这个决策不合理)，在上海站天神下凡的lmsh也恰好在点杀名单当中(但老刘并不知道具体情况，他对我们队的判断是上半年集体vp打得并不好，实际上是我们队都有课导致经常打一半就少一两个人，所以会出现签到题一整场没人签，中后期题却写掉了的情况，比如台北场)，此后lmsh开始去华为算法岗实习。\r\n2022年5月，我的思维达到了整个生涯最强的时期，并且在5月14日同时也是进队514天时场切2400分题目cf上黄(20届零基础仅三人上黄)，rating2165，那时候遇到2300及以下的思维题总是能想一会儿就出做法，处于整个生涯的思维巅峰状态。\r\n\r\n上黄之后cf就不太怎么关注了，cf刷题力度确实也弱了下来，在疯狂刷洛谷当中，整个人开始陷入套路化，从一个思维选手逐渐转变成了一个套路选手，但思维是油，算法是车，车离开了油终究会跑不动，所以也从黄掉回了紫，也为之后的失败埋下了伏笔。\r\n暑假和void_f,soxsx组成了Oceanic\r\nGlow(杭电11队)，先来讲讲新队友void_f(perdu)，借用和starry聊天时的话语，void_f是一个非常不典型的oier。他会在一些奇怪的地方突然拓展思路，但一旦思路错误会整个人陷入进去并且队友也会跟着陷入进去。\r\nsoxsx也许是突然失去了对acm的热情，整个人开始投入到课内当中(是我课内实验的救星)，第二年除了学了计算几何之外并没有怎么做题，做题水平除了计算几何之外和2021年没什么区别，也是20届零基础里唯一一个没上过紫的，两年加起来刷了1000题，所以第二年的懈怠程度甚至让我在私聊时忍不住喷过一次。\r\n我在暑假里一度失了智，思维能力大不如黄名时期，多校时一度开不出多项式以外的中期题，那时就晚上拼了命的写题，一点两点刷题是常态，但并没有得到什么好的效果。\r\n但最致命的是打法上的冲突导致磨合非常困难，这也是在组队时完全没想到的，我一共经历了三支队伍，唯有这一支，在磨合和默契程度上都大不如以前的队伍，三个人很多时候沟通并不到位，甚至在换位置这件事上也有体现，曾经的队伍三个人的位置在赛中会随便坐，但这支并不会这样，导致很多时候三个人像各打各的，形成一种三人单挑的局面。void_f原来队伍的打法和我们上赛季队伍的打法非常不同，导致整个暑假里我尝试调整了两次策略，但效果其实都不是很好，磨合问题其实到退役都没能解决得非常良好。\r\n虽然有种种问题，但三个人终究实力还是有保证，所以偶尔即使沟通不足也能打出上限，比如多校打出两次校内rk3，但更多的是由于磨合和沟通以及自身实力原因打出非常抽象的下限，比如校内rk8/9/10，导致多校校内排名从rk4掉到rk7(区域赛打完连rk7都没了)，并且亲手丢失一次参加ccpc的机会。\r\n网络赛后我靠着爆刷了一波斜率优化dp补足了dp方面，两年来第一次顿悟dp。\r\n此后开始进入到大量vp阶段，可参考2022-2023赛季VP记录博客，可以发现又是开局猛后期萎，貌似成了这支队伍的通病，越vp越发现自己思维越来越差只会套路，队伍甚至开始卡死在签到题，今年的比赛里唯一一场vp金牌区是2021-2022\r\nec-final，rk21，也vp了今年所有的CCPC，三银一铜，为了练签到专门练了两套comfest，但第二套直接死在了签到，最后一周的三场vp里有两场死在了签到，只打好了一场，Oceanic\r\nGlow的问题开始愈发明显，却不知道如何解决，也直接导致了icpc的失利。\r\n2022年11月13日，西安站来临，三个人没有一个人状态是正常的，签到失误也非常严重，soxsx甚至没写出签到最后我上机调出来，在2队7题时我们队甚至只有3题，两个多小时才签完6题之后三个人又开始了互演时刻，我和soxsx开A开到只剩1h我把代码写完时发现题目读错了，void_f练了一个暑假的网络流却没能切出B，三个人灾难性表现直接导致整把崩盘，甚至没打赢学弟，以铜牌结束比赛，论赛场表现肯定会被去年上海的LSP\r\nsteaming buns吊起来打。\r\n2022年11月27日，济南站来临，也是离夺金最近的一次，但架不住犯病，那天脑子一样由于睡眠不足昏昏沉沉，做题时A这种非常擅长的题目都能算错复杂度并且少优化一个地方，同时伴随的是决策问题，void_f一开始就想到了我没加的那个优化，但是我似乎没有听进去，void_f转而和soxsx开E，void_f出现了上述提到的问题，思路歪了的同时带着soxsx一起陷了进去，后来soxsx突然灵光一现做了出来(模型非常典，也许换黄名时期的我能一眼看出来)，10分钟后我也突然发现A的优化，从而做出A，但此时已经过去127分钟了(所以正确的决策应是soxsx单独开E，我和void_f开A)，然后void_f和soxsx读完长篇大论的D后很快想出了正解，我也很快想出了C的一个解法，写了一发发现是错误的，没考虑子树相对顺序，所以开始和soxsx想C，讨论出了一个非常难写的背包回退写法，在浪费了非常多时间之后终于调出了C，交上去还被卡了时间和空间，卡完常后终于通过，此时过去了268分钟，只剩半小时开G，但是，此时其实仍然有翻盘希望，void_f很早就想出了线段树维护swap操作，soxsx也很快想出了swap次数不会多，相当于两个人拼起来就是正解，但并没有进行充分交流，soxsx选择用不够快的码速敲了一遍题面代码去验了一遍，验出结论是正确时只剩5分钟，宣告济南站以rk58遗憾打银。\r\n最后的结果是和金牌线同题数，差233分钟罚时夺金，也就是要么写签到题A题和E题时不犯病浪费那么长时间，要么写C题时不犯病，要么G题soxsx和void_f加强一下沟通，然后直接上手写，任意做到一个都能夺金，可惜的是一个都没能做到，也成为了多校校内前八支队伍里唯一一支没有夺金的队伍。\r\n整体回想一下三场区域赛，只有大二时期的上海站打得像顺风局，大三的两把都是逆风局，问题出在哪呢，我自己确实也有很大问题，大二时期非常注重思维，思维越练越强，大三开始学了一些useless的算法，思维变得套路化，从思维选手变成了套路选手，导致非常吃题目风格，队伍上的问题相对更大一些，交流并不像前两支队伍一样充分，即使到了结束都没能磨合好这个问题，再加上场上脑子犯病，三个机会里把握一个就能夺金，没把握住也确实可惜。\r\n回想一下整个生涯，两年时间，codeforces、洛谷等等平台再加上组队赛，刷了至少3000道题目，洛谷上蓝紫黑题加起来接近600题，大二区域赛银，省赛银，天梯赛个人二等，大三区域赛银，貌似自己总是拿不到最好的成绩，也许是运气不足，也许是实力不够，也许是训练方法有误。\r\n\r\nACM生涯也到此结束，终于迎来了大学里第一个能休息的假期，不用再没日没夜地敲代码，倒也不错。接下来的计划大概就是寒假里尽量恢复一下实力cf回个黄，实在做不到也就算了，再做一个nonebot，然后背背八股带上lmsh一起跑路投简历下学期去实习了，希望进Iscream2001实习的公司，由于这学期期末考试变成了下学期开学考，所以额外空降的计划就是寒假好好补一下落下的课程，至于下学期的天梯赛和省赛，就看队友的意愿了，毕竟区域赛结束，也宣告ACM告一段落，自己也随之退役了。\r\n"},{"title":"AtCoder Regular Contest 115 E - LEQ and NEQ","url":"/2022/07/29/AtCoder%20Regular%20Contest%20115%20E%20-%20LEQ%20and%20NEQ/","content":"\r\n题意：给定个数，求个数满足下列条件的方案数：  数据范围： \r\n类似杭电多校1多项式题的容斥，但是此时由于的值是不固定的，所以只能写成形式，设为前i个序列的答案，枚举钦定最后个不合法，则有\r\n\r\n单调栈求出作为最小值的左边界，从转移到时只会影响一段后缀，用线段树维护即可，时间复杂度也可以用笛卡尔树做到\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 500005;int n, m, k;ll a[N];int stk[N], L[N];ll lazy[N &lt;&lt; 2];struct point{    ll sum, f;} c[N &lt;&lt; 2];const ll mod = 998244353;inline void pushup(int k){    c[k].sum = (c[k &lt;&lt; 1].sum + c[k &lt;&lt; 1 | 1].sum) % mod;    c[k].f = (c[k &lt;&lt; 1].f + c[k &lt;&lt; 1 | 1].f) % mod;}const ll inf = 1e9;inline void pushdown(int k){    if (lazy[k] != inf)    {        lazy[k &lt;&lt; 1] = lazy[k &lt;&lt; 1 | 1] = lazy[k];        c[k &lt;&lt; 1].sum = c[k &lt;&lt; 1].f * lazy[k] % mod;        c[k &lt;&lt; 1 | 1].sum = c[k &lt;&lt; 1 | 1].f * lazy[k] % mod;        lazy[k] = inf;    }}void update(int L, int R, int l, int r, int k, ll v){    if (L &lt;= l &amp;&amp; r &lt;= R)    {        c[k].sum = v * c[k].f % mod;        lazy[k] = v;        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (L &lt;= m)update(L, R, l, m, k &lt;&lt; 1, v);    if (R &gt; m)update(L, R, m + 1, r, k &lt;&lt; 1 | 1, v);    pushup(k);}void insert(int l, int r, int k, int x, ll v, ll f){    if (l == r)    {        c[k] = {v * f % mod, f};        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (x &lt;= m)insert(l, m, k &lt;&lt; 1, x, v, f);    else insert(m + 1, r, k &lt;&lt; 1 | 1, x, v, f);    pushup(k);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        scanf(\"%lld\", &amp;a[i]);    fill(lazy, lazy + n * 4, inf);    int top = 0;    for (int i = n; i; i--)    {        while (top &amp;&amp; a[stk[top]] &gt;= a[i])            L[stk[top--]] = i;        stk[++top] = i;    }    insert(0, n, 1, 0, 1, 1);    for (int i = 1; i &lt;= n; i++)    {        update(L[i], i - 1, 0, n, 1, mod - a[i] % mod);        if (i == n)cout &lt;&lt; (i &amp; 1 ? mod - 1 : 1) * c[1].sum % mod;        insert(0, n, 1, i, a[i], c[1].sum);    }    return 0;}\r\n","tags":["Inclusion-Exclusion Principle","DP","Data Structure"]},{"title":"C++智能指针","url":"/2023/02/18/C++%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/","content":"\r\nauto_ptr\r\nauto_ptr的语义实现，个人体会及注意事项已写在注释中\r\n//auto_ptr的语义实现template&lt;class T&gt;class smart_ptr//不能出现两个smart_ptr的ptr指向同一个地址，否则析构会重复delete{private:    T *ptr;public:    explicit smart_ptr(T *ptr = nullptr) : ptr(ptr) {}    smart_ptr(smart_ptr &amp;rhs)//rhs的ptr变为空    {        ptr = rhs.release();    }    smart_ptr &amp;operator=(smart_ptr &amp;rhs)//赋值之后rhs的ptr为空    {        if (ptr == rhs.get())return *this;//自赋值问题        smart_ptr(rhs).swap(*this);        return *this;    }    ~smart_ptr()    {        delete ptr;    }    T *release()    {        T *_ptr = ptr;        ptr = nullptr;        return _ptr;    }    void swap(smart_ptr &amp;rhs)    {        std::swap(ptr, rhs.ptr);    }    T *get() const { return ptr; }    T &amp;operator*() const { return *ptr; };//空指针访问会报错    T *operator-&gt;() const { return ptr; }    explicit operator bool() const { return ptr; }//用于bool表达式};int main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    smart_ptr&lt;int&gt; A(new int(1)), B(new int(2));    std::cout &lt;&lt; A.get() &lt;&lt; \" \" &lt;&lt; B.get() &lt;&lt; std::endl;    std::cout &lt;&lt; *A &lt;&lt; \" \" &lt;&lt; *B &lt;&lt; std::endl;    A = B;    std::cout &lt;&lt; A.get() &lt;&lt; \" \" &lt;&lt; B.get() &lt;&lt; std::endl;    std::cout &lt;&lt; *A &lt;&lt; std::endl;    A = A;    std::cout &lt;&lt; A.get() &lt;&lt; \" \" &lt;&lt; *A &lt;&lt; std::endl;    return 0;}\r\nshared_ptr\r\nshared_ptr简单版(非线程安全)语义实现\r\n可以使用abi::__cxa_demangle函数得到类的类型从而提高理解\r\n默认赋值运算符为浅拷贝，刚好shared_ptr实现就是基于浅拷贝原理\r\n#include &lt;bits/stdc++.h&gt;#include &lt;cxxabi.h&gt;class shape{public:    virtual ~shape() { std::cout &lt;&lt; \"~shape()\" &lt;&lt; std::endl; }};class circle : public shape{public:    ~circle() { std::cout &lt;&lt; \"~circle()\" &lt;&lt; std::endl; }};class shared_count{private:    int cnt;public:    shared_count() : cnt(1) {}    void add_count() { cnt++; }    int sub_count() { return --cnt; }    int use_count() const { return cnt; }};template&lt;class T&gt;class Shared_ptr{private:    T *ptr;    shared_count *shared_count_ptr;public:    explicit Shared_ptr(T *ptr = nullptr) : ptr(ptr)    {        if (ptr)            shared_count_ptr = new shared_count;    }    Shared_ptr(const Shared_ptr &amp;rhs) : ptr(rhs.ptr)    {        if (ptr)        {            rhs.shared_count_ptr-&gt;add_count();            shared_count_ptr = rhs.shared_count_ptr;        }    }    template&lt;class U&gt; friend    class Shared_ptr;    template&lt;class U&gt;    Shared_ptr(const Shared_ptr&lt;U&gt; &amp;rhs):ptr(rhs.ptr)//隐式转换情况    {        if (ptr)        {            rhs.shared_count_ptr-&gt;add_count();            shared_count_ptr = rhs.shared_count_ptr;        }    }    template&lt;class U&gt;    Shared_ptr(const Shared_ptr&lt;U&gt; &amp;rhs, T *another_ptr):ptr(another_ptr)    {        if (ptr)        {            rhs.shared_count_ptr-&gt;add_count();            shared_count_ptr = rhs.shared_count_ptr;        }    }    template&lt;class U&gt;    Shared_ptr(Shared_ptr&lt;U&gt; &amp;&amp;rhs):ptr(rhs.ptr)//此处并不被编译器视为移动构造函数    {        if (ptr)        {            shared_count_ptr = rhs.shared_count_ptr;            rhs.ptr = nullptr;        }    }    ~Shared_ptr()    {        if (ptr &amp;&amp; shared_count_ptr-&gt;sub_count() == 0)        {            delete ptr;            delete shared_count_ptr;        }    }    Shared_ptr &amp;operator=(Shared_ptr rhs) noexcept    {        rhs.swap(*this);        return *this;    }    void swap(Shared_ptr &amp;rhs)    {        std::swap(ptr, rhs.ptr);        std::swap(shared_count_ptr, rhs.shared_count_ptr);    }    int use_count() const    {        return ptr ? shared_count_ptr-&gt;use_count() : 0;    }    T *get() const    {        return ptr;    }    T &amp;operator*() noexcept { return *ptr; }    T *operator-&gt;() noexcept { return ptr; }    explicit operator bool() const noexcept { return ptr; }};template&lt;class T&gt;Shared_ptr&lt;T&gt; swap(const Shared_ptr&lt;T&gt; &amp;lhs, const Shared_ptr&lt;T&gt; &amp;rhs)noexcept{    lhs.swap(rhs);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; static_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = static_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; reinterpret_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = reinterpret_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; const_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = const_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}template&lt;class T, class U&gt;Shared_ptr&lt;T&gt; dynamic_pointer_cast(const Shared_ptr&lt;U&gt; &amp;rhs){    T *ptr = dynamic_cast&lt;T *&gt;(rhs.get());    return Shared_ptr&lt;T&gt;(rhs, ptr);}int main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    Shared_ptr&lt;circle&gt; p1(new circle);    std::cout &lt;&lt; \"use count of p1 = \" &lt;&lt; p1.use_count() &lt;&lt; std::endl;    Shared_ptr&lt;shape&gt; p2;    std::cout &lt;&lt; \"use count of p2 = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl;    std::cout &lt;&lt; abi::__cxa_demangle(typeid(p1).name(), 0, 0, 0) &lt;&lt; std::endl;    p2 = p1;    std::cout &lt;&lt; \"use count of p2 = \" &lt;&lt; p2.use_count() &lt;&lt; std::endl;    if (p1)        std::cout &lt;&lt; \"p1 is not empty\" &lt;&lt; std::endl;    Shared_ptr&lt;circle&gt; p4 = p1;    std::cout &lt;&lt; \"use count of p4 = \" &lt;&lt; p4.use_count() &lt;&lt; std::endl;    p4 = p1;//注意165行调用拷贝构造函数,167行调用赋值重载运算符    Shared_ptr&lt;circle&gt; p3 = dynamic_pointer_cast&lt;circle&gt;(p2);//默认赋值运算符为浅拷贝    std::cout &lt;&lt; \"use count of p3 = \" &lt;&lt; p3.use_count() &lt;&lt; std::endl;    return 0;}\r\n","tags":["C++"]},{"title":"CF1716F Bags with Balls 生成函数递推初探","url":"/2022/08/05/CF1716F%20Bags%20with%20Balls%20%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%80%92%E6%8E%A8%E5%88%9D%E6%8E%A2/","content":"\r\n斯特林数展开可以更轻松得推出所求答案，这里用生成函数推导\r\n\r\nconst int N = 2005;int n, m, k;ll f[N][N];const ll mod = 998244353; ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;} int main(){    int p, q, u, v, w, x, y, z, T;    f[0][0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        for (int j = 1; j &lt;= i; j++)            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);        ll ans = 0, now = 1;        for (int i = 0; i &lt;= min(n, k); i++)        {            ans = (ans + now * f[k][i] % mod * fpow(m, n - i) % mod * fpow((m + 1) / 2, i)) % mod;            now = now * (n - i) % mod;        }        printf(\"%lld\\n\", ans);    }    return 0;}\r\n","tags":["Generating Functions","Stirling"]},{"title":"NOI2018 屠龙勇士","url":"/2022/07/03/NOI2018%20%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/","content":"\r\n题目所求即为对所有有\r\n\r\n考虑以下同余方程的合并 \r\n\r\n\r\n令\r\n则\r\n设\r\n则通解，，可通过求解\r\n，注意此处不需要乘上系数\r\n\r\n最初添加一个方程即可做到\r\n此时可求出满足同余方程的答案，对于条件扫一遍处理即可 #include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;ll t[N], sword[N];ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if (!b)    {        x = 1;        y = 0;        return a;    }    ll gcd = exgcd(b, a % b, x, y);    ll t = x;    x = y;    y = t - a / b * y;    return gcd;}ll excrt(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;b, vector&lt;ll&gt; &amp;p){    assert(a.size() == b.size() &amp;&amp; a.size() == p.size());    ll A = 0, P = 1;    for (int i = 0; i &lt; a.size(); i++)    {        ll x, y;        ll p1 = P, p2 = p[i];        ll a1 = A, a2 = a[i];        ll b1 = 1, b2 = b[i];        ll m1 = p1 * b2, m2 = p2 * b1;        ll d = exgcd(m1, m2, x, y);        if ((-a1 * b2 + a2 * b1) % d)return -1;        ll lcm = p[i] / d * P;        __int128 k1 = ((__int128) -a1 * b2 + a2 * b1) / d % lcm * x % lcm;        A = (a1 + k1 * p1) % lcm;        P = lcm;    }    A = (A % P + P) % P;    for (int i = 0; i &lt; a.size(); i++)    {        ll now = (a[i] + b[i] - 1) / b[i];        if (A &lt; now)            A += (now - A + P - 1) / P * P;    }    return A;}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        vector&lt;ll&gt; a(n), b(n), p(n);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;a[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;p[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;t[i]);        multiset&lt;ll&gt; st;        for (int i = 0; i &lt; m; i++)            scanf(\"%lld\", &amp;sword[i]), st.insert(sword[i]);        for (int i = 0; i &lt; n; i++)        {            auto p = st.upper_bound(a[i]);            if (p == st.begin())                b[i] = *p;            else b[i] = *--p;            st.erase(p);            st.insert(t[i]);        }        printf(\"%lld\\n\", excrt(a, b, p));    }    return 0;}\r\n","tags":["Number Theory"]},{"title":"P3746 组合数问题 循环卷积","url":"/2022/07/13/P3746%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%20%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/","content":"\r\n给定四个整数 ，求\r\n\r\n\r\n转化为循环卷积\r\nconst int N = 300005;int n, m, k;ll mod;using poly = vector&lt;ll&gt;;poly operator*(const poly &amp;a, const poly &amp;b){    poly c(k);    for (int i = 0; i &lt; a.size(); i++)        for (int j = 0; j &lt; b.size(); j++)            c[(i + j) % k] = (c[(i + j) % k] + a[i] * b[j]) % mod;    return c;}poly fpow(poly x, ll r){    poly ans{1};    while (r)    {        if (r &amp; 1)ans = ans * x;        r &gt;&gt;= 1;        x = x * x;    }    return ans;}int main(){    int p, q, u, v, w, x, y, z, T;    int r;    cin &gt;&gt; n &gt;&gt; mod &gt;&gt; k &gt;&gt; r;    poly F{1, 1};    cout &lt;&lt; fpow(F, 1ll * n * k)[r];    return 0;}\r\n","tags":["Generating Functions","FFT"]},{"title":"P5293 [HNOI2019]白兔之舞","url":"/2022/07/05/P5293%20%5BHNOI2019%5D%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/","content":"\r\n设为白兔跳了次终点为的方案数 \r\n可以用矩阵优化，则跳次可以用矩阵表示为,为行向量，初始只有第列为1，为输入矩阵\r\n设，那么最终在第个点结束的答案为，即行向量的第列\r\n接下来求方案数 单位根反演\r\n令 可通过矩阵预处理得出，为次单位根，可通过求原根之后求出\r\n算法变换\r\n差卷积即可 ll get_r(){    vector&lt;int&gt; vec;    ll now = mod - 1;    for (int i = 2; i * i &lt;= now; i++)    {        if (now % i)continue;        vec.emplace_back(i);        while (now % i == 0)now /= i;    }    for (int g = 2;; g++)    {        bool flag = true;        for (auto p:vec)            if (fpow(g, (mod - 1) / p) == 1)            {                flag = false;                break;            }        if (flag)return g;    }}ll wk[N];int main(){    ll p, q, u, v, x, y, z, T;    ll L;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; mod;    matrix Z;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            scanf(\"%lld\", &amp;Z.a[i][j]);    ll r = get_r();    ll w = fpow(r, (mod - 1) / k);    wk[0] = 1;    for (int i = 1; i &lt; k; i++)        wk[i] = wk[i - 1] * w % mod;    poly h(k);    for (int i = 0; i &lt; k; i++)    {        matrix f;        f.a[1][x] = 1;        f = f * (Z * wk[i] + matrix::E()).fpow(L);        h[i] = f.a[1][y];    }    poly F(2 * k - 1), G(k);    for (int i = 0; i &lt; k; i++)        G[i] = h[i] * fpow(w, 1ll * i * (i - 1) / 2) % mod;    for (int i = 0; i &lt; 2 * k - 1; i++)        F[i] = fpow(fpow(w, mod - 2), 1ll * i * (i - 1) / 2);    F = F * G.rev();    const ll invk = fpow(k, mod - 2);    for (int i = 0; i &lt; k; i++)        printf(\"%lld\\n\", fpow(w, 1ll * i * (i - 1) / 2) * invk % mod * F[k - 1 + i] % mod);    return 0;}\r\n","tags":["Generating Functions","Bluestein"]},{"title":"STL容器的一些细节问题","url":"/2023/02/27/STL%E5%AE%B9%E5%99%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98/","content":"\r\nvector通常保证强异常安全性\r\n当 push_back、insert、reserve、resize\r\n等函数导致内存重分配时，或当insert、erase 导致元素位置移动时，vector\r\n会试图把元素“移动”到新的内存区域。vector通常会保证强异常安全性，如果元素类型没有提供一个保证不抛异常的移动构造函数，vector通常会使用拷贝构造函数。因此对于拷贝代价较高的自定义元素类型，我们应定义移动构造函数，并标其为noexcept，或只在容器内放置对象的只能指针。\r\n考虑以下一段代码\r\nclass Obj1{public:    Obj1()    {        std::cout &lt;&lt; \"Obj1()\\n\";    }    Obj1(const Obj1 &amp;)    {        std::cout &lt;&lt; \"Obj1(const Obj1&amp;)\\n\";    }    Obj1(Obj1 &amp;&amp;)    {        std::cout &lt;&lt; \"Obj1(Obj1&amp;&amp;)\\n\";    }};class Obj2{public:    Obj2()    {        std::cout &lt;&lt; \"Obj2()\\n\";    }    Obj2(const Obj2 &amp;)    {        std::cout &lt;&lt; \"Obj2(const Obj2&amp;)\\n\";    }    Obj2(Obj2 &amp;&amp;) noexcept    {        std::cout &lt;&lt; \"Obj2(Obj2&amp;&amp;)\\n\";    }};\r\nint main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::vector&lt;Obj1&gt; vec1;    vec1.reserve(2);    vec1.emplace_back();    vec1.emplace_back();    vec1.emplace_back();    std::cout &lt;&lt; std::endl;    std::vector&lt;Obj2&gt; vec2;    vec2.reserve(2);    vec2.emplace_back();    vec2.emplace_back();    vec2.emplace_back();    return 0;}\r\n输出: Obj1()Obj1()Obj1()Obj1(const Obj1&amp;)Obj1(const Obj1&amp;)Obj2()Obj2()Obj2()Obj2(Obj2&amp;&amp;)Obj2(Obj2&amp;&amp;)\r\nObj1和Obj2仅仅相差了一个noexcept，但这个小小的差异会导致vector是否会移动对象，这点非常重要。\r\n将main函数中的代码稍微更改一下\r\nint main(){    std::ios::sync_with_stdio(false);    std::cin.tie(0);    std::vector&lt;Obj1&gt; vec1;    vec1.reserve(2);    vec1.push_back(Obj1());//这种写法会被clangd检查建议优化，这里只是刚好需要这种写法。    vec1.push_back(Obj1());    vec1.push_back(Obj1());    std::cout &lt;&lt; std::endl;    std::vector&lt;Obj2&gt; vec2;    vec2.reserve(2);    vec2.push_back(Obj2());    vec2.push_back(Obj2());    vec2.push_back(Obj2());    return 0;}\r\n输出： Obj1()Obj1(Obj1&amp;&amp;)Obj1()Obj1(Obj1&amp;&amp;)Obj1()Obj1(Obj1&amp;&amp;)Obj1(const Obj1&amp;)Obj1(const Obj1&amp;)Obj2()Obj2(Obj2&amp;&amp;)Obj2()Obj2(Obj2&amp;&amp;)Obj2()Obj2(Obj2&amp;&amp;)Obj2(Obj2&amp;&amp;)Obj2(Obj2&amp;&amp;)\r\n可以看出由于Obj1()/Obj2()只是个临时对象，即使移动时出现异常也不会有什么损失，因此push_back时会调用移动构造函数，但对于vector内部元素移动的情况，如果出现异常可能会导致vector的状态彻底混乱了，所以在不保证不出现异常的情况下会调用拷贝构造函数。\r\nstack/queue为什么pop函数返回值为void\r\n在《C++ Concurrency In Action》书中有一段描述：\r\n\r\n\r\n\r\n假设有一个stack&lt;vector&gt;，vector是一个动态容器，当你拷贝一个vector时，标准库会从堆上分配很多内存来完成这次拷贝。当这个系统处在重度负荷，或有严重的资源限制的情况下，这种内存分配就会失败，所以vector的拷贝构造函数可能会抛出一个std::bad_alloc异常。当vector中存有大量元素时，这种情况发生的可能性更大。当pop()函数返回“弹出值”时(也就是从栈中将这个值移除)，会有一个潜在的问题：这个值被返回到调用函数的时候，栈才被改变；但当拷贝数据的时候，调用函数抛出一个异常会怎么样？如果事情真的发生了，要弹出的数据将会丢失；它的确从栈上移出了，但是拷贝失败了！std::stack的设计人员将这个操作分为两个部分：先获取顶部元素(top())，然后从栈中移除元素(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足时，应用可能会释放一些内存，然后再进行尝试。\r\n\r\n\r\n\r\nC++98里没有移动构造的概念，返回数据类型可能会出现异常安全问题，这是C++98时设计的接口。\r\n","tags":["C++"]},{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"\r\n设权值为的答案为，对应OGF为，集合对应的OGF为\r\n考虑，枚举二叉树左右子树的方案数和根的值，可得\r\n\r\n均大于0,所以只有为空树的一种情况即，可得\r\n\r\n，代入和 ，可得 \r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"TODO","url":"/2023/02/16/TODO/","content":"\n  51a47be05339f396953926958ef9b35b43dd8f38487f5f35d15826d560c9f501e66f3068559d14999d62b9bfd9326d12e234bb5701265dcfab462469865e45ab67aef329e8b0ff8738dae72fe0d2464c6cd8e0c7396a9e01c4abe4abf1398b8685e8c882d538eecfbaa4f8a2460a46d6c42df6ce7bd46c66d4de6bb75dfe35d9265aa8e24d95f9ce3d8c6ca5730d97ab739a796cf01f96587408cc52838c4246126d6f8a95419355836eb23a4458a45b9b01c6ec45c046ae5cbf3794a6e0c7626ac2652f4aa4195031c2b5f58ba7682262cd69cd479463acb9b44272db5dd489376b2cde635ef152cdeb2456bb515764b1a67ce375a3e69206362305e70939267f69ac0cd921644b8e9c80b2e6a420f6b86f222a6947d54d43862547a01153f9d235a582fdeac5ab32c976fb68622c74c41f4b67a7b2d83481afbd3c95d83114ad82025c5b00531afd8dc2ad25f186b08164ca0ba4c16589978b909c4f62a89169c4b6b5b1baa47650f7c6aa38ded547d15dbc48d6b1959b012f9e78a2bc829df7072d2986ef33bb0e754550a40746434b12e2594d29e3a175f7eebefafe4a83898e2d00e705833b2ca4c7c242ad2763c391da7ed7464bb0b9ff6e3d2c4a6926a6b9c26d030f6c0d02bebbe7514901363e45942e06e053ddfb20cb54ea3d0d5292943b6bb8c71e86321300d3346d3790de327df7d618bd851805d3553f88b93d257b958a6549ebe46e41bca270469dc6b01e1b9ea3c02aa9097bcc1af108c28746766e57f07c1428f709a31f3c9fb2cedb49e7ba57c76f4ae7391d84465d31ee8f0dba3e604cd9585f30c803a4e5d0a9f77cb8b6273241e2719918fccc5b2ef6c0b28f37e294b11c02e8bdcc46e23f0bd22b8761b30de77e57eec45e31e1f906686c627c46ea57895e5972b512a138d73a753490c5387e06d4f3db7faa6cc9630271aa6cd4e01f15308308c5b73eb6fc94d3242ed38ca97bbb5baccd7f55c5ebbfd9b4ce5d2c9f8f90d56189a977369d77333948830949decc0927b081be4cb3030da871b65099e3fcc11cf4930b7ed4688e85ceaa5e776f64e55479a37c82b7da5a4006fb1a0bf1f9dc517e3627e48f80d6fb40f635ebeb1b025eed9631559260d2448149f14275c5aeea5afcf100c53710db275632d945b9ba2268e4fa3b61d948268db24903920079bb86542d41a09a30d5b7edbaa24eb2736f5bf8c373c1281335cbcfa09ea848f692d0a932ecfdc5be9332ef2762ae89d0e8da0bc1e6e72c7a67008fe223def37cbd4b1930cf96c71c01571a962b9b8ce4d401fb2c3b2df158e4f51af06b6640e6a37118dbf41522f25a992b9ff0c6464ac7c1a017ad728ca824cea7cd233b607a7d949ccd872cc936151d22c7c7f75f62e8ccb70ecf3fe560029ce6c3c184396ac327cb55f6797ded8bf3a09e4072a87202210549de6bff3a956078a3a94aff7d07dc1c387d36565befd9d4181f9972095a37f340bff213fcf5ccb244fe0d610001f90b29f211c15dd3b8515568305c4847b84da53f95524491ca61515347f1c5a2fc5e3dfc9ef5799acb28039398baff9d61065ef5f8d468175c2e031907d0b52de8fb1d1b35e7b92ad1e2a2a601f24c4c64c6a8a66b91a66f298a1e90c37991429ac815151e2473412e4b2851b80e8473e840aeb21382afa2494a99dede6bd54c3908dabd2123011f5ea92496d0c0b7e30267f9e08d4a75944eb1b9a039406577bb4a43a8ec4c00dbf0c4d0a75114c74260d05c313084dd274328fc26a4735669c52d554b1aea506b44ad5d928774d614251e5bd268ce74774e85cedc1f2b87978a3a97fe76f936232722fb48ecb8db2de588458d0564639c1d92d66949fb6f4df1da4b97f19d0d66da0041b07d85bfd6c1c84d8bc7467f3d48005cb14e3a993c4675574477a3660c48895978f7e3ea7fdcc01b2d305fff05227f6efcf106ef684d521009abe7745223a8a026836f54e77ec173c34f5ea5a90b292395fc65c6e4556fd8717e71952c2d90864c865c47981cd6f5a43513aff95ba81828ae9c8536e577230a5cdb00daac331100be5f88b55377cc6a1c1f9da407fa27ac218d7ffca5f5ef04e9ae888c49f4763940f214197930db2a84957b1910e89c4d81b91cf26e3aa23fee6422a9a47902dda2624c1ddc0cab27505dd11e301ec9aa470192fd3426aedda3157abd0c1745d30624c3d4f1f4c8fa4b80ea601f79d204459850dd5d9adba0a2ab0303ef576e85d955346d3b0a9b8aa83cc80e68b71d83c51a1016ba62e18a5e68a0a4c979b852b37aa41578e18ff1fd6327f03240aaee4413fa900268f49205657a93e6215e9bb2821ace26ea3b0263f27b9b216427e091c9940c29560bb0296f7bff4031dbf2cade4d28858e689ad8cc6880dda61e45f947009251a6e978724c4c0f5f5da253f419a7ceef12b0f1670ca342321b8749917e0a554b0fc89a4341c8a7aa17c5f38937abab6313dbdaf5a9fa15863406b0317547306770a13a122916c2ec34a060834e168e68ddae3c5c9a044c6c0805e7f5f362467cf48370713472a39130ab661b9d2541318bb33e3957ce87b02301dfc644b7fde756bd4b8e587fd7cdaba98e906a8c925efcd04edc4f9f5d313306947bd6add785a79d7294992ccf27e430e41d22fc79eadbbfd6cea4b43b5f3255b9562caf5e9cb54965917e3a09f74061703e3532296c51082f7c7227551ab17ebe09e03269540221ad8328743e8225148939d00289fa166fb8fde909afdca1a3b1465caae8d935d73d3a9face7dc044b95c01799305079d2fff2789bdbe2961eecfddac3b17ff8be776859a273391a3bccf931ea108db77dd5a448c6e26d7f0c4a2513dd5e57246d86cd0d122d2dbb00e85f5bfa10c15b0539826b71a67e1957ccb52902c8cff9f5707dedc0f740aabacb0cdf11cc652b6df2672e40c5a29839690eb84f6e24dd55222d2a8cae2277ec1a3a8d4a49a0ddc836a70196ca189d1f67d970a13d60cd520a5a179ffc0df4af9a43d30c378d8229d0d3c3d0813d077fc6628f20615d75370c59a9cb7f0e4c3e0c8bac6ffe2e808fbaf3630a1e18535fc2bf98928ec4a340491850505dd04c9ce9b3cea84b4fab87c769acfd8e8bbfbece153d0fc21965a91bd62d0cff6ea8cbb85a9ce2a628dbb978cb57f6627f718a82533002f6e877f0614b4b5a03791f1d9124bab18ba13854bcaf144c32cdfc84e2c89d587828bf6a9d72774b73207ff45e80170754cc14fe1951ef776143a732e70fa01ea657f2684448d5ac4f05259cda209504ff2fdeee1401838214c63ecc7a8f8991462ace8d55967edb703919dfe212e4e47004a61356bb40bd5390abf2169732566f25384874f2554575836b12aab1513218f2abfa6136cc235cd92d8aaa68571f404615e94e01971d5e6c5f9cafcf911ec6a8652dc8488e03dda047370cb2624682f4952c0f13ddb622531ea4fd0dcc778070e3435dadfb8d60300e69c3beb07a61b2fd0a9c1a21aafca838a82098a29e420a36c89f9834921f18cea0281764088bd64ba51b907edec13df7d0d2592c71a11f8b95aab37ef79f4c79be32cceb78d22ff53c48a2c99c45c291e73525d0e98ff41745a9463b3d72a4e05e60d6b25d9998ee47f330fc3c68d7ee07911c1e4f7370e87c4f2fd2e83358175165f1fb28365dc7906e008088b12354762b2b8da81901c24a2874c7d47570acc74054fff29e87f5d2ebd9138ccb22c9e594b6f5f257b34c4b0f9c0e3471d8ea8447afb79f4d79ac05cb9568d732843ac05ce5fa9312f0aba84b61eecf9f106d318792f05075469189c2555b93a61ab1b64d642be7812c7a138f5b3b203bad98cbc758f4bef1e40d800b1dd57c09c292dc41504cc0c02e8359c198b33db14a7bf6b8d6e6d30e8552f1dba580d9b1458f6d72f16f449e9d0489cc3eaf3d81813838cacd81512141356532e0143e16a16a8d3b7fa4f6cc9e4f66bde5352ea0203b24f7b20f6eb6ede55a2a6b406efc4e00b637c4adb78803e95a906fdd0d80c73a14b7e2a3ef0a4f0033578c1141f2df625f4905e5aba3bee7448e9ad68866e01eeaf63409e40eec51b87f075cc1e2086bf777135ab073382b5d274898de76292ae195b17322a15c5e1586f83a71a909760e7a2332e98ef6b8f92642ee136d19916c665b64e551cff28fec62f68c7e8bc5269ba18e18f56a333b6e954821e272eb7a805b29f14b5a72fa24f9aacae0542d63369df803eb2fec533f2d5b3f4ff165daafe89670f92e6c3cd679d416349f395c266a70f5289051ba69f1e2b61866a8bf2bb6d656a38fdcd56b83e495754ae5d19c61566a0638290dd3f34093fff464f523167ddccf40a703245d13a0c024d6eee7706d8a624b96c5661ecd35fb6ce3e20ad5715366fa187b4111e9f499a690f90a66d64fe55e338a1ed6d4746e243b9806cc3f2d2766787079a57ceed316ad74b59ef2b8d9073f8c4c88beb21905486b7375bf18396df1c6e52ec5addc53fd277414eae78f594a85f5cae18ef7efc4931742cc9e07d5b44fe940ccb413eac6ed303cb7490421657b68d951f176203e63dab3ac04d37738c58e28a6e37c39b71d642626c28e50e1ddc220f1991ee64ee888f56b6a05e8e97645ee39f40cb6a6d6b8df016f83daa74b07c2f95c1686b03d032b4c99e54e67fcf64af8bc3aa39e0ca059f451096565a4a8686a8c56d6711284d9fe02e6015633e58f0896859aefdf0dad764d9b1af4c1d7399ba9724074b9571f3b848d97af7ed411190b68da5ef23564e6e0fae6177cd28ba3dc8b3b50d550fb6702942501b3e59cf37326407a261f3f84b8c7192ad3d3b926d079e752d65145bf083a0838bf73dd2d27668f96d0f13cf215fc20b63be700d97346a3438685b55d6018496a6d4f50cadc327dcea96e36b4b14a3ee9c520ae759c131e7bb2894087c23adc79a7dcdbe39230fea4e47beb6667f3ee2985554ef4eda8bc942493485cbf4b4701347b12b20adb406143e571719111f8f9dadc55e6edb10b8fa3cd4ee12dd9c66168a6330db260efdc1d1a9b7e3478046a6d361a3caf92322945ea683460ac4ef785b868285116030db7c5c4506ffc1075889b55ba9d15488e15bf92338b8ac89da4c1c2e21860956dda9d2a83a55e7f985b6399a4166fbeae47c4ce03eae3a976442c0c482b9987241cb9a16fa6d22e9c3e4cdfadb599d4057865e3ec493291014346be5a93c7f461773004086bbe6055a9ce595be55f99cb9288ccc6db3d570373adaed47309faa2af0774acd5c87a1a9147206fbc32ac97230aaf04f2ca45d9d95e37b83c78f2c3b292076218028e601cfaaccda9eb8fe5b6a8f373b3f8ef3f667713dc945b591e0730f548c9c147a7e688d39a1c9425f2d3f35c1cebd8b0b4e73305750d35b95e76692ca95b7f7189ed4f006ac858e90f097148730dfb0bb71f3552651b9f6417c89e5331aef4a153a717a4d656997276516935a3836cdd72e35b77c56c6754f40599aaa676228575f2931c0716ab15f0431841f67d9c049c5537cc20b09729198e808ed18d87d3c6ade8b8eab61b8468d7ae3c3409124a9228836cd3c6adef089a75d50eacb70fcc1d2c06a769cf76f702dd8bc92ae06bede8b1bf5f66ff18fc0d9881b07b11c06fc18d9eed37cd4b3d87d7577b53030e8b3b7a0a8a0cc47e95d2a0d326b7f082f5bd84d7684ff5b31d153f160fcf48ca529c56396ff57d672e58bc8af21419b9adbcc84d5dcc32135f2f1713727c5b2ad839cf188a0c998611ce42850dd240be3750a8161e9a29d16c463350afe6325856543739d492f316724710e69491c7e4f2105d193cdcc38140496fbfba4093fe056e51530c1b0754e3a22dca7253b7af5f5912166a3f52885dca2129c9b7ef37657b42c89c604114d992ebfc3b04508aff3e79a362cbce59b91682ea0f288e49bf88084eb83a30502dac2da21df918253fb757ed37efd7451408108f5d34b881b821feadcf620b630b45c577f0e07ec59d6d2e2e790831147599c7407ddb30dd17053eea305876fbc31ad8f818204ce907b2e92471cc32d1f7de6aa62ae7ce4a29536475d980913cc1f6161dbfb939c6bed7bcbf9dd25f95e84febef050c89eb528efbe0c32d3f716286981f7f3c98fd590d704e1af107d92f60eff9812da79cdc10718f78f11683ab1bb092468d645f6dc523e4f3cffa39b94ab11d5f522c1df370fdedda17b9ddd573b839d2ce25f8272e3a9c276aaecbe771d03d62045773515cac5ee358fe9a40c076e26d5d16bb31eded8a8cc11cfdc7e92caeab03e22c21c4b63ec8f3a788ce32787a4c8379897f59c466dea89d8b51575d8c513e76761ef0774fb0df86624c3f1b27d0bfb97bb6d062518442e1e8855d81da6591ba8c8e270e99fb366b0b7ef3455a3bcfefe9a32ee62b77db89fe9c3cd1d8e4b59d891aacb5de1ba93c48389b70295ba61faa5e1e8eb379a60fb0e86604f6026afecb11201dc29da565b71fb17ea1b94e68675be3a34bd4bebaabf8038903bde057d1787487c2276b3c99389af3cc699cc38ba7962a0af0b00df552fb31e8c9048b7ce9d2411c53425e3119828e3fd33c9dce6b502e83c72b8bb365ef6ced1e1ce9c2938b873ba00692238d8e0c1938addfb13bd0c5f7f37782ca105b9c63ced230422b402ffc8a62fd5054c7495e0ae9649e89dae5305f26148c1e96072f8b390bba9650806de8d764c0749f0b6640012a9e076870d41cde454245f2c31baa216bab22455c5cf00618d6a1c019f3a1a76108826992e5642030878f4dc5deca18986494e35cc6f817a773848ca3ec351431e80ad6540d99551a30ee8077b39db09241ffc640e8a1361a3ac60daf91cd8ddbc02beea940e0ed80059f00b6d295a648b03a88b4901c5ed8736eed60040d6b76e9fc5239510de8c040011a8f5d2185886ba00b169d763192ea85e82b834806c9abadfc595835e14149aeb5e44be647f88f9d3b50d26f9473582bf0bd2ab6f76d16d7b8ba92cb2d8cb11b8e98051e5cd6ea1d697da51320a4ab404022511d75f8ef97f84844aa83856fdc38db2d819a97a028a31ec28d4d1650db62c7f048d58efd09453850c8903a3cfc29b9294bdba166119eae49d11a7aea9ee19729e93a4f61df3b3fc8806fce468b40743f90ae24cd413f4b128c3982cbddea38e8809b5904c0a83fe54fd8c8b127fe8bdc15bf1b39c0f1e996ae3622f7302fe8922a0cdd95d99091317ac5cff72115b6fd6ccfae0c6c1e1d0520a027992021adeb3403eb1d2ee49034c223f4b00a6b0e855af7cd15d3b90d4e1f4e5647b09c0d1710ee52c5f2896f7e3f0f239faa495fd07f6a783b708e574a4c5a94556c4a7ca2812f6068e3388e553502e301f1e8bd8f1d210930da4d9dcb49ccbad01500d241d3d55d47c8942cdf9cb5b2e82747271d0f765b8e0cb079b5a6194ac238814262c34d30421b916adfd1bf713b86cb2088a0202c9565e3705c02332c44be209e75edee0cc6ef8ee63f03232de11f17ccd9c3ae1859c9dd60258f3895362cfdb11f4ba3f2f2978f1b2d0c1428466d4cde4ace67b04a908ced26cf8a6acb11284f06f52faf04258ce918dbe924572d964541de0f844d658afadf643080d6490b5a427fa3212757dd6e2e4f5185045d43c2bfd9238489219f5c92664999001b5c834935c353195d65716cffb047b7b51c207410b10e63964d90bd3192f33ef8e11d14e2e2c09ce563459e4381c4e1961e017e5529746d7f676c6f8d1cc956bcb2c857d01ae514c50b56f9b6a2ac71562c39d79f9fcd127de998d75cc10dd7ec77631dd31e4a89c479e8487f3aeb9bda209da7c75805217899a193d34c3bc0c2fd3ae27fd7429574531caf34b4111005dd8e5dd0739097165fbf2d91393fed1c5669498e862d51cd28ea5176e8e35094874b559eaa67835a109df19a91bcfe94fe9d9934fe66ba37c35856e8751a8c84e507061226eb62ff02cda3c2594a538e977ead474deb845ec26d8f4f795446eeff71d94f247fa9a1d98dbdaa7e6b864d3c98a5e7014d00a5852a9b17a147e113ace5ef9c10c01ee3196dc7b8863bc5e4447511fc7601b20fc5809e5a4e048bfd8be3c8a8b9b9c5e273449451ff5d02dda6028015390d8487fc320b4cf06bb27f5c2b2d71b735c43e0fa7d1c13ab65ea65e5ead0342de708a01e104c7d4b5b66ce5467eec1ef81b2d689f866a6fa9284321af7206006a312fe56f86a790f55cf2750cd851d115de1d445d71e904acfaa31cf1b11dc1a3f3772ad2876d63437d0bdaa3740bf45a44bb5567a6bd5be5598921e3d9a4a1cfe0854a38ea705697781d14b82efdd2e35c3af1b63ef90eae2417f41ff3a7f2fd2b56f2c96e839d716fe896539fae56fef25ffa61addf74974dbf2c44163e2878fd961e1de02f49bc58dad3a48efd744fd1a584f7382ac31eafe511ed9336c3e0124897975db477adb09df196ba28f31b31f333cfc2ae57ac2d48c4a0bf25cc88bc860a5141c9123e42463bec33a2d040a0d45e8e165a0e085b98c16fc858fd06388e088ba15fde12f1ff73f62dfcc94c7f0bf1e4a158dfa51acd3775455ec5f47e2f41927ffdc9fda8240ee1548bbc573b92592c7cf490f0f889f84b7b504a1462e8afc6d216adefd45971f2ddcc47317f0581248307322ba7c2da027ef23fef75d12467a7d0f5f8984ad8d2a870a1e0997553579b0833f55e4f4947f98887481afd57ca7d4a4e1be2608b27a1e3d9d2d332ce442574f1123037c7c65c6907a7d993f4b04be805447f6562fbb0e656327a20ebf21d88bfcc129397f086d03ac06f8a012f1713d6f9d5de13a9bb0f7ee24a6880d39e0b2258e05d2c39549732667a87e3fb11e140e57298f46496c9e99d89938a9ab65c232c33b1a793d347f38a92b5f74f33ea3af255346ac06537497501d1dcdd638d51a77e9c69ab237183abe211f9107afca9a2c3fb1c279b015ce511e193d3bae12011965df971904b365bd671a9e9afe97316b7ebe29055be1fd59cc466e80749189cbe4277b439d2fbd68f7ec7a46b5478ce2eb5d122261f626d84dbec722ebb9a505c6654e3ed6d74fec92a4fab08c630a6c9774cea7733de7718226e325b4ee643215cde0870e9313da92986acc76bf1c68d4f82d27d2d851a9e7c625659ec93b408172413648b118734f97498beb9c997ca19ba99b036da814102826fae1cb2bafe4d1859e533218a129110ada2b393422cc24f5c7aa88340c7234fcc971aebd56524169d17f5785e3a981a69a930c65c51ffe04c3de73b208cfe70e8fb503b0c36500284be19bce95fb43fb4e8756069910f854e2e245c5117bf6f2e3e3acd537bcdf190e4c8ae76d5075e6a789c59ab8e792ff912b62374811d629db5eb67cee9c67de94c44df5a1432e34cdd8b75f075c8e5e81ff3bc437a298755178da0022a1da025c99a0b955f607584d8ad0cacfbc86bb62f7b05e0211140e8b4de295ac173ba1bdf5d5393c1001b57189b5d5b61fe0276ffcb553d30fa9bd9d2dc697ff9d3a7b8f2fa7f9223efb26372dce81a825caf70bf793a83a829cd653bcab721a44ea32d2ff38a552ab7daacaf9d9ddd27c35c62cb24a5db238511995f3d79a00f6c59e06dca3dbd8399951520113bbbf4b814f5d9b2dd21fdfe6b4eeb1090e2c9f3c434ee2d15618aa3299e5e26dcecddd34f6e088501cd2a2b1ca0e66d6c8193d472581c429d5fa87680537d8d77ce6cd184912b725797ed34a2d35d631277dd05ed79c3f3e5c8b27f7091c29bfeedd40776653cc4978572c58f93f76247f4e6b36d3456266763d36adcb5578a5a01b0cac4123763a4ac2f999afa276d06b8222b87451def98e63de8c60993e87f9f69cd4fddb8dfc6afd6e0df3945add8b1ab1c1710d43d5e337e5ab5385f3d12041a058cf0bbae6f55f8d4fb22d8995984848671d92df396e4f58439c867094a04180df9c5a40ddd664364cf5f8a5c43ac6ac48b58c95dce7d675dc13cd22d4d06276b1b3883b0b626b9eab314ba6e625414c641d27c49859c27e68a61ebbe3f69c85422c636714693e66b3124f93a9c6cc8f1416ba8a997c06da4096a505a6c1fff651955b808bc15430cd63d8df67f8e27301a3421b0b089efa5141f2f93a3f93d9dab26b55c2d36b929475a1895d3870a1190d2c8819a7af5fbe5cbb1833d5566bae575cc53a7d959bc728e2a4a00b28365fb20855b91579d91087f95888788efa6d9637bb5946c18e58ad9e3858c79bde1e950b8b062245c6d203f04a4c8341b736cd2dd58508e61d6941ec00816435909476b8658b5db8475ac472b9c132f5682615775ac95dcae056f29b172256141a46ca25aabd85b66eb9d6503a48b43fe1e32af9fde632eb7be82345d4837460218f7d08de32fa0660e601f9409732ca3539860e4dd2a33c47ba4157f97ee62447224bd50fce08ce0aeed117a69e2fb7cab0b65d1483f7a0bba23080ffb15b14f4ad038a603e4e37bf0770957c6105930044160a03602d39e495be035ce9232e1f423b63c9b80cf61affb129ed574a4f512689c889faf77c790af2552819f6656563376a9c03c65beacef4ea736dd3588bf587ee14f079606f5a3b9666ccf8bc5bcf092586f60ebc7e787864de11ac0ad5107460b8ffa3b7a35ff827cc4c4b269039b2f036bae414e8e94c0954dacd43a5fcb483b4656e60a181c68f442bc4d5b29671076a51bbf4b04f4c51836dc344c6643155174c8d4c53cc98ba912a55c72b45d9e264bdb19492ff8a471c301dc0b1d7f04d7834d42427e3b6155ea8cc19345d6e321e43a84085058275b40c4e6bceda947c192a794598d8a13647a4b1647330a1ec63f34153b84f4ecc3155411f7855d8a7a145bced6298ed68b57ca85367df9837a6b23545c9d8405c26e33421111f2b85b1da7380675624b8df3992d80eb7681a9b79e7352f5da4b2589b306dfc3fa21ede2028ae600d7c12f9992c719185612e8fc7f80b3bcbbf8d062da65808dc3c37f8e67eed349d865e7a2cec197015caa50c6fd29b9709c7e33c353eab5e592cf3b4b37c81077409b284dd44b07dfe9918b65de6df7fe3ff73c91f9b46a1af8f812986e1f5cbae2d495e49f7b1b0d9d6f6e4a73379ba11ca508bde866aff134f37428ed6b3fe0a1b7b496562f904819fe7ecf71780f062e94ba16cc83dfe7d0d12b482c8e4891f9d93b19055d3dd22f4808a686cf6a133e86e23f0f7b3e4edc788b1aa9cb41ef06bf5df4fdc0bdb0066f2edf3757a07a7cda98b2685e97c31a2c249a158c418e23edfaae0ec6764c76bb6d5465ed84df3eb6b3dcff5c11ed18ca5fb5293304dfd8ba5ce033b892783835a5252baff9d1166e8a23b6be3169f3f36dc44321e9c01299f4ae580da9a5cf9eb9d663d2b2ae794571\n  \n    \n      \n      \n        Please enter your password\n      \n    \n  \n\n","tags":["TODO"]},{"title":"快速沃尔什变换/快速莫比乌斯变换","url":"/2022/04/10/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%20%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/","content":"\r\n笔者对快速沃尔什变换/快速莫比乌斯变换的理解也只是刚学阶段，本文只是写写自己的理解和一些其他博客略去的证明。(还没写完的部分可能会咕咕咕一段时间再写)\r\n前置知识：卷积\r\n对于多项式卷积，其思想是对于两个多项式，首先经过转换为点值表示得到，令，再对作一次转化为数组即为答案。\r\n那么类比多项式卷积，位运算卷积也可以类似定义，第项和第项的乘积贡献到第项，则，此处对应某种位运算，那么只需要构造一种转换满足就能实现时间复杂度的位运算卷积(论构造手为什么是神)，具体构造方法可以由数学推导得出+真值表+矩阵求逆得出，由于笔者处于初学阶段，暂不去推构造证明\r\n以下只讲与、或、异或三种位运算卷积且序列长度为的幂\r\n与\r\n\r\n\r\n构造  这样就可以在时间求出和的乘积，现在只需快速求出变换和\r\n设序列长度为，下标范围为，由于和位运算的特殊性，考虑对按位分治，设\r\n设是下标为的序列，是下标为的序列，如果已经求出了和，那么只要计算和相互的贡献就能求出\r\n对于，有，考虑二进制表示，则在二进制表示上比多一个最高位的，即，因此对于任意若满足，也一定满足，又和构成双射，那么对于，在上恰好对有一次贡献，在上不变，因此可以推出下式：\r\n在区间上为，在区间上为 那么的分治就完成了\r\n再对序列做就能得到答案序列经过变换后的序列\r\n对于，即为的反演，考虑矩阵\r\n 行变换后可得  (这部分矩阵证明反演笔者也不知道是否合理，凭感觉写的)\r\n那么可以推出下式： 在区间上为，在区间上为 就能得到最终的答案序列\r\nvoid mul(int n){    for (int i = 0; i &lt; n; i++)        a[i] = a[i] * b[i] % mod;}void AND(ll *f, ll x, int n){    for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1)        for (int i = 0; i &lt; n; i += o)            for (int j = 0; j &lt; k; j++)                f[i + j] = (f[i + j] + f[i + j + k] * x) % mod;}void FWT_AND(){    AND(a, 1, n), AND(b, 1, n), mul(n), AND(a, mod - 1, n)}\r\n剩下的部分咕咕咕\r\n","tags":["Math","FWT","FMT"]},{"title":"洛谷P4491 [HAOI2018]染色","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4491%20%5BHAOI2018%5D%E6%9F%93%E8%89%B2/","content":"\r\n设为钦定种颜色，每种颜色恰好出现了次的方案数，设为恰好种颜色，每种颜色恰好出现了次的方案数\r\n考虑钦定k种颜色能得到的方案数，可得\r\n\r\n阶乘预处理后即可时间内算出\r\n然后考虑和之间的关系，有 \r\n二项式反演后可得 \r\n差卷积后乘上对应值即可得出答案，总复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 10000005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    int s;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    poly W(m + 1);    for (int i = 0; i &lt;= m; i++)        scanf(\"%d\", &amp;W[i]);    poly F(m + 1);    for (int i = min(n / s, m); i &gt;= 0; i--)        F[i] = fac[m] * ifac[m - i] % mod * fac[n] % mod * fpow(ifac[s], i) % mod *               ifac[n - i * s] % mod * fpow(m - i, n - i * s) % mod;    poly H(m + 1);    for (int i = 0; i &lt;= m; i++)        H[m - i] = (i &amp; 1 ? mod - 1 : 1) * ifac[i] % mod;    poly G = F * H;    ll ans = 0;    for (int i = 0; i &lt;= m; i++)        ans = (ans + G[m + i] * ifac[i] % mod * W[i]) % mod;    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"洛谷P4389 付公主的背包","url":"/2022/04/03/%E6%B4%9B%E8%B0%B7P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","content":"\r\n设商品体积为的为， \r\n则所求答案为\r\n麦克劳林公式展开后可得 \r\n枚举倍数后可得系数，再求一次多项式即可得到答案，时间复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }        poly exp(int n)//需要保证f[0]=1        {            poly a{1};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * (poly{1} - a.ln(k) + modxk(k))).modxk(k);            }            return a.modxk(n);        }#undef T    };}using namespace polybase;int cnt[N];ll inv[N];int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        scanf(\"%d\", &amp;x), cnt[x]++;    for (int i = 1; i &lt;= m; i++)        inv[i] = fpow(i, mod - 2);    poly F(m + 1);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; i * j &lt;= m; j++)            F[i * j] = (F[i * j] + inv[j] * cnt[i]) % mod;    F = F.exp(m + 1);    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"转置原理和多项式多点求值","url":"/2022/06/09/%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86%E5%92%8C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/","content":"这篇博客背后是阅读十数篇博客和高强度悟道\r\n矩阵的初等变换和初等矩阵:\r\n三种矩阵初等变换\r\n\r\n交换矩阵两行(列)\r\n对一行(列)乘\r\n将第行乘加给第行\r\n\r\n对单位矩阵实施一次初等变换得到的矩阵称为初等矩阵。\r\n一种初等变换对应一个初等矩阵\r\n一个可逆矩阵可分为多个初等矩阵相乘\r\n转置原理：\r\n转置定理：如果，可得\r\n线性算法的转置：\r\n\r\n已知矩阵，输入向量，向量为左乘的运算结果，求解的算法为线性算法\r\n称与互为转置\r\n若矩阵可逆，可分为若干个初等矩阵相乘 此时若算法较难求出，可先求解的优化方法即 的优化方法，求出的优化方法后以相反的运算顺序即可求出的优化方法，具体原理可以参考其他博客，笔者高强度悟道才理解此处\r\n\r\n多项式乘法\r\n对于一个多项式次多项式和次多项式,令，可知将看作向量，看作矩阵\r\n以举例，考虑矩阵形式：\r\n 该线性算法转置为  即，可见加法卷积的转置为减法卷积，加法卷积的转置标记为\r\n多项式多点求值\r\n给定一个次多项式，现在请你对于，求出 。\r\n不妨都将长度扩充到，长度不够的地方补充0，以下令\r\n考虑该算法的矩阵形式  求点值的过程为线性变换，矩阵A为范德蒙德矩阵，可分为若干个初等矩阵扩充为n阶方阵后运算得到，并不影响推导(应该吧)。\r\n考虑该算法的转置，易知\r\n 该式可用分治快速求出 令分子为，分母为，则\r\n\r\n以上为转置算法的解\r\n接下来考虑原算法，可知与多项式无关，可视为列向量，对应转置算法为\r\n\r\n线段树预处理数组\r\n由转置原理的第三条和多项式乘法的转置可知自顶向下求解，顶部求出\r\n由转置算法中分子的运算过程可得原算法的逆过程： \r\n叶子节点即为答案\r\n\r\n该算法常数小且易于实现，难点在于高强度悟道\r\n这篇博客中有很多东西并没有讲清楚，许多细节以笔者的水平难以表达出来，同时笔者对线代的理解非常浅显，暂时先写成这样\r\n以下是笔者写的递归代码\r\nconst int N = 100005;int n, m, k;poly mulT(const poly &amp;a){    if (a.empty())return poly();    return (T * a.rev()) &gt;&gt; (a.size() - 1);}poly a, F;poly c[N &lt;&lt; 2], h[N &lt;&lt; 2];int len;void build(int l, int r, int k){    if (l == r)c[k] = poly{1, mod - a[l]};    else    {        int m = (l + r) &gt;&gt; 1;        build(l, m, k &lt;&lt; 1);        build(m + 1, r, k &lt;&lt; 1 | 1);        c[k] = c[k &lt;&lt; 1] * c[k &lt;&lt; 1 | 1];    }}void solve(int l, int r, int k){    if (l == r)return;    else    {        int m = (l + r) &gt;&gt; 1;        h[k &lt;&lt; 1] = h[k].mulT(c[k &lt;&lt; 1 | 1]).modxk(m - l + 1);        h[k &lt;&lt; 1 | 1] = h[k].mulT(c[k &lt;&lt; 1]).modxk(r - m);        solve(l, m, k &lt;&lt; 1);        solve(m + 1, r, k &lt;&lt; 1 | 1);    }}void print(int l, int r, int k){    if (l == r)    {        if (l &lt; m)            printf(\"%lld\\n\", h[k][0]);    }    else    {        int m = (l + r) &gt;&gt; 1;        print(l, m, k &lt;&lt; 1);        print(m + 1, r, k &lt;&lt; 1 | 1);    }}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    F.resize(n + 1);    for (int i = 0; i &lt;= n; i++)        scanf(\"%lld\", &amp;F[i]);    a.resize(m);    for (int i = 0; i &lt; m; i++)        scanf(\"%d\", &amp;a[i]);    len = max(n + 1, m);    F.resize(len), a.resize(len);    build(0, len - 1, 1);    h[1] = F.mulT(c[1].inv(len));    solve(0, len - 1, 1);    print(0, len - 1, 1);    return 0;}\r\n","tags":["Generating Functions","Matrix","Poly"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"\r\n设个点的简单有标号无向图的数目为,对应为\r\n个点的简单有标号无向连通图的数目为,对应为\r\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\r\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\r\n所以，答案即为\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\r\n","tags":["Generating Functions"]}]