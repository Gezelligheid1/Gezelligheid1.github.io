[{"title":"2020牛客暑期多校训练营（第五场）C-Easy","url":"/2022/06/16/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89C-Easy/","content":"\r\n2020牛客暑期多校训练营（第五场）C-Easy\r\n设所对应的二元生成函数为，则答案为\r\n由基本生成函数知识可知\r\n\r\n考虑 \r\n则\r\n因此\r\n时间复杂度\r\n","tags":["Generating Functions","Combinatorics"]},{"title":"2022-2023赛季VP记录","url":"/2022/10/15/2022-2023%E8%B5%9B%E5%AD%A3VP%E8%AE%B0%E5%BD%95/","content":"\r\n19哈尔滨：8题933罚时，正式榜rk7，去除打星rk4，cf上截至vp结束rk35，C题机时不足赛后20分钟通过，正式大量VP的开端。\r\n\r\n19徐州：7题1349罚时，正式榜rk15，去除打星rk13，vjudge上截至vp结束rk20，未过银牌题M，本场因掉网和首次使用vjudge\r\nvp导致体验糟糕，机时上也很混乱，对队友的pollard_rho板子不熟悉导致浪费了很多时间，总体罚时爆炸。\r\n19拉美：8题991罚时，cf上截至vp结束rk120，还剩半个多小时的时候觉得没什么想法就先解散吃饭了，F题中期两个多小时没开出来我背大锅，被杜老师(DDOSvoid)n+2爆杀\r\n"},{"title":"2022多校多项式做题记录","url":"/2022/07/26/2022%E5%A4%9A%E6%A0%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\r\n牛客多校1：H题\r\nFly，基础不牢没学过完全背包转二进制01背包，中档题，挺可惜。\r\n杭电多校1：1010\r\nwalk，容斥+矩阵维护多项式，压轴难度，完全没思路，补题见Blog。\r\n牛客多校2：E题 Falfa with\r\nSubstring，经典二项式反演，例题难度，场切。\r\n杭电多校2：无多项式。\r\n牛客多校3：I题Ice Drinking，压轴难度，数的touchard同余性质以及快速求5000个级别的第二类数，不会求这5000个斯特林数，比较可惜的是只差这一步，而这一步在翻混凝土数学的时候没去翻二阶欧拉数，二阶欧拉数能与转换，差临门一脚，可惜。\r\nPS：东京大学队伍有个神秘科技可以求单次的斯特林数，令人震惊\r\n\r\n杭电多校3：1001 Equipment\r\nUpgrade，cdq分治fft优化期望dp，场切，中档题难度，但是过题人数和牛客多校2的E题差不多，人均会多项式？\r\n牛客多校4：C Easy Counting Problem，中档题，场切，但是选择了枚举而不是背包导致需要卡常\r\n杭电多校4：无多项式。\r\n牛客多校5：著名锅场，无多项式。\r\n杭电多校5：1007 Count\r\nSet，普通分治fft，签到题难度，场切，270个队会多项式就很离谱。\r\n杭电多校6：1003 Find the Number of\r\nPaths，金牌题难度，会，但是没开，一整场卡了四道签到导致时间上寄了，所以另一道置换群模板题也没时间开。\r\n","tags":["record"]},{"title":"2022杭电多校一1010 hdoj7147 Walk","url":"/2022/07/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%801010%20hdoj7147%20Walk/","content":" 的分界线分别为,\r\n对于下一层的纵坐标\r\n，，， 称满足上述条件为合法情况，不满足上述条件为不合法情况。\r\n设恰好有层不合法的方案数为，设恰好有i层合法的方案数为。\r\n考虑容斥求，钦定最后层（即到层）不合法，前层合法。（容斥部分感谢ywx的讲解和点化）\r\n那么从钦定最后层不合法和前层合法开始，当前情况数为，此时只钦定了前层和最后层，第层和第层之间的关系并未确定，可能第层和第层仍然构成不合法情况，那么就要把这种情况减去，也就是减掉，同理仍然有第层和第层可能构成不合法情况，但被减去了，所以要加上，一步步下去，可得如下式子\r\n\r\n合并后可得\r\n\r\n所以对应的生成函数和对应的生成函数之间的关系为  接下来考虑如何求\r\n连续层不合法，那么会使得\r\n设，那么需要相隔至少个数之后才能选，那么可以每选择一个数使得减，即线性变换，因此考虑矩阵\r\n设为输入的个权值\r\n时不需要偏移，所以矩阵为\r\n\r\n时偏移为格\r\n\r\n时偏移为格\r\n\r\n以时的矩阵为例进行解释，之后能选的数是，那么i移动就只能从第三列移动到一列之后才能加，在移动两格的过程中，和就没有被选在之后，而选择之后又需要停两次才能选，若不选则仍然停留在立即能选的状态，所以该矩阵的转移就是\r\n\r\n写出来就是的矩阵\r\n最后带回原式做一个多项式求逆即可\r\nstruct matrix{    poly a[4][4];    static constexpr int n = 3;    friend matrix operator*(const matrix &amp;u, const matrix &amp;v)    {        matrix ans;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                for (int k = 1; k &lt;= n; k++)                    ans.a[i][j] = ans.a[i][j] + u.a[i][k] * v.a[k][j];        return ans;    }    poly *operator[](const int i)    {        return this-&gt;a[i];    }} s[N];matrix solve(int l, int r){    if (l == r)return s[l];    int m = (l + r) &gt;&gt; 1;    return solve(l, m) * solve(m + 1, r);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)    {        scanf(\"%d\", &amp;w);        if (i &lt; 16)            s[i][1][1] = poly{1, w};        else if (i &lt; 65536)            s[i][1][1] = s[i][2][1] = poly{1}, s[i][1][2] = poly{0, w};        else            s[i][1][1] = s[i][2][1] = s[i][3][2] = poly{1}, s[i][1][3] = poly{0, w};    }    matrix A = solve(1, m);    poly F = A[1][1] + A[1][2] + A[1][3];    for (int i = 1; i &lt; F.size(); i += 2)        F[i] = mod - F[i];    cout &lt;&lt; F.inv(n + 1)[n] &lt;&lt; endl;    return 0;}\r\n","tags":["Generating Functions","Matrix"]},{"title":"2022杭电多校六1003 hdoj7199 Find the Number of Paths","url":"/2022/08/05/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E5%85%AD1003%20hdoj7199%20Find%20the%20Number%20of%20Paths/","content":"\r\n设为已经走了步，当前在点的方案数，易知方程为\r\n\r\n式子不太方便，考虑令新标号等于原标号 则式子变为\r\n\r\n考虑生成函数形式，设为所对应的生成函数 则\r\n\r\n根据高中知识，构造 则\r\n\r\n就可以快速求出和\r\n时间复杂度，但常数巨大\r\n主函数核心代码就十行\r\nint main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;k);        poly A(n);        for (int i = 1; i &lt;= n - 1; i++)            scanf(\"%lld\", &amp;A[i]);        poly F = A.integ().exp(k + 1);        poly G0 = F &lt;&lt; (n - 1);        poly Gk(n);        for (int i = 0; i &lt; n; i++)            Gk[i] = G0[i + k] * fac[i + k] % mod * ifac[i] % mod;        poly H = Gk * F.inv(n);        for (int i = n - 1; i &gt;= 0; i--)            printf(\"%lld%c\", H[i], \" \\n\"[i == 0]);    }    return 0;}\r\n","tags":["Generating Functions","math"]},{"title":"2022杭电多校七1007 hdoj7217 Counting Good Arrays","url":"/2022/09/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%831007%20hdoj7217%20Counting%20Good%20Arrays/","content":"\r\n题意：对于一个数列，满足数列长度不超过，数列最大值不超过，且对于所有，满足的方案数\r\n设为数组长度为，最后一个数为的方案数，那么答案是\r\n\r\n首先固定观察性质，可以发现对于不同的质因子，在分配时并不相互影响，所以是一个关于的积性函数那么我们只要求\r\n对于，相当于对所有，把个因子可重复得分给个位置（最后一个位置固定为），即可重组合数，所以对于单个的方案数是\r\n\r\n一个简单的生成函数证明是考虑每个位置的因子个数，对于一个位置，方案数为任意个的方案数都是，那么一个位置的生成函数是，个的位置对应的生成函数就是，方案数就是\r\n\r\n那么对于所有的方案数就是 \r\n现在求出了，就可以通过筛求出关于的前缀和，这里预处理质数处的总和时，可以发现虽然不能像单项式那样子计算，但实际是质数个数乘上（一句只要求质数处的和，一语惊醒梦中人），剩余部分就是普通的操作\r\n求出了固定下的关于的前缀和，对再做一次前缀和就能得到答案所需的式子，此时太大了，但是！！！我们发现上面有一个式子\r\n\r\n在时就是一个关于的多项式，又因为是积性函数，所以也是一个多项式，并且项数是级别的，那么我们就可以通过拉格朗日插值计算得到最终的答案，复杂度\r\n比较怪的是这题，网络赛在长度n不需要求前缀和时，虽然那题并不需要插值（用插值就啦）\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;const ll mod = 1e9 + 7;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;namespace interpolate {    ll f[N], pre[N], suf[N];    ll lagrange(ll *f, int n, ll x)    {        if (x &lt;= n)return f[x];        ll ans = 0;        pre[0] = x % mod;        for (int i = 1; i &lt;= n; i++)            pre[i] = pre[i - 1] * (x - i + mod) % mod;        suf[n + 1] = 1;        for (int i = n; i; i--)            suf[i] = suf[i + 1] * (x - i + mod) % mod;        for (int i = 1; i &lt;= n; i++)        {            ll res = ifac[i] * ifac[n - i] % mod * pre[i - 1] % mod * suf[i + 1] % mod * f[i] % mod;            if ((n - i) &amp; 1)res = mod - res;            ans += res;            if (ans &gt;= mod)ans -= mod;        }        return ans;    }}using namespace interpolate;int vis[N];ll prime[N];int cnt;void Prime(int n){    cnt = 0;//多次时别忘了    for (int i = 2; i &lt;= n; i++)    {        if (!vis[i])prime[++cnt] = i;        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)        {            vis[i * prime[j]] = 1;            if (i % prime[j] == 0)break;        }    }}ll w[N], num_p[N], g[N];int id1[N], id2[N];int sz, t;ll limit;inline int getid(ll x){    if (x &lt;= sz)return id1[x];    else return id2[limit / x];}void init(ll n){    limit = n;    sz = sqrt(n) + 5;    Prime(sz);    t = 0;//多次时别忘了，也可以设置成局部变量    for (ll l = 1, r; l &lt;= n; l = r + 1)    {        r = n / (n / l);        w[++t] = n / l;        num_p[t] = w[t] - 1;        if (w[t] &lt;= sz)id1[w[t]] = t;        else id2[n / w[t]] = t;    }    for (int i = 1; i &lt;= cnt; i++)        for (int j = 1; j &lt;= t &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j++)        {            int id = getid(w[j] / prime[i]);            num_p[j] = (num_p[j] - (num_p[id] - (i - 1)) % mod + mod) % mod;//质数个数        }}ll S(ll n, int j, int r){    if (prime[j] &gt; n)return 0;    ll ans = (num_p[getid(n)] - j + mod) * r % mod;    for (int i = j + 1; i &lt;= cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++)        for (ll e = 1, sp = prime[i]; sp &lt;= n; sp *= prime[i], e++)            ans = (ans + C(e + r - 1, e) * (S(n / sp, i, r) + (e &gt; 1))) % mod;    return ans;}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        init(m);        for (int i = 1; i &lt;= 35; i++)            f[i] = (S(m, 0, i) + 1) % mod, f[i] = (f[i] + f[i - 1]) % mod;        printf(\"%lld\\n\", lagrange(f, 35, n));    }    return 0;}\r\n","tags":["Math","Combination","Min25"]},{"title":"2022牛客多校三 D Directed","url":"/2022/08/25/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E4%B8%89%20D%20Directed/","content":"\r\n结论：结点走到父亲的期望步数为\r\n证明：设为走到父亲期望步数，为结点的度数，有 \r\n若为叶子结点\r\n可以发现和成一次函数关系，待定系数后解得\r\n\r\n那么不考虑无向边变成有向边的影响，答案就是\r\n到的链\r\n接下来考虑无向边变为有向边且方向指向根结点的影响，设从起点到终点的这条链上的结点都被染色过，对于任意一个结点，\r\n若到父亲这条边变成有向边，当且仅当到目标结点的路径中除了和这条边被染色，其他边都不被染色才会产生的贡献。\r\n记结点的被染色祖先里距离最近的祖先为，\r\n考虑这种情况的概率，设和之间距离为，概率为，而的范围是到这条链上的结点，所以这部分贡献和是\r\n\r\n求解每个的贡献即可，时间复杂度\r\nconst int N = 2000005;int n, m, k;int a[N], vis[N], d[N], f[N], sz[N];vector&lt;int&gt; vec[N];const ll mod = 998244353;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;ll ans;void dfs1(int u, int fa){    f[u] = fa;    d[u] = d[fa] + 1;    sz[u] = 1;    for (auto v:vec[u])    {        if (v == fa)continue;        dfs1(v, u);        sz[u] += sz[v];    }}ll inv;void dfs2(int u, int ancient){    if (u != 1)        ans = (ans - (C(n - d[u] + d[ancient], k) - C(n - 1 - d[u] + d[2], k)) * inv % mod * 2 * sz[u] % mod + mod) % mod;    for (auto v:vec[u])    {        if (v == f[u])continue;        if (vis[u])            dfs2(v, u);        else dfs2(v, ancient);    }}int main(){    int p, q, u, v, w, x, y, z, T;    int s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    inv = fpow(C(n - 1, k), mod - 2);    for (int i = 1; i &lt; n; i++)        scanf(\"%d%d\", &amp;u, &amp;v), vec[u].emplace_back(v), vec[v].emplace_back(u);    dfs1(1, 0);    vis[1] = 1;    for (int u = s; u != 1; u = f[u])        vis[u] = 1, ans += 2 * sz[u] - 1;    ans %= mod;    dfs2(1, 0);    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Expectation"]},{"title":"AtCoder Regular Contest 115 E - LEQ and NEQ","url":"/2022/07/29/AtCoder%20Regular%20Contest%20115%20E%20-%20LEQ%20and%20NEQ/","content":"\r\n题意：给定个数，求个数满足下列条件的方案数：  数据范围： \r\n类似杭电多校1多项式题的容斥，但是此时由于的值是不固定的，所以只能写成形式，设为前i个序列的答案，枚举钦定最后个不合法，则有\r\n\r\n单调栈求出作为最小值的左边界，从转移到时只会影响一段后缀，用线段树维护即可，时间复杂度也可以用笛卡尔树做到\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 500005;int n, m, k;ll a[N];int stk[N], L[N];ll lazy[N &lt;&lt; 2];struct point{    ll sum, f;} c[N &lt;&lt; 2];const ll mod = 998244353;inline void pushup(int k){    c[k].sum = (c[k &lt;&lt; 1].sum + c[k &lt;&lt; 1 | 1].sum) % mod;    c[k].f = (c[k &lt;&lt; 1].f + c[k &lt;&lt; 1 | 1].f) % mod;}const ll inf = 1e9;inline void pushdown(int k){    if (lazy[k] != inf)    {        lazy[k &lt;&lt; 1] = lazy[k &lt;&lt; 1 | 1] = lazy[k];        c[k &lt;&lt; 1].sum = c[k &lt;&lt; 1].f * lazy[k] % mod;        c[k &lt;&lt; 1 | 1].sum = c[k &lt;&lt; 1 | 1].f * lazy[k] % mod;        lazy[k] = inf;    }}void update(int L, int R, int l, int r, int k, ll v){    if (L &lt;= l &amp;&amp; r &lt;= R)    {        c[k].sum = v * c[k].f % mod;        lazy[k] = v;        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (L &lt;= m)update(L, R, l, m, k &lt;&lt; 1, v);    if (R &gt; m)update(L, R, m + 1, r, k &lt;&lt; 1 | 1, v);    pushup(k);}void insert(int l, int r, int k, int x, ll v, ll f){    if (l == r)    {        c[k] = {v * f % mod, f};        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (x &lt;= m)insert(l, m, k &lt;&lt; 1, x, v, f);    else insert(m + 1, r, k &lt;&lt; 1 | 1, x, v, f);    pushup(k);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        scanf(\"%lld\", &amp;a[i]);    fill(lazy, lazy + n * 4, inf);    int top = 0;    for (int i = n; i; i--)    {        while (top &amp;&amp; a[stk[top]] &gt;= a[i])            L[stk[top--]] = i;        stk[++top] = i;    }    insert(0, n, 1, 0, 1, 1);    for (int i = 1; i &lt;= n; i++)    {        update(L[i], i - 1, 0, n, 1, mod - a[i] % mod);        if (i == n)cout &lt;&lt; (i &amp; 1 ? mod - 1 : 1) * c[1].sum % mod;        insert(0, n, 1, i, a[i], c[1].sum);    }    return 0;}\r\n","tags":["Inclusion-Exclusion Principle","DP","Data Structure"]},{"title":"2022牛客多校八 G Lexicographic Comparison","url":"/2022/09/04/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E5%85%AB%20G%20Lexicographic%20Comparison/","content":" 平衡树维护置换环\r\n的数据结构真的锻炼能力，平衡树能力++\r\nconst int N = 100005;int n, m, k;namespace Splay {    int c[N], son[N][2], f[N], sz[N], minid[N];#define ls son[x][0]#define rs son[x][1]    inline int cmp(int x, int y)    {        if (!x || !y)return x | y;        else return x &lt; y ? x : y;    }    inline void pushup(int x)    {        sz[x] = sz[ls] + sz[rs] + 1;        minid[x] = cmp(x, cmp(minid[ls], minid[rs]));    }    inline int get(int x) { return x == son[f[x]][1]; }    inline void connect(int x, int y, int d)    {        if (x)son[x][d] = y;        if (y)f[y] = x;    }    inline void rotate(int x)    {        int fa = f[x], ffa = f[fa], p = get(x), q = get(fa);        connect(fa, son[x][p ^ 1], p);        connect(x, fa, p ^ 1);        connect(ffa, x, q);        pushup(fa), pushup(x);    }    void splay(int x, int ed)    {        for (int fa; fa = f[x], fa != ed; rotate(x))            if (f[fa] != ed)rotate(get(fa) == get(x) ? fa : x);    }    inline int get_minid(int x)    {        splay(x, 0);        return minid[x];    }    int getlast(int x)    {        splay(x, 0);        while (son[x][1])            x = son[x][1];        splay(x, 0);        return x;    }    inline int kth(int x, int rk)    {        splay(x, 0);        while (1)        {            if (sz[ls] &gt;= rk)                x = ls;            else            {                rk -= sz[ls] + 1;                if (!rk)return x;                x = rs;            }        }    }    void movefront(int x)    {        splay(x, 0);        if (!ls)return;        int r = getlast(x);        int y = ls;        ls = 0;        pushup(x);        son[r][1] = y;        f[y] = r;        pushup(r);        splay(x, 0);    }#undef ls#undef rs}using namespace Splay;int p[N], circle_sz[N];set&lt;int&gt; S1[N], S2;int SZ;void print(int x){    if (son[x][0])print(son[x][0]);    printf(\"%d \", x);    if (son[x][1])print(son[x][1]);}inline void add(int x){    splay(x, 0);    circle_sz[minid[x]] = sz[x];    if (sz[x] &lt;= SZ)S1[sz[x]].insert(minid[x]);    else S2.insert(minid[x]);}inline void del(int x){    splay(x, 0);    if (sz[x] &lt;= SZ)S1[sz[x]].erase(minid[x]);    else S2.erase(minid[x]);}void merge(int x, int y){    if (get_minid(x) &gt; get_minid(y))swap(x, y);    del(x), del(y);    movefront(x), movefront(p[y]);    if (x != p[x])    {        splay(x, 0), splay(p[x], x);        son[p[x]][0] = p[y];        f[p[y]] = p[x];        pushup(p[x]);        splay(p[x], 0);    }    else    {        son[x][1] = p[y];        f[p[y]] = x;        pushup(x);        splay(x, 0);    }    add(x);}void divide(int x, int y){    del(x);    movefront(x);    if (sz[x] == 2)    {        splay(x, 0);        son[x][1] = 0;        f[y] = 0;        pushup(x);    }    else    {        if (x == p[y])swap(x, y);        assert(x != p[y]);        splay(x, 0), splay(p[y], x);        int z = son[p[y]][0];        son[p[y]][0] = 0;        f[z] = 0;        pushup(p[y]);        splay(p[y], 0);    }    add(x), add(y);}int main(){    int q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;q);        for (int i = 1; i &lt;= n; i++)            son[i][0] = son[i][1] = 0, S1[i].clear();        S2.clear();        fill(f, f + n + 1, 0);        fill(sz + 1, sz + n + 1, 1);        iota(minid + 1, minid + n + 1, 1);        iota(c + 1, c + n + 1, 1);        iota(p + 1, p + n + 1, 1);        SZ = sqrt(n);        char s[10];        while (q--)        {            ll x, y;            scanf(\"%s%lld%lld\", s, &amp;x, &amp;y);            if (s[0] == 's' &amp;&amp; s[5] == 'a')                swap(c[x], c[y]);            else if (s[0] == 's' &amp;&amp; s[5] == 'p')            {                if (x == y)continue;                if (get_minid(x) != get_minid(y))                    merge(x, y);                else                    divide(x, y);                swap(p[x], p[y]);            }            else            {                ll dif = abs(x - y);                int id = n + 1;                for (int i = 1; i &lt;= SZ; i++)                    if (!S1[i].empty() &amp;&amp; dif % i)                        id = min(id, *S1[i].begin());                for (auto x:S2)                    if (dif % circle_sz[x])                        id = min(id, x);                if (id == n + 1)puts(\"=\");                else                {                    x = (x - 1) % circle_sz[id] + 1;                    y = (y - 1) % circle_sz[id] + 1;                    movefront(id);                    x = kth(id, x);                    y = kth(id, y);                    if (c[x] &lt; c[y])puts(\"&lt;\");                    else puts(\"&gt;\");                }            }        }    }    return 0;}\r\n","tags":["Splay"]},{"title":"CF1716F Bags with Balls 生成函数递推初探","url":"/2022/08/05/CF1716F%20Bags%20with%20Balls%20%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%80%92%E6%8E%A8%E5%88%9D%E6%8E%A2/","content":"\r\n斯特林数展开可以更轻松得推出所求答案，这里用生成函数推导\r\n\r\nconst int N = 2005;int n, m, k;ll f[N][N];const ll mod = 998244353; ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;} int main(){    int p, q, u, v, w, x, y, z, T;    f[0][0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        for (int j = 1; j &lt;= i; j++)            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);        ll ans = 0, now = 1;        for (int i = 0; i &lt;= min(n, k); i++)        {            ans = (ans + now * f[k][i] % mod * fpow(m, n - i) % mod * fpow((m + 1) / 2, i)) % mod;            now = now * (n - i) % mod;        }        printf(\"%lld\\n\", ans);    }    return 0;}\r\n","tags":["Generating Functions","Stirling"]},{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"\r\n设权值为的答案为，对应OGF为，集合对应的OGF为\r\n考虑，枚举二叉树左右子树的方案数和根的值，可得\r\n\r\n均大于0,所以只有为空树的一种情况即，可得\r\n\r\n，代入和 ，可得 \r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"NOI2018 屠龙勇士","url":"/2022/07/03/NOI2018%20%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/","content":"\r\n题目所求即为对所有有\r\n\r\n考虑以下同余方程的合并 \r\n\r\n\r\n令\r\n则\r\n设\r\n则通解，，可通过求解\r\n，注意此处不需要乘上系数\r\n\r\n最初添加一个方程即可做到\r\n此时可求出满足同余方程的答案，对于条件扫一遍处理即可 #include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;ll t[N], sword[N];ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if (!b)    {        x = 1;        y = 0;        return a;    }    ll gcd = exgcd(b, a % b, x, y);    ll t = x;    x = y;    y = t - a / b * y;    return gcd;}ll excrt(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;b, vector&lt;ll&gt; &amp;p){    assert(a.size() == b.size() &amp;&amp; a.size() == p.size());    ll A = 0, P = 1;    for (int i = 0; i &lt; a.size(); i++)    {        ll x, y;        ll p1 = P, p2 = p[i];        ll a1 = A, a2 = a[i];        ll b1 = 1, b2 = b[i];        ll m1 = p1 * b2, m2 = p2 * b1;        ll d = exgcd(m1, m2, x, y);        if ((-a1 * b2 + a2 * b1) % d)return -1;        ll lcm = p[i] / d * P;        __int128 k1 = ((__int128) -a1 * b2 + a2 * b1) / d % lcm * x % lcm;        A = (a1 + k1 * p1) % lcm;        P = lcm;    }    A = (A % P + P) % P;    for (int i = 0; i &lt; a.size(); i++)    {        ll now = (a[i] + b[i] - 1) / b[i];        if (A &lt; now)            A += (now - A + P - 1) / P * P;    }    return A;}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        vector&lt;ll&gt; a(n), b(n), p(n);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;a[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;p[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;t[i]);        multiset&lt;ll&gt; st;        for (int i = 0; i &lt; m; i++)            scanf(\"%lld\", &amp;sword[i]), st.insert(sword[i]);        for (int i = 0; i &lt; n; i++)        {            auto p = st.upper_bound(a[i]);            if (p == st.begin())                b[i] = *p;            else b[i] = *--p;            st.erase(p);            st.insert(t[i]);        }        printf(\"%lld\\n\", excrt(a, b, p));    }    return 0;}\r\n","tags":["number theory"]},{"title":"P5293 [HNOI2019]白兔之舞","url":"/2022/07/05/P5293%20%5BHNOI2019%5D%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/","content":"\r\n设为白兔跳了次终点为的方案数 \r\n可以用矩阵优化，则跳次可以用矩阵表示为,为行向量，初始只有第列为1，为输入矩阵\r\n设，那么最终在第个点结束的答案为，即行向量的第列\r\n接下来求方案数 单位根反演\r\n令 可通过矩阵预处理得出，为次单位根，可通过求原根之后求出\r\n算法变换\r\n差卷积即可 ll get_r(){    vector&lt;int&gt; vec;    ll now = mod - 1;    for (int i = 2; i * i &lt;= now; i++)    {        if (now % i)continue;        vec.emplace_back(i);        while (now % i == 0)now /= i;    }    for (int g = 2;; g++)    {        bool flag = true;        for (auto p:vec)            if (fpow(g, (mod - 1) / p) == 1)            {                flag = false;                break;            }        if (flag)return g;    }}ll wk[N];int main(){    ll p, q, u, v, x, y, z, T;    ll L;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; mod;    matrix Z;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            scanf(\"%lld\", &amp;Z.a[i][j]);    ll r = get_r();    ll w = fpow(r, (mod - 1) / k);    wk[0] = 1;    for (int i = 1; i &lt; k; i++)        wk[i] = wk[i - 1] * w % mod;    poly h(k);    for (int i = 0; i &lt; k; i++)    {        matrix f;        f.a[1][x] = 1;        f = f * (Z * wk[i] + matrix::E()).fpow(L);        h[i] = f.a[1][y];    }    poly F(2 * k - 1), G(k);    for (int i = 0; i &lt; k; i++)        G[i] = h[i] * fpow(w, 1ll * i * (i - 1) / 2) % mod;    for (int i = 0; i &lt; 2 * k - 1; i++)        F[i] = fpow(fpow(w, mod - 2), 1ll * i * (i - 1) / 2);    F = F * G.rev();    const ll invk = fpow(k, mod - 2);    for (int i = 0; i &lt; k; i++)        printf(\"%lld\\n\", fpow(w, 1ll * i * (i - 1) / 2) * invk % mod * F[k - 1 + i] % mod);    return 0;}\r\n","tags":["Generating Functions","Bluestein"]},{"title":"P3746 组合数问题 循环卷积","url":"/2022/07/13/P3746%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%20%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/","content":"\r\n给定四个整数 ，求\r\n\r\n\r\n转化为循环卷积\r\nconst int N = 300005;int n, m, k;ll mod;using poly = vector&lt;ll&gt;;poly operator*(const poly &amp;a, const poly &amp;b){    poly c(k);    for (int i = 0; i &lt; a.size(); i++)        for (int j = 0; j &lt; b.size(); j++)            c[(i + j) % k] = (c[(i + j) % k] + a[i] * b[j]) % mod;    return c;}poly fpow(poly x, ll r){    poly ans{1};    while (r)    {        if (r &amp; 1)ans = ans * x;        r &gt;&gt;= 1;        x = x * x;    }    return ans;}int main(){    int p, q, u, v, w, x, y, z, T;    int r;    cin &gt;&gt; n &gt;&gt; mod &gt;&gt; k &gt;&gt; r;    poly F{1, 1};    cout &lt;&lt; fpow(F, 1ll * n * k)[r];    return 0;}\r\n","tags":["Generating Functions","FFT"]},{"title":"快速沃尔什变换/快速莫比乌斯变换","url":"/2022/04/10/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%20%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/","content":"\r\n笔者对快速沃尔什变换/快速莫比乌斯变换的理解也只是刚学阶段，本文只是写写自己的理解和一些其他博客略去的证明。(还没写完的部分可能会咕咕咕一段时间再写)\r\n前置知识：卷积\r\n对于多项式卷积，其思想是对于两个多项式，首先经过转换为点值表示得到，令，再对作一次转化为数组即为答案。\r\n那么类比多项式卷积，位运算卷积也可以类似定义，第项和第项的乘积贡献到第项，则，此处对应某种位运算，那么只需要构造一种转换满足就能实现时间复杂度的位运算卷积(论构造手为什么是神)，具体构造方法可以由数学推导得出+真值表+矩阵求逆得出，由于笔者处于初学阶段，暂不去推构造证明\r\n以下只讲与、或、异或三种位运算卷积且序列长度为的幂\r\n与\r\n\r\n\r\n构造  这样就可以在时间求出和的乘积，现在只需快速求出变换和\r\n设序列长度为，下标范围为，由于和位运算的特殊性，考虑对按位分治，设\r\n设是下标为的序列，是下标为的序列，如果已经求出了和，那么只要计算和相互的贡献就能求出\r\n对于，有，考虑二进制表示，则在二进制表示上比多一个最高位的，即，因此对于任意若满足，也一定满足，又和构成双射，那么对于，在上恰好对有一次贡献，在上不变，因此可以推出下式：\r\n在区间上为，在区间上为 那么的分治就完成了\r\n再对序列做就能得到答案序列经过变换后的序列\r\n对于，即为的反演，考虑矩阵\r\n 行变换后可得  (这部分矩阵证明反演笔者也不知道是否合理，凭感觉写的)\r\n那么可以推出下式： 在区间上为，在区间上为 就能得到最终的答案序列\r\nvoid mul(int n){    for (int i = 0; i &lt; n; i++)        a[i] = a[i] * b[i] % mod;}void AND(ll *f, ll x, int n){    for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1)        for (int i = 0; i &lt; n; i += o)            for (int j = 0; j &lt; k; j++)                f[i + j] = (f[i + j] + f[i + j + k] * x) % mod;}void FWT_AND(){    AND(a, 1, n), AND(b, 1, n), mul(n), AND(a, mod - 1, n)}\r\n剩下的部分咕咕咕\r\n","tags":["math","FWT","FMT"]},{"title":"洛谷P4389 付公主的背包","url":"/2022/04/03/%E6%B4%9B%E8%B0%B7P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","content":"\r\n设商品体积为的为， \r\n则所求答案为\r\n麦克劳林公式展开后可得 \r\n枚举倍数后可得系数，再求一次多项式即可得到答案，时间复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }        poly exp(int n)//需要保证f[0]=1        {            poly a{1};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * (poly{1} - a.ln(k) + modxk(k))).modxk(k);            }            return a.modxk(n);        }#undef T    };}using namespace polybase;int cnt[N];ll inv[N];int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        scanf(\"%d\", &amp;x), cnt[x]++;    for (int i = 1; i &lt;= m; i++)        inv[i] = fpow(i, mod - 2);    poly F(m + 1);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; i * j &lt;= m; j++)            F[i * j] = (F[i * j] + inv[j] * cnt[i]) % mod;    F = F.exp(m + 1);    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"\r\n设个点的简单有标号无向图的数目为,对应为\r\n个点的简单有标号无向连通图的数目为,对应为\r\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\r\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\r\n所以，答案即为\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"洛谷P4491 [HAOI2018]染色","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4491%20%5BHAOI2018%5D%E6%9F%93%E8%89%B2/","content":"\r\n设为钦定种颜色，每种颜色恰好出现了次的方案数，设为恰好种颜色，每种颜色恰好出现了次的方案数\r\n考虑钦定k种颜色能得到的方案数，可得\r\n\r\n阶乘预处理后即可时间内算出\r\n然后考虑和之间的关系，有 \r\n二项式反演后可得 \r\n差卷积后乘上对应值即可得出答案，总复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 10000005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    int s;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    poly W(m + 1);    for (int i = 0; i &lt;= m; i++)        scanf(\"%d\", &amp;W[i]);    poly F(m + 1);    for (int i = min(n / s, m); i &gt;= 0; i--)        F[i] = fac[m] * ifac[m - i] % mod * fac[n] % mod * fpow(ifac[s], i) % mod *               ifac[n - i * s] % mod * fpow(m - i, n - i * s) % mod;    poly H(m + 1);    for (int i = 0; i &lt;= m; i++)        H[m - i] = (i &amp; 1 ? mod - 1 : 1) * ifac[i] % mod;    poly G = F * H;    ll ans = 0;    for (int i = 0; i &lt;= m; i++)        ans = (ans + G[m + i] * ifac[i] % mod * W[i]) % mod;    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"转置原理和多项式多点求值","url":"/2022/06/09/%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86%E5%92%8C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/","content":"这篇博客背后是阅读十数篇博客和高强度悟道\r\n矩阵的初等变换和初等矩阵:\r\n三种矩阵初等变换\r\n\r\n交换矩阵两行(列)\r\n对一行(列)乘\r\n将第行乘加给第行\r\n\r\n对单位矩阵实施一次初等变换得到的矩阵称为初等矩阵。\r\n一种初等变换对应一个初等矩阵\r\n一个可逆矩阵可分为多个初等矩阵相乘\r\n转置原理：\r\n转置定理：如果，可得\r\n线性算法的转置：\r\n\r\n已知矩阵，输入向量，向量为左乘的运算结果，求解的算法为线性算法\r\n称与互为转置\r\n若矩阵可逆，可分为若干个初等矩阵相乘 此时若算法较难求出，可先求解的优化方法即 的优化方法，求出的优化方法后以相反的运算顺序即可求出的优化方法，具体原理可以参考其他博客，笔者高强度悟道才理解此处\r\n\r\n多项式乘法\r\n对于一个多项式次多项式和次多项式,令，可知将看作向量，看作矩阵\r\n以举例，考虑矩阵形式：\r\n 该线性算法转置为  即，可见加法卷积的转置为减法卷积，加法卷积的转置标记为\r\n多项式多点求值\r\n给定一个次多项式，现在请你对于，求出 。\r\n不妨都将长度扩充到，长度不够的地方补充0，以下令\r\n考虑该算法的矩阵形式  求点值的过程为线性变换，矩阵A为范德蒙德矩阵，可分为若干个初等矩阵扩充为n阶方阵后运算得到，并不影响推导(应该吧)。\r\n考虑该算法的转置，易知\r\n 该式可用分治快速求出 令分子为，分母为，则\r\n\r\n以上为转置算法的解\r\n接下来考虑原算法，可知与多项式无关，可视为列向量，对应转置算法为\r\n\r\n线段树预处理数组\r\n由转置原理的第三条和多项式乘法的转置可知自顶向下求解，顶部求出\r\n由转置算法中分子的运算过程可得原算法的逆过程： \r\n叶子节点即为答案\r\n\r\n该算法常数小且易于实现，难点在于高强度悟道\r\n这篇博客中有很多东西并没有讲清楚，许多细节以笔者的水平难以表达出来，同时笔者对线代的理解非常浅显，暂时先写成这样\r\n以下是笔者写的递归代码\r\nconst int N = 100005;int n, m, k;poly mulT(const poly &amp;a){    if (a.empty())return poly();    return (T * a.rev()) &gt;&gt; (a.size() - 1);}poly a, F;poly c[N &lt;&lt; 2], h[N &lt;&lt; 2];int len;void build(int l, int r, int k){    if (l == r)c[k] = poly{1, mod - a[l]};    else    {        int m = (l + r) &gt;&gt; 1;        build(l, m, k &lt;&lt; 1);        build(m + 1, r, k &lt;&lt; 1 | 1);        c[k] = c[k &lt;&lt; 1] * c[k &lt;&lt; 1 | 1];    }}void solve(int l, int r, int k){    if (l == r)return;    else    {        int m = (l + r) &gt;&gt; 1;        h[k &lt;&lt; 1] = h[k].mulT(c[k &lt;&lt; 1 | 1]).modxk(m - l + 1);        h[k &lt;&lt; 1 | 1] = h[k].mulT(c[k &lt;&lt; 1]).modxk(r - m);        solve(l, m, k &lt;&lt; 1);        solve(m + 1, r, k &lt;&lt; 1 | 1);    }}void print(int l, int r, int k){    if (l == r)    {        if (l &lt; m)            printf(\"%lld\\n\", h[k][0]);    }    else    {        int m = (l + r) &gt;&gt; 1;        print(l, m, k &lt;&lt; 1);        print(m + 1, r, k &lt;&lt; 1 | 1);    }}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    F.resize(n + 1);    for (int i = 0; i &lt;= n; i++)        scanf(\"%lld\", &amp;F[i]);    a.resize(m);    for (int i = 0; i &lt; m; i++)        scanf(\"%d\", &amp;a[i]);    len = max(n + 1, m);    F.resize(len), a.resize(len);    build(0, len - 1, 1);    h[1] = F.mulT(c[1].inv(len));    solve(0, len - 1, 1);    print(0, len - 1, 1);    return 0;}\r\n","tags":["Generating Functions","Matrix","Poly"]}]