[{"title":"2020牛客暑期多校训练营（第五场）C-Easy","url":"/2022/06/16/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89C-Easy/","content":"\r\n2020牛客暑期多校训练营（第五场）C-Easy\r\n设所对应的二元生成函数为，则答案为\r\n由基本生成函数知识可知\r\n\r\n考虑 \r\n则\r\n因此\r\n时间复杂度\r\n","tags":["Generating Functions","Combinatorics"]},{"title":"2015-2016 Petrozavodsk Winter Training Camp, Moscow SU Trinity Contest Problem H. Hans Zimmer","url":"/2022/11/01/2015-2016%20Petrozavodsk%20Winter%20Training%20Camp,%20Moscow%20SU%20Trinity%20Contest%20Problem%20H.%20Hans%20Zimmer/","content":"\r\n引理1： 长为的线段随机切刀分成条线段，最短线段长度期望为，第短线段长度为\r\n\r\n考虑一个直观等价的事实，随机切刀等价于个随机变量满足，最短段为(具体证明不会。。)\r\n另一个比较直观的引理2(证明不会，概率论太差了呜呜呜)：\r\n\r\n再一个比较直观的引理3：\r\n\r\n证明(终于有我会的了)：\r\n分部积分法\r\n那么最短线段的期望长度:\r\n引理\r\n最长线段的期望长度(容斥做法)：\r\n\r\n第短线段的递推做法(容斥做法不会呜呜呜)：\r\n考虑第2短的线段期望长度，相当于给都减去，答案就是此时的最短线段期望长度+原先最短线段期望长度。\r\n\r\n由此可以数学归纳法求出 \r\n回到原题，此时可以枚举确定横纵切的刀数 答案为：\r\n\r\n精度上用函数解决即可\r\n","tags":["Math","Integral","Expectation"]},{"title":"2022-2023赛季VP记录","url":"/2022/10/15/2022-2023%E8%B5%9B%E5%AD%A3VP%E8%AE%B0%E5%BD%95/","content":"\r\n19哈尔滨：8题933罚时，正式榜rk7，去除打星rk4，cf上截至vp结束rk35，C题机时不足赛后20分钟通过，正式大量VP的开端。\r\n\r\n19徐州：7题1349罚时，正式榜rk15，去除打星rk13，vjudge上截至vp结束rk20，未过银牌题M，本场因掉网和首次使用vjudge\r\nvp导致体验糟糕，机时上也很混乱，对队友的pollard_rho板子不熟悉导致浪费了很多时间，总体罚时爆炸。\r\n19拉美：8题991罚时，cf上截至vp结束rk120，还剩半个多小时的时候觉得没什么想法就先解散吃饭了，F题中期两个多小时没开出来我背大锅，被杜老师(DDOSvoid)n+2爆杀。\r\n19秦皇岛：6题996罚时，正式榜rk18，去除打星rk15，cf上截至vp结束rk81，有不少失误，加上博弈苦手的原因一度大脑宕机，导致罚时过高。\r\n20秦皇岛：5题319罚时，gym上无银牌假题C，正式榜rk73，去除打星rk61，cf上截至vp结束rk76，出金牌题实力不够，hash姿势不足。\r\n19SEERC：4题520罚时，cf上截至vp结束rk292，寄穿。 2015-2016 Petrozavodsk Winter Training Camp, Moscow\r\nSU Trinity\r\nContest：6题653罚时，cf上截至vp结束rk67，C题背景描述与输入描述不符合，D题实际应算没过，G题又是构造苦手，过题人数非常多的构造未出。\r\n2019 Petrozavodsk Winter Camp, Yandex Cup:\r\n3题426罚时，cf上截至vp结束rk86，跟娱乐一样乱打+被贪心题卡死\r\n22桂林：6题862罚时，cf上截至vp结束rk86，正式榜rk56，去除打星rk47，G题队友没睡够状态不好，D题自己推到最后一步时候把一个会的结论应该是一元GF形式推错写成了二元，寄寄寄，场上推式子天天犯病。\r\n20银川：6题916罚时，cf上截至vp结束rk29，正式榜rk28，去除打星rk27，CD浪费过多时间想和写错误做法，C想了两小时优化打表，最后一小时反应过来是多项式，D写了个200行LCT最后发现反例否定了这种做法，非常逆风。\r\n22威海：7题704罚时，cf上截至vp结束rk48，正式榜rk35，去除打星rk34，2小时44分钟签完7题，然后K题没有想太深就开始写一个极其麻烦的做法，到最后都没有调出来，赛后发现这种做法漏了一种情况+方案数算错了，应该想得再深入一些再动键盘。 2022-2023 ICPC NERC (NEERC), North-Western Russia\r\nRegional Contest (Northern\r\nSubregionals)：6题410罚时，cf上截至vp结束rk57，赛后一分钟内过了F，又被杜老师n+2爆杀了。\r\n22广州：5题559罚时，cf上截至vp结束rk59，正式榜rk37，去除打星rk29。\r\n21EC：6题624罚时，cf上截至vp结束rk18，正式榜rk22，去除打星rk21。\r\n22绵阳：4题215罚时，cf上截至vp结束rk154，正式榜rk105，去除打星rk99。 COMPFEST 13 - Finals Online Mirror (Unrated, ICPC\r\nRules, Teams Preferred)：9题972罚时，cf上截至vp结束rk49。\r\nCOMPFEST 14 - Preliminary Online Mirror (Unrated, ICPC Rules, Teams\r\nPreferred)：7题485罚时，cf上截至vp结束rk133，正式大量vp的结尾。\r\n"},{"title":"2022多校多项式做题记录","url":"/2022/07/26/2022%E5%A4%9A%E6%A0%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\r\n牛客多校1：H题\r\nFly，基础不牢没学过完全背包转二进制01背包，中档题，挺可惜。\r\n杭电多校1：1010\r\nwalk，容斥+矩阵维护多项式，压轴难度，完全没思路，补题见Blog。\r\n牛客多校2：E题 Falfa with\r\nSubstring，经典二项式反演，例题难度，场切。\r\n杭电多校2：无多项式。\r\n牛客多校3：I题Ice Drinking，压轴难度，数的touchard同余性质以及快速求5000个级别的第二类数，不会求这5000个斯特林数，比较可惜的是只差这一步，而这一步在翻混凝土数学的时候没去翻二阶欧拉数，二阶欧拉数能与转换，差临门一脚，可惜。\r\nPS：东京大学队伍有个神秘科技可以求单次的斯特林数，令人震惊\r\n\r\n杭电多校3：1001 Equipment\r\nUpgrade，cdq分治fft优化期望dp，场切，中档题难度，但是过题人数和牛客多校2的E题差不多，人均会多项式？\r\n牛客多校4：C Easy Counting Problem，中档题，场切，但是选择了枚举而不是背包导致需要卡常\r\n杭电多校4：无多项式。\r\n牛客多校5：著名锅场，无多项式。\r\n杭电多校5：1007 Count\r\nSet，普通分治fft，签到题难度，场切，270个队会多项式就很离谱。\r\n杭电多校6：1003 Find the Number of\r\nPaths，金牌题难度，会，但是没开，一整场卡了四道签到导致时间上寄了，所以另一道置换群模板题也没时间开。\r\n","tags":["record"]},{"title":"2022杭电多校一1010 hdoj7147 Walk","url":"/2022/07/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%801010%20hdoj7147%20Walk/","content":" 的分界线分别为,\r\n对于下一层的纵坐标\r\n，，， 称满足上述条件为合法情况，不满足上述条件为不合法情况。\r\n设恰好有层不合法的方案数为，设恰好有i层合法的方案数为。\r\n考虑容斥求，钦定最后层（即到层）不合法，前层合法。（容斥部分感谢ywx的讲解和点化）\r\n那么从钦定最后层不合法和前层合法开始，当前情况数为，此时只钦定了前层和最后层，第层和第层之间的关系并未确定，可能第层和第层仍然构成不合法情况，那么就要把这种情况减去，也就是减掉，同理仍然有第层和第层可能构成不合法情况，但被减去了，所以要加上，一步步下去，可得如下式子\r\n\r\n合并后可得\r\n\r\n所以对应的生成函数和对应的生成函数之间的关系为  接下来考虑如何求\r\n连续层不合法，那么会使得\r\n设，那么需要相隔至少个数之后才能选，那么可以每选择一个数使得减，即线性变换，因此考虑矩阵\r\n设为输入的个权值\r\n时不需要偏移，所以矩阵为\r\n\r\n时偏移为格\r\n\r\n时偏移为格\r\n\r\n以时的矩阵为例进行解释，之后能选的数是，那么i移动就只能从第三列移动到一列之后才能加，在移动两格的过程中，和就没有被选在之后，而选择之后又需要停两次才能选，若不选则仍然停留在立即能选的状态，所以该矩阵的转移就是\r\n\r\n写出来就是的矩阵\r\n最后带回原式做一个多项式求逆即可\r\nstruct matrix{    poly a[4][4];    static constexpr int n = 3;    friend matrix operator*(const matrix &amp;u, const matrix &amp;v)    {        matrix ans;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                for (int k = 1; k &lt;= n; k++)                    ans.a[i][j] = ans.a[i][j] + u.a[i][k] * v.a[k][j];        return ans;    }    poly *operator[](const int i)    {        return this-&gt;a[i];    }} s[N];matrix solve(int l, int r){    if (l == r)return s[l];    int m = (l + r) &gt;&gt; 1;    return solve(l, m) * solve(m + 1, r);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)    {        scanf(\"%d\", &amp;w);        if (i &lt; 16)            s[i][1][1] = poly{1, w};        else if (i &lt; 65536)            s[i][1][1] = s[i][2][1] = poly{1}, s[i][1][2] = poly{0, w};        else            s[i][1][1] = s[i][2][1] = s[i][3][2] = poly{1}, s[i][1][3] = poly{0, w};    }    matrix A = solve(1, m);    poly F = A[1][1] + A[1][2] + A[1][3];    for (int i = 1; i &lt; F.size(); i += 2)        F[i] = mod - F[i];    cout &lt;&lt; F.inv(n + 1)[n] &lt;&lt; endl;    return 0;}\r\n","tags":["Generating Functions","Matrix"]},{"title":"2022牛客多校八 G Lexicographic Comparison","url":"/2022/09/04/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E5%85%AB%20G%20Lexicographic%20Comparison/","content":" 平衡树维护置换环\r\n的数据结构真的锻炼能力，平衡树能力++\r\nconst int N = 100005;int n, m, k;namespace Splay {    int c[N], son[N][2], f[N], sz[N], minid[N];#define ls son[x][0]#define rs son[x][1]    inline int cmp(int x, int y)    {        if (!x || !y)return x | y;        else return x &lt; y ? x : y;    }    inline void pushup(int x)    {        sz[x] = sz[ls] + sz[rs] + 1;        minid[x] = cmp(x, cmp(minid[ls], minid[rs]));    }    inline int get(int x) { return x == son[f[x]][1]; }    inline void connect(int x, int y, int d)    {        if (x)son[x][d] = y;        if (y)f[y] = x;    }    inline void rotate(int x)    {        int fa = f[x], ffa = f[fa], p = get(x), q = get(fa);        connect(fa, son[x][p ^ 1], p);        connect(x, fa, p ^ 1);        connect(ffa, x, q);        pushup(fa), pushup(x);    }    void splay(int x, int ed)    {        for (int fa; fa = f[x], fa != ed; rotate(x))            if (f[fa] != ed)rotate(get(fa) == get(x) ? fa : x);    }    inline int get_minid(int x)    {        splay(x, 0);        return minid[x];    }    int getlast(int x)    {        splay(x, 0);        while (son[x][1])            x = son[x][1];        splay(x, 0);        return x;    }    inline int kth(int x, int rk)    {        splay(x, 0);        while (1)        {            if (sz[ls] &gt;= rk)                x = ls;            else            {                rk -= sz[ls] + 1;                if (!rk)return x;                x = rs;            }        }    }    void movefront(int x)    {        splay(x, 0);        if (!ls)return;        int r = getlast(x);        int y = ls;        ls = 0;        pushup(x);        son[r][1] = y;        f[y] = r;        pushup(r);        splay(x, 0);    }#undef ls#undef rs}using namespace Splay;int p[N], circle_sz[N];set&lt;int&gt; S1[N], S2;int SZ;void print(int x){    if (son[x][0])print(son[x][0]);    printf(\"%d \", x);    if (son[x][1])print(son[x][1]);}inline void add(int x){    splay(x, 0);    circle_sz[minid[x]] = sz[x];    if (sz[x] &lt;= SZ)S1[sz[x]].insert(minid[x]);    else S2.insert(minid[x]);}inline void del(int x){    splay(x, 0);    if (sz[x] &lt;= SZ)S1[sz[x]].erase(minid[x]);    else S2.erase(minid[x]);}void merge(int x, int y){    if (get_minid(x) &gt; get_minid(y))swap(x, y);    del(x), del(y);    movefront(x), movefront(p[y]);    if (x != p[x])    {        splay(x, 0), splay(p[x], x);        son[p[x]][0] = p[y];        f[p[y]] = p[x];        pushup(p[x]);        splay(p[x], 0);    }    else    {        son[x][1] = p[y];        f[p[y]] = x;        pushup(x);        splay(x, 0);    }    add(x);}void divide(int x, int y){    del(x);    movefront(x);    if (sz[x] == 2)    {        splay(x, 0);        son[x][1] = 0;        f[y] = 0;        pushup(x);    }    else    {        if (x == p[y])swap(x, y);        assert(x != p[y]);        splay(x, 0), splay(p[y], x);        int z = son[p[y]][0];        son[p[y]][0] = 0;        f[z] = 0;        pushup(p[y]);        splay(p[y], 0);    }    add(x), add(y);}int main(){    int q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;q);        for (int i = 1; i &lt;= n; i++)            son[i][0] = son[i][1] = 0, S1[i].clear();        S2.clear();        fill(f, f + n + 1, 0);        fill(sz + 1, sz + n + 1, 1);        iota(minid + 1, minid + n + 1, 1);        iota(c + 1, c + n + 1, 1);        iota(p + 1, p + n + 1, 1);        SZ = sqrt(n);        char s[10];        while (q--)        {            ll x, y;            scanf(\"%s%lld%lld\", s, &amp;x, &amp;y);            if (s[0] == 's' &amp;&amp; s[5] == 'a')                swap(c[x], c[y]);            else if (s[0] == 's' &amp;&amp; s[5] == 'p')            {                if (x == y)continue;                if (get_minid(x) != get_minid(y))                    merge(x, y);                else                    divide(x, y);                swap(p[x], p[y]);            }            else            {                ll dif = abs(x - y);                int id = n + 1;                for (int i = 1; i &lt;= SZ; i++)                    if (!S1[i].empty() &amp;&amp; dif % i)                        id = min(id, *S1[i].begin());                for (auto x:S2)                    if (dif % circle_sz[x])                        id = min(id, x);                if (id == n + 1)puts(\"=\");                else                {                    x = (x - 1) % circle_sz[id] + 1;                    y = (y - 1) % circle_sz[id] + 1;                    movefront(id);                    x = kth(id, x);                    y = kth(id, y);                    if (c[x] &lt; c[y])puts(\"&lt;\");                    else puts(\"&gt;\");                }            }        }    }    return 0;}\r\n","tags":["Splay"]},{"title":"2022牛客多校三 D Directed","url":"/2022/08/25/2022%E7%89%9B%E5%AE%A2%E5%A4%9A%E6%A0%A1%E4%B8%89%20D%20Directed/","content":"\r\n结论：结点走到父亲的期望步数为\r\n证明：设为走到父亲期望步数，为结点的度数，有 \r\n若为叶子结点\r\n可以发现和成一次函数关系，待定系数后解得\r\n\r\n那么不考虑无向边变成有向边的影响，答案就是\r\n到的链\r\n接下来考虑无向边变为有向边且方向指向根结点的影响，设从起点到终点的这条链上的结点都被染色过，对于任意一个结点，\r\n若到父亲这条边变成有向边，当且仅当到目标结点的路径中除了和这条边被染色，其他边都不被染色才会产生的贡献。\r\n记结点的被染色祖先里距离最近的祖先为，\r\n考虑这种情况的概率，设和之间距离为，概率为，而的范围是到这条链上的结点，所以这部分贡献和是\r\n\r\n求解每个的贡献即可，时间复杂度\r\nconst int N = 2000005;int n, m, k;int a[N], vis[N], d[N], f[N], sz[N];vector&lt;int&gt; vec[N];const ll mod = 998244353;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;ll ans;void dfs1(int u, int fa){    f[u] = fa;    d[u] = d[fa] + 1;    sz[u] = 1;    for (auto v:vec[u])    {        if (v == fa)continue;        dfs1(v, u);        sz[u] += sz[v];    }}ll inv;void dfs2(int u, int ancient){    if (u != 1)        ans = (ans - (C(n - d[u] + d[ancient], k) - C(n - 1 - d[u] + d[2], k)) * inv % mod * 2 * sz[u] % mod + mod) % mod;    for (auto v:vec[u])    {        if (v == f[u])continue;        if (vis[u])            dfs2(v, u);        else dfs2(v, ancient);    }}int main(){    int p, q, u, v, w, x, y, z, T;    int s;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; s;    inv = fpow(C(n - 1, k), mod - 2);    for (int i = 1; i &lt; n; i++)        scanf(\"%d%d\", &amp;u, &amp;v), vec[u].emplace_back(v), vec[v].emplace_back(u);    dfs1(1, 0);    vis[1] = 1;    for (int u = s; u != 1; u = f[u])        vis[u] = 1, ans += 2 * sz[u] - 1;    ans %= mod;    dfs2(1, 0);    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Expectation"]},{"title":"2022杭电多校七1007 hdoj7217 Counting Good Arrays","url":"/2022/09/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%831007%20hdoj7217%20Counting%20Good%20Arrays/","content":"\r\n题意：对于一个数列，满足数列长度不超过，数列最大值不超过，且对于所有，满足的方案数\r\n设为数组长度为，最后一个数为的方案数，那么答案是\r\n\r\n首先固定观察性质，可以发现对于不同的质因子，在分配时并不相互影响，所以是一个关于的积性函数那么我们只要求\r\n对于，相当于对所有，把个因子可重复得分给个位置（最后一个位置固定为），即可重组合数，所以对于单个的方案数是\r\n\r\n一个简单的生成函数证明是考虑每个位置的因子个数，对于一个位置，方案数为任意个的方案数都是，那么一个位置的生成函数是，个的位置对应的生成函数就是，方案数就是\r\n\r\n那么对于所有的方案数就是 \r\n现在求出了，就可以通过筛求出关于的前缀和，这里预处理质数处的总和时，可以发现虽然不能像单项式那样子计算，但实际是质数个数乘上（一句只要求质数处的和，一语惊醒梦中人），剩余部分就是普通的操作\r\n求出了固定下的关于的前缀和，对再做一次前缀和就能得到答案所需的式子，此时太大了，但是！！！我们发现上面有一个式子\r\n\r\n在时就是一个关于的多项式，又因为是积性函数，所以也是一个多项式，并且项数是级别的，那么我们就可以通过拉格朗日插值计算得到最终的答案，复杂度\r\n比较怪的是这题，网络赛在长度n不需要求前缀和时，虽然那题并不需要插值（用插值就啦）\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;const ll mod = 1e9 + 7;ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;}namespace binom {    ll fac[N], ifac[N];    int __ = []    {        fac[0] = 1;        for (int i = 1; i &lt;= N - 5; i++)            fac[i] = fac[i - 1] * i % mod;        ifac[N - 5] = fpow(fac[N - 5], mod - 2);        for (int i = N - 5; i; i--)            ifac[i - 1] = ifac[i] * i % mod;        return 0;    }();    inline ll C(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[m] % mod * ifac[n - m] % mod;    }    inline ll A(int n, int m)    {        if (n &lt; m || m &lt; 0)return 0;        return fac[n] * ifac[n - m] % mod;    }}using namespace binom;namespace interpolate {    ll f[N], pre[N], suf[N];    ll lagrange(ll *f, int n, ll x)    {        if (x &lt;= n)return f[x];        ll ans = 0;        pre[0] = x % mod;        for (int i = 1; i &lt;= n; i++)            pre[i] = pre[i - 1] * (x - i + mod) % mod;        suf[n + 1] = 1;        for (int i = n; i; i--)            suf[i] = suf[i + 1] * (x - i + mod) % mod;        for (int i = 1; i &lt;= n; i++)        {            ll res = ifac[i] * ifac[n - i] % mod * pre[i - 1] % mod * suf[i + 1] % mod * f[i] % mod;            if ((n - i) &amp; 1)res = mod - res;            ans += res;            if (ans &gt;= mod)ans -= mod;        }        return ans;    }}using namespace interpolate;int vis[N];ll prime[N];int cnt;void Prime(int n){    cnt = 0;//多次时别忘了    for (int i = 2; i &lt;= n; i++)    {        if (!vis[i])prime[++cnt] = i;        for (int j = 1; j &lt;= cnt &amp;&amp; i * prime[j] &lt;= n; j++)        {            vis[i * prime[j]] = 1;            if (i % prime[j] == 0)break;        }    }}ll w[N], num_p[N], g[N];int id1[N], id2[N];int sz, t;ll limit;inline int getid(ll x){    if (x &lt;= sz)return id1[x];    else return id2[limit / x];}void init(ll n){    limit = n;    sz = sqrt(n) + 5;    Prime(sz);    t = 0;//多次时别忘了，也可以设置成局部变量    for (ll l = 1, r; l &lt;= n; l = r + 1)    {        r = n / (n / l);        w[++t] = n / l;        num_p[t] = w[t] - 1;        if (w[t] &lt;= sz)id1[w[t]] = t;        else id2[n / w[t]] = t;    }    for (int i = 1; i &lt;= cnt; i++)        for (int j = 1; j &lt;= t &amp;&amp; prime[i] * prime[i] &lt;= w[j]; j++)        {            int id = getid(w[j] / prime[i]);            num_p[j] = (num_p[j] - (num_p[id] - (i - 1)) % mod + mod) % mod;//质数个数        }}ll S(ll n, int j, int r){    if (prime[j] &gt; n)return 0;    ll ans = (num_p[getid(n)] - j + mod) * r % mod;    for (int i = j + 1; i &lt;= cnt &amp;&amp; prime[i] * prime[i] &lt;= n; i++)        for (ll e = 1, sp = prime[i]; sp &lt;= n; sp *= prime[i], e++)            ans = (ans + C(e + r - 1, e) * (S(n / sp, i, r) + (e &gt; 1))) % mod;    return ans;}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        init(m);        for (int i = 1; i &lt;= 35; i++)            f[i] = (S(m, 0, i) + 1) % mod, f[i] = (f[i] + f[i - 1]) % mod;        printf(\"%lld\\n\", lagrange(f, 35, n));    }    return 0;}\r\n","tags":["Math","Combination","Min25"]},{"title":"2022杭电多校六1003 hdoj7199 Find the Number of Paths","url":"/2022/08/05/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E5%85%AD1003%20hdoj7199%20Find%20the%20Number%20of%20Paths/","content":"\r\n设为已经走了步，当前在点的方案数，易知方程为\r\n\r\n式子不太方便，考虑令新标号等于原标号 则式子变为\r\n\r\n考虑生成函数形式，设为所对应的生成函数 则\r\n\r\n根据高中知识，构造 则\r\n\r\n就可以快速求出和\r\n时间复杂度，但常数巨大\r\n主函数核心代码就十行\r\nint main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;k);        poly A(n);        for (int i = 1; i &lt;= n - 1; i++)            scanf(\"%lld\", &amp;A[i]);        poly F = A.integ().exp(k + 1);        poly G0 = F &lt;&lt; (n - 1);        poly Gk(n);        for (int i = 0; i &lt; n; i++)            Gk[i] = G0[i + k] * fac[i + k] % mod * ifac[i] % mod;        poly H = Gk * F.inv(n);        for (int i = n - 1; i &gt;= 0; i--)            printf(\"%lld%c\", H[i], \" \\n\"[i == 0]);    }    return 0;}\r\n","tags":["Generating Functions","Math"]},{"title":"AtCoder Regular Contest 115 E - LEQ and NEQ","url":"/2022/07/29/AtCoder%20Regular%20Contest%20115%20E%20-%20LEQ%20and%20NEQ/","content":"\r\n题意：给定个数，求个数满足下列条件的方案数：  数据范围： \r\n类似杭电多校1多项式题的容斥，但是此时由于的值是不固定的，所以只能写成形式，设为前i个序列的答案，枚举钦定最后个不合法，则有\r\n\r\n单调栈求出作为最小值的左边界，从转移到时只会影响一段后缀，用线段树维护即可，时间复杂度也可以用笛卡尔树做到\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 500005;int n, m, k;ll a[N];int stk[N], L[N];ll lazy[N &lt;&lt; 2];struct point{    ll sum, f;} c[N &lt;&lt; 2];const ll mod = 998244353;inline void pushup(int k){    c[k].sum = (c[k &lt;&lt; 1].sum + c[k &lt;&lt; 1 | 1].sum) % mod;    c[k].f = (c[k &lt;&lt; 1].f + c[k &lt;&lt; 1 | 1].f) % mod;}const ll inf = 1e9;inline void pushdown(int k){    if (lazy[k] != inf)    {        lazy[k &lt;&lt; 1] = lazy[k &lt;&lt; 1 | 1] = lazy[k];        c[k &lt;&lt; 1].sum = c[k &lt;&lt; 1].f * lazy[k] % mod;        c[k &lt;&lt; 1 | 1].sum = c[k &lt;&lt; 1 | 1].f * lazy[k] % mod;        lazy[k] = inf;    }}void update(int L, int R, int l, int r, int k, ll v){    if (L &lt;= l &amp;&amp; r &lt;= R)    {        c[k].sum = v * c[k].f % mod;        lazy[k] = v;        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (L &lt;= m)update(L, R, l, m, k &lt;&lt; 1, v);    if (R &gt; m)update(L, R, m + 1, r, k &lt;&lt; 1 | 1, v);    pushup(k);}void insert(int l, int r, int k, int x, ll v, ll f){    if (l == r)    {        c[k] = {v * f % mod, f};        return;    }    int m = (l + r) &gt;&gt; 1;    pushdown(k);    if (x &lt;= m)insert(l, m, k &lt;&lt; 1, x, v, f);    else insert(m + 1, r, k &lt;&lt; 1 | 1, x, v, f);    pushup(k);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n;    for (int i = 1; i &lt;= n; i++)        scanf(\"%lld\", &amp;a[i]);    fill(lazy, lazy + n * 4, inf);    int top = 0;    for (int i = n; i; i--)    {        while (top &amp;&amp; a[stk[top]] &gt;= a[i])            L[stk[top--]] = i;        stk[++top] = i;    }    insert(0, n, 1, 0, 1, 1);    for (int i = 1; i &lt;= n; i++)    {        update(L[i], i - 1, 0, n, 1, mod - a[i] % mod);        if (i == n)cout &lt;&lt; (i &amp; 1 ? mod - 1 : 1) * c[1].sum % mod;        insert(0, n, 1, i, a[i], c[1].sum);    }    return 0;}\r\n","tags":["Inclusion-Exclusion Principle","DP","Data Structure"]},{"title":"CF1716F Bags with Balls 生成函数递推初探","url":"/2022/08/05/CF1716F%20Bags%20with%20Balls%20%E7%94%9F%E6%88%90%E5%87%BD%E6%95%B0%E9%80%92%E6%8E%A8%E5%88%9D%E6%8E%A2/","content":"\r\n斯特林数展开可以更轻松得推出所求答案，这里用生成函数推导\r\n\r\nconst int N = 2005;int n, m, k;ll f[N][N];const ll mod = 998244353; ll fpow(ll x, ll r){    ll result = 1;    while (r)    {        if (r &amp; 1)result = result * x % mod;        r &gt;&gt;= 1;        x = x * x % mod;    }    return result;} int main(){    int p, q, u, v, w, x, y, z, T;    f[0][0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        for (int j = 1; j &lt;= i; j++)            f[i][j] = (f[i - 1][j - 1] + f[i - 1][j] * j) % mod;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k);        ll ans = 0, now = 1;        for (int i = 0; i &lt;= min(n, k); i++)        {            ans = (ans + now * f[k][i] % mod * fpow(m, n - i) % mod * fpow((m + 1) / 2, i)) % mod;            now = now * (n - i) % mod;        }        printf(\"%lld\\n\", ans);    }    return 0;}\r\n","tags":["Generating Functions","Stirling"]},{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"\r\n设权值为的答案为，对应OGF为，集合对应的OGF为\r\n考虑，枚举二叉树左右子树的方案数和根的值，可得\r\n\r\n均大于0,所以只有为空树的一种情况即，可得\r\n\r\n，代入和 ，可得 \r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"ACM之旅","url":"/2022/12/16/ACM%E4%B9%8B%E6%97%85/","content":"\r\n临时赶工的质量，随便看看吧\r\n2020.12.16-2022.12.16\r\n一转眼，我也到了退役的日子，今年的日子相比去年总是过得飞快，些许是更忙碌的原因，两年的ACM之旅为我带来了什么？扎实的码力，志同道合的伙伴，抑或是不健康的作息。一年前自己和队友在集训室看着学长们退役的情景仍然历历在目，想不到这么快就到了我们身上，甚至也复刻了去年7队的遗憾。\r\n2020年12月16日，我在最后一轮选拔赛中因老刘的网开一面成功进入到集训队，此后便是扎身于训练当中，起初一直只刷cf，直到5月在debug杯上被坐在旁边的阿敏n+3之后开始转向洛谷学习算法，此后确实实力大涨，在校赛中成功存活下来(反转了，阿敏不幸地短暂离开了集训队)。\r\n多校前和lmsh,soxsx组成了LSP steaming\r\nbuns(蒸馒头/杭电12队)，一个oier(lmsh)和两个零基础，20场多校之后排名全校rk11，之后由于线上赛的原因获得了上海站的参赛资格，此后开始了一周三场的vp，这支队伍从一开始磨合度就非常良好，也经常能够封榜后出题翻盘，再加上三个人码风非常相似，所以经常能在赛中打出combo，会出现两个人甚至三个人合写一份代码的情况，也会出现一个人写一半写不下去了另一个人能接着写的情况，所以越vp越强，vp到赛前一周的状态，那时候是LSP\r\nsteaming buns 2021年最巅峰的时期，三个人都爆发出了cf\r\nrating(当时队里三个1600，max rating\r\n1800+1800+1900)完全不匹配的实力，尤其是lmsh，借用今年和starry聊天时的描述就是lmsh成为了一个非常典型的oi选手，那个星期的lmsh在我认知中是他整个ACM生涯最强的时间段，那一周里不仅在策略上说不要让机子空下来，又在调节气氛和解决题目上起到了中流砥柱的作用，soxsx则承担了很大一部分的构造和模拟，soxsx的特点是思考问题相对学术化，经常会迸发出意想不到的灵感，而我在场上中后期经常会成为那个21开题的1，当lmsh和soxsx一起讨论题目卡住时(有时这俩会纠结于一些奇奇怪怪的地方，甚至和题目关系不大)偶尔会突然迸发出灵感解决掉自己手上的题。就这样，三个人轮流迸发出灵感，在那段时间三人打满5h的场里基本都是能达到银牌水平，后来我对当时lmsh和soxsx的评价是进入化境。\r\n2021年11月27日，上海站热身赛来临，凭借还不错的状态拿到了校内rk1(众所周知热身赛不能体现真实实力)。\r\n2021年11月28日，上海站正式赛来临，也是lmsh那一年的封神一战，那天主办方要求早上8点就到达比赛场地(但比赛时间是12:00-17:00)，所以带着半梦半醒的状态赶往了实验室，到那之后便是无事可干，后面的学长在玩单机游戏，而我因为电脑上没装什么游戏所以开始敲起了某场div2f的线段树，两个队友则在罚坐，我敲到一半敲不下去，lmsh让我不要敲了放空一下脑子，此后便是三人的罚坐时间(提前罚坐了场上就不会罚坐了)。\r\n直到12点比赛终于开始了，一上来两个人秒了D和E，第三道G是数学+树形dp，我推出了公式，然后lmsh听到我会公式，所以写了个calc接口给我，我稍微调了一下就过了，一波配合非常良好的combo。然后是I题，我当时并不会dp，但是一眼看出了是dp题，队里dp专精手lmsh想了一下两发就把这题过了，然后就去开了M题，一道二分图构造或者猜公式的题，开了许久没有猜出正确的结论，转向了非常困难的H题，kruskal重构树，但当时我们队并没有人学过这个算法，此时lmsh站了出来，在纸上写了一堆草稿+讲了我和soxsx完全听不懂的做法，然后上机写起了代码，留下了一脸懵逼的我和soxsx，lmsh写完wa了一发之后我看soxsx仍然处于懵逼状态就选择了自己造了一组数据，恰好找出了lmsh代码上的问题，第二发提交通过了H，此后转向了K题，构造，三个人想出了一些特殊情况之后我开始上机写暴力验证小数据，但我还没调出暴力时soxsx和lmsh突然就把所有的构造方式都想出来了，然后soxsx上机一发通过了这题，此后是90分钟的罚坐时间，B题多项式，但当时没人学过，lmsh想了一下发现不太可做，我想出了J题的一半，也知道要用bitset，但差了临门一脚，和lmsh讨论了一下无果之后三人开始合力冲M，soxsx用随机模拟的方式模拟出了n=3的情况，但到赛后发现是猜的多项式最高次有问题，所以后面公式一直猜的不对，此后也没有再过题，以rk71(校内rk3)结束上海站，也让我们创造了2021-2022赛季校内同级别队伍的最好成绩。\r\n回想起夺银的那天，去学校美食城的时候整个人也是容光焕发的样子，那一天的成绩确实振奋人心。\r\n此后一个月开始摆烂，不怎么刷题天天打游戏和水群，某一天突然发觉自己仍然有着对金牌的渴望，就又开始刷起了题的同时进入了2022年。\r\n如果说2021年是成功的一年，那么2022年可以说是失败的一年。\r\n寒假里，某算法群由于ay的出现和cupids_bow的疯狂刷题行为加剧了大家的精神内耗，所以我的状态大概就是起床玩会儿手机，吃完午饭开始上机学算法写代码，写到差不多晚上吃饭的时间，回来继续写，晚上有比赛就参加比赛，大概一周6-7天都是这个状态，也因此实力大涨时隔半年重新回到了紫名。3月左右开始了也许是整个生涯最歪的决定————学习多项式，只能说多项式是个高投入低收益的东西，在有其他知识面缺陷的情况下并不太值得花几个月的精力去学习。\r\n四月的时候由于lmsh和soxsx不知道连续摆了多久，都没能通过省赛选拔，我和zn_com,2020hduyz组成了一支临时队伍slow\r\ntime down参加省赛，但在磨合度上并不输LSP steaming\r\nbuns，大概有些默契本就天生形成，赛前的vp各种打穿，尤其是17th\r\nzjcpc，甚至以vp打赢了正式参赛的五点共圆，良好的化学反应和成绩让我们对省赛有着很大把握，可惜正式赛当天，队伍三个人轮流犯病，我和zn_com前期题出现非常大的罚时失误，导致签到题贡献了200分钟罚时，我在201分钟和zn_com打出combo解决第八题之后2020hduyz立即上机开始写第九题，可惜他没完全听懂zn_com的做法导致99分钟没能写完那题，最后差102分钟罚时夺金。\r\n省赛过后的下一星期就是天梯赛，当时我cf达到了历史新高的2000+，由于cf的出色表现老刘把我放在了2队里，那次天梯赛明显变难，模拟题的增多再加上陈越写的松针题面属实不行，所以前面浪费了很多时间，在达到227分左右时只剩下15分钟了，当时也不知道再写个暴力就能拿20多分从而夺金，所以很快就上手写正解，但是没能调出来，最后以230分收场拿下个人二等团队一等。\r\n天梯赛结束之后，由于老刘认为队里4个大二银牌oier(一共就4个oier+2个零基础)达不到金牌水平，所以他们被迫强制退役(至今认为这个决策不合理)，在上海站天神下凡的lmsh也恰好在点杀名单当中(但老刘并不知道具体情况，他对我们队的判断是上半年集体vp打得并不好，实际上是我们队都有课导致经常打一半就少一两个人，所以会出现签到题一整场没人签，中后期题却写掉了的情况，比如台北场)，此后lmsh开始去华为算法岗实习。\r\n2022年5月，我的思维达到了整个生涯最强的时期，并且在5月14日同时也是进队514天时场切2400分题目cf上黄(20届零基础仅三人上黄)，rating2165，那时候遇到2300及以下的思维题总是能想一会儿就出做法，处于整个生涯的思维巅峰状态。\r\n\r\n上黄之后cf就不太怎么关注了，cf刷题力度确实也弱了下来，在疯狂刷洛谷当中，整个人开始陷入套路化，从一个思维选手逐渐转变成了一个套路选手，但思维是油，算法是车，车离开了油终究会跑不动，所以也从黄掉回了紫，也为之后的失败埋下了伏笔。\r\n暑假和void_f,soxsx组成了Oceanic\r\nGlow(杭电11队)，先来讲讲新队友void_f(perdu)，借用和starry聊天时的话语，void_f是一个非常不典型的oier。他会在一些奇怪的地方突然拓展思路，但一旦思路错误会整个人陷入进去并且队友也会跟着陷入进去。\r\nsoxsx也许是突然失去了对acm的热情，整个人开始投入到课内当中(是我课内实验的救星)，第二年除了学了计算几何之外并没有怎么做题，做题水平除了计算几何之外和2021年没什么区别，也是20届零基础里唯一一个没上过紫的，两年加起来刷了1000题，所以第二年的懈怠程度甚至让我在私聊时忍不住喷过一次。\r\n我在暑假里一度失了智，思维能力大不如黄名时期，多校时一度开不出多项式以外的中期题，那时就晚上拼了命的写题，一点两点刷题是常态，但并没有得到什么好的效果。\r\n但最致命的是打法上的冲突导致磨合非常困难，这也是在组队时完全没想到的，我一共经历了三支队伍，唯有这一支，在磨合和默契程度上都大不如以前的队伍，三个人很多时候沟通并不到位，甚至在换位置这件事上也有体现，曾经的队伍三个人的位置在赛中会随便坐，但这支并不会这样，导致很多时候三个人像各打各的，形成一种三人单挑的局面。void_f原来队伍的打法和我们上赛季队伍的打法非常不同，导致整个暑假里我尝试调整了两次策略，但效果其实都不是很好，磨合问题其实到退役都没能解决得非常良好。\r\n虽然有种种问题，但三个人终究实力还是有保证，所以偶尔即使沟通不足也能打出上限，比如多校打出两次校内rk3，但更多的是由于磨合和沟通以及自身实力原因打出非常抽象的下限，比如校内rk8/9/10，导致多校校内排名从rk4掉到rk7(区域赛打完连rk7都没了)，并且亲手丢失一次参加ccpc的机会。\r\n网络赛后我靠着爆刷了一波斜率优化dp补足了dp方面，两年来第一次顿悟dp。\r\n此后开始进入到大量vp阶段，可参考2022-2023赛季VP记录博客，可以发现又是开局猛后期萎，貌似成了这支队伍的通病，越vp越发现自己思维越来越差只会套路，队伍甚至开始卡死在签到题，今年的比赛里唯一一场vp金牌区是2021-2022\r\nec-final，rk21，也vp了今年所有的CCPC，三银一铜，为了练签到专门练了两套comfest，但第二套直接死在了签到，最后一周的三场vp里有两场死在了签到，只打好了一场，Oceanic\r\nGlow的问题开始愈发明显，却不知道如何解决，也直接导致了icpc的失利。\r\n2022年11月13日，西安站来临，三个人没有一个人状态是正常的，签到失误也非常严重，soxsx甚至没写出签到最后我上机调出来，在2队7题时我们队甚至只有3题，两个多小时才签完6题之后三个人又开始了互演时刻，我和soxsx开A开到只剩1h我把代码写完时发现题目读错了，void_f练了一个暑假的网络流却没能切出B，三个人灾难性表现直接导致整把崩盘，甚至没打赢学弟，以铜牌结束比赛，论赛场表现肯定会被去年上海的LSP\r\nsteaming buns吊起来打。\r\n2022年11月27日，济南站来临，也是离夺金最近的一次，但架不住犯病，那天脑子一样由于睡眠不足昏昏沉沉，做题时A这种非常擅长的题目都能算错复杂度并且少优化一个地方，同时伴随的是决策问题，void_f一开始就想到了我没加的那个优化，但是我似乎没有听进去，void_f转而和soxsx开E，void_f出现了上述提到的问题，思路歪了的同时带着soxsx一起陷了进去，后来soxsx突然灵光一现做了出来(模型非常典，也许换黄名时期的我能一眼看出来)，10分钟后我也突然发现A的优化，从而做出A，但此时已经过去127分钟了(所以正确的决策应是soxsx单独开E，我和void_f开A)，然后void_f和soxsx读完长篇大论的D后很快想出了正解，我也很快想出了C的一个解法，写了一发发现是错误的，没考虑子树相对顺序，所以开始和soxsx想C，讨论出了一个非常难写的背包回退写法，在浪费了非常多时间之后终于调出了C，交上去还被卡了时间和空间，卡完常后终于通过，此时过去了268分钟，只剩半小时开G，但是，此时其实仍然有翻盘希望，void_f很早就想出了线段树维护swap操作，soxsx也很快想出了swap次数不会多，相当于两个人拼起来就是正解，但并没有进行充分交流，soxsx选择用不够快的码速敲了一遍题面代码去验了一遍，验出结论是正确时只剩5分钟，宣告济南站以rk58遗憾打银。\r\n最后的结果是和金牌线同题数，差233分钟罚时夺金，也就是要么写签到题A题和E题时不犯病浪费那么长时间，要么写C题时不犯病，要么G题soxsx和void_f加强一下沟通，然后直接上手写，任意做到一个都能夺金，可惜的是一个都没能做到，也成为了多校校内前八支队伍里唯一一支没有夺金的队伍。\r\n整体回想一下三场区域赛，只有大二时期的上海站打得像顺风局，大三的两把都是逆风局，问题出在哪呢，我自己确实也有很大问题，大二时期非常注重思维，思维越练越强，大三开始学了一些useless的算法，思维变得套路化，从思维选手变成了套路选手，导致非常吃题目风格，队伍上的问题相对更大一些，交流并不像前两支队伍一样充分，即使到了结束都没能磨合好这个问题，再加上场上脑子犯病，三个机会里把握一个就能夺金，没把握住也确实可惜。\r\n回想一下整个生涯，两年时间，codeforces、洛谷等等平台再加上组队赛，刷了至少3000道题目，洛谷上蓝紫黑题加起来接近600题，大二区域赛银，省赛银，天梯赛个人二等，大三区域赛银，貌似自己总是拿不到最好的成绩，也许是运气不足，也许是实力不够，也许是训练方法有误。\r\n\r\nACM生涯也到此结束，终于迎来了大学里第一个能休息的假期，不用再没日没夜地敲代码，倒也不错。接下来的计划大概就是寒假里尽量恢复一下实力cf回个黄，实在做不到也就算了，再做一个nonebot，然后背背八股带上lmsh一起跑路投简历下学期去实习了，希望进Iscream2001实习的公司，由于这学期期末考试变成了下学期开学考，所以额外空降的计划就是寒假好好补一下落下的课程，至于下学期的天梯赛和省赛，就看队友的意愿了，毕竟区域赛结束，也宣告ACM告一段落，自己也随之退役了。\r\n"},{"title":"NOI2018 屠龙勇士","url":"/2022/07/03/NOI2018%20%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/","content":"\r\n题目所求即为对所有有\r\n\r\n考虑以下同余方程的合并 \r\n\r\n\r\n令\r\n则\r\n设\r\n则通解，，可通过求解\r\n，注意此处不需要乘上系数\r\n\r\n最初添加一个方程即可做到\r\n此时可求出满足同余方程的答案，对于条件扫一遍处理即可 #include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;ll t[N], sword[N];ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if (!b)    {        x = 1;        y = 0;        return a;    }    ll gcd = exgcd(b, a % b, x, y);    ll t = x;    x = y;    y = t - a / b * y;    return gcd;}ll excrt(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;b, vector&lt;ll&gt; &amp;p){    assert(a.size() == b.size() &amp;&amp; a.size() == p.size());    ll A = 0, P = 1;    for (int i = 0; i &lt; a.size(); i++)    {        ll x, y;        ll p1 = P, p2 = p[i];        ll a1 = A, a2 = a[i];        ll b1 = 1, b2 = b[i];        ll m1 = p1 * b2, m2 = p2 * b1;        ll d = exgcd(m1, m2, x, y);        if ((-a1 * b2 + a2 * b1) % d)return -1;        ll lcm = p[i] / d * P;        __int128 k1 = ((__int128) -a1 * b2 + a2 * b1) / d % lcm * x % lcm;        A = (a1 + k1 * p1) % lcm;        P = lcm;    }    A = (A % P + P) % P;    for (int i = 0; i &lt; a.size(); i++)    {        ll now = (a[i] + b[i] - 1) / b[i];        if (A &lt; now)            A += (now - A + P - 1) / P * P;    }    return A;}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        vector&lt;ll&gt; a(n), b(n), p(n);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;a[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;p[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;t[i]);        multiset&lt;ll&gt; st;        for (int i = 0; i &lt; m; i++)            scanf(\"%lld\", &amp;sword[i]), st.insert(sword[i]);        for (int i = 0; i &lt; n; i++)        {            auto p = st.upper_bound(a[i]);            if (p == st.begin())                b[i] = *p;            else b[i] = *--p;            st.erase(p);            st.insert(t[i]);        }        printf(\"%lld\\n\", excrt(a, b, p));    }    return 0;}\r\n","tags":["Number Theory"]},{"title":"P3746 组合数问题 循环卷积","url":"/2022/07/13/P3746%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%20%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/","content":"\r\n给定四个整数 ，求\r\n\r\n\r\n转化为循环卷积\r\nconst int N = 300005;int n, m, k;ll mod;using poly = vector&lt;ll&gt;;poly operator*(const poly &amp;a, const poly &amp;b){    poly c(k);    for (int i = 0; i &lt; a.size(); i++)        for (int j = 0; j &lt; b.size(); j++)            c[(i + j) % k] = (c[(i + j) % k] + a[i] * b[j]) % mod;    return c;}poly fpow(poly x, ll r){    poly ans{1};    while (r)    {        if (r &amp; 1)ans = ans * x;        r &gt;&gt;= 1;        x = x * x;    }    return ans;}int main(){    int p, q, u, v, w, x, y, z, T;    int r;    cin &gt;&gt; n &gt;&gt; mod &gt;&gt; k &gt;&gt; r;    poly F{1, 1};    cout &lt;&lt; fpow(F, 1ll * n * k)[r];    return 0;}\r\n","tags":["Generating Functions","FFT"]},{"title":"P5293 [HNOI2019]白兔之舞","url":"/2022/07/05/P5293%20%5BHNOI2019%5D%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/","content":"\r\n设为白兔跳了次终点为的方案数 \r\n可以用矩阵优化，则跳次可以用矩阵表示为,为行向量，初始只有第列为1，为输入矩阵\r\n设，那么最终在第个点结束的答案为，即行向量的第列\r\n接下来求方案数 单位根反演\r\n令 可通过矩阵预处理得出，为次单位根，可通过求原根之后求出\r\n算法变换\r\n差卷积即可 ll get_r(){    vector&lt;int&gt; vec;    ll now = mod - 1;    for (int i = 2; i * i &lt;= now; i++)    {        if (now % i)continue;        vec.emplace_back(i);        while (now % i == 0)now /= i;    }    for (int g = 2;; g++)    {        bool flag = true;        for (auto p:vec)            if (fpow(g, (mod - 1) / p) == 1)            {                flag = false;                break;            }        if (flag)return g;    }}ll wk[N];int main(){    ll p, q, u, v, x, y, z, T;    ll L;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; mod;    matrix Z;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            scanf(\"%lld\", &amp;Z.a[i][j]);    ll r = get_r();    ll w = fpow(r, (mod - 1) / k);    wk[0] = 1;    for (int i = 1; i &lt; k; i++)        wk[i] = wk[i - 1] * w % mod;    poly h(k);    for (int i = 0; i &lt; k; i++)    {        matrix f;        f.a[1][x] = 1;        f = f * (Z * wk[i] + matrix::E()).fpow(L);        h[i] = f.a[1][y];    }    poly F(2 * k - 1), G(k);    for (int i = 0; i &lt; k; i++)        G[i] = h[i] * fpow(w, 1ll * i * (i - 1) / 2) % mod;    for (int i = 0; i &lt; 2 * k - 1; i++)        F[i] = fpow(fpow(w, mod - 2), 1ll * i * (i - 1) / 2);    F = F * G.rev();    const ll invk = fpow(k, mod - 2);    for (int i = 0; i &lt; k; i++)        printf(\"%lld\\n\", fpow(w, 1ll * i * (i - 1) / 2) * invk % mod * F[k - 1 + i] % mod);    return 0;}\r\n","tags":["Generating Functions","Bluestein"]},{"title":"TODO","url":"/2023/02/16/TODO/","content":"\n  51a47be05339f396953926958ef9b35bb7a1ac0040d05c4c21869fb57e761fd3b766e73efb2fe31bd895dd9f403a715ea7e654382baf795d7dcf4cfbbe6d310d08791b5160ddaec7a9ab6fb9fac65c95e88d7d9b31d6c3cf5a266fcaeea40cde9c5c5644c5542e116330bd0d5ca64bbccba483e935ce4afcfaedd63f90c9081370c6c9590faf1514e8c9a511032863f5e45d13a4a4c2303fae5889ac847f24a22beae6b38611e860ca3d178e8883fd3d49bd68bb2aa4c93cc20a50fbd204dddd9db17581ef89db874236f1c0e084062dbe16170267d2b1d9a79cc76ecbd50571da9b14e40435456b872ee032350df7fe09552bc933178c98954366902492ff13761fb4930a13de7bb5bcf168962cb10f29c766cb6ff4972d481a82e63b77425847353e3d736c81fc5df64d6aba19862704230c382ccfdae36229f362f4b3b98cddbb41ba9d37d1445c8388f63461d919159a6328bc60037b57816cc43897378f8331a865a7b70d95c82302c6f3bf69d41e2b957da5507fcd0e26dd8b1b9c14de61cc1f1f69a4a7a08ff4b2e2ac76f361b39ade340e921a84e9553d8502d735c64c9d2c473e83c69ae05200e2479161205547824f201ae1ebaff0e4b7a85843a6bb3329f8009edd02634282a07af07407f22709dd5f5b12ba9b92c679864937f59382831152a0fa38486cba682a94355e176cda87ab3df4f400983e9aaacfec97b5476a706d7a0177ed47655ea4ad550eb862e41cf50eab18368987d478f82fdd4127f190892e548c8cd461bc7bfcd54a5038a26bb97b4dee534a35ddbf3491ed0ce7246f531b50205fcf19e06a03a8ca6970a57dc1f2934b80876dea94745504495e0fe6d7264954efd2f564af5bcada954d3ea07ebb9ade2c5551a235ca100187af4f46f0ffbc47aded7468f78559b5091dfb7b05d889c8fac77b70d0420ed78728fd5102237be54c7db5c76ebc6b6116d01eecac844be4411868b0387d2c5987d7c075fa18ea6775b04a22e14934f09e9aff91f662bf6ff3b3604c9745f684b4e21e1dabd3bb3c062cb3ccc3e942639f68929641b39ad2235190330ebc369cfc2a766838dbc967af8eae51764c24fcc786a9d3b1d831aa34e110916394d073bcab4040072b972f7451fc0ddc42e7679b258ecc97fba04fea45b676e5ebcc701ecc77dfa13df40fda79a003885ff44bf779ab55d5d23b57c91ad8aeff8a96a934d417b89077519978f6165792e96d0047542f1e4d771abe5dc9a694bf38ca10278e6514b202561197dca673ac059305b5e4213194b1cb008baa2f0a2df5abc9aa4be48d4b3851a52ef050aefdc8ac3b1d69c32507cf9156a1ffa3c0a0045742e757a7e7dd7628c234c5bd820dc25f38d758b6060d244e6c09636903e24535389ec0a46efc2c639a091aa20ae2e4920619491bfb4231e5ee27085a788556970a996bee82019dcb242f85e97cab65acf6306fe5f92f5a08a061f8a59fbb7d0902b760803b313a4466cff70d995f8484499a82277bda80d4c283e96c01a964679108fd51ae2c56767cf21b891ad97248384ff0024b1e817c7f50d028e90fe080bd9426290b140df3514631cabf2dc03cbc85d6ec19821f2b2c9dca583b855b77f424bff6657309c2cf5254b36652113e709e22aa3d4ac2b1837757688e4c24a8909d3dbfeb983877b0d52f0b8fcc8e9a914412ffad5493746ba6a85a91343b0365136051d47a56a3bf426d19483aea6a243477863ee2198ade8d9e9f2fe6cb49d008e1a0b5359492d6cd3b96fa79511033b0cadaa75a53060e6e1c198785b5c4dbb6637f8aef781f76cab2833b2ab8574656083591f95c39fc300c9eae1838b258044f1d24fcc69cd16ae1b3edfda416725343dcc0520aab56369ae14d306bf6805d58ec85e72f54d4d71c97564320553762fb11b9225d80591b00e60db893e206dc46353fee36bba18aeb315ed499ec62da15ba4ef87d6bc744cdba8e43e88b89564b137a35a367d7502b1b7022d7093055eac8a9b7cbbdc33c7c24dc033808a1b4f32006bf259e7ab74527a9441071ecd9bde56cc90b19215649fcc471bc6814005ae432296affdf2244c23b4bfc47fa5ca633424b1df882984fac52ea81f7de9698e30221e15f96da583cf06931b4da9dac51f25195b8e9aedc5d6a6ba75bdd9f0bc3e30757f4aabd6918e4bb57665806c458ca73e2a2d7d598f1f6361ec3e50e7c1043d2e931ee505ec4d70dc611497e11aa8a1d5d0ee0030fd24ce1feebc3745f33093492f0aedeb879bdf3becfcbb002fa997c3c2db759864aa2c29f223200709659470defb47351fda8ba8085b8c5081cd7360562c58d00468523ce20f2e3023357be6b8f68abf7b1316c5d9abc8aad857e4cb3454960bd531699cfd9f111595ff9da7493a964cffa5a13eb171318597f7f6afc3058ce6c3ae835532373719a992401675bb3f635de8dd32a25a53987203a8597699cc9b3d0b5009a59a458845d942eb2e7b5637a04e98e7586bd1334c420a07e4d13ec55198245d72c364242df4060b0d7b3b488c00da70ad9f1a3dbc5131a70f6bfae3632feb4b3d293a7aec3af4f20835ca7336b036e57ef835700a917c1ffb7f8abdd48c7c4e4ec03e5e055fe6424e08c6913809fa3c5e72fb3422731e4dd164888c4e37f33282d9e82371868334ee7172770736005a4297d47f7a98cbd11a607f0522133ea3891cbf4ac1def72c366acf8efd163def7d56f9588ac09178c82fa26d84e812c7f9b6a9515c3dd6ca8790e9e91f6e973a42b0a97e72a40cc2dbb16e7814203f8791ef25b1fabd824032e97826ef99e01c04f99682cbf185d70e39deee6111795f14b754b182bc853f0e0d301ff0b3612ec7605a057fa53ffc997a07871d8cebf7e38f65cdb3993a767aafbba70c75c3dd383926bbccb5785b975bb2d31221be514da60421d8f7c79ab1d69d6c5797cb1aaad3034a6342b725c467648dd6f9db2d8b3b79cd3068ddc8f3b69daae7327b5d5e5725581f46172fb44abc9cfe9508b727264b5c1efe603392828ef16e493754350506e03f6cdbed98ab54566c259d3fb63d7397ed8373e48e6c1317c13c3917e574dd0e02e0bed604bec5ae61b551e623e094043d072473677afbbc56b2372d6da29188c00bfefc389157f63f5552a77ea903a1b5d071ef4039e0fcb6b4ea025c83e5817dc42236fb6991708f1a6c47e7f145e63452c620f297e8d4d8f4840dabf9e0599fea0605436d7e52c5b8bdc4ad0f261688ec8ae6b96d5155ce92833747412d3b063842e701b6238da91ee49dc24b40755ee286c4484f5f998de235978b4b2f2afd5889d1eab5b731739460e046ca39882e4761cc238d03e9fc656167a29d1c5b14d5695fd995d5bd65b98c7b51e0f60ed575c832048fb6f93fe5dc6e47d413b6ea4a98d5af9458996579a0166f576bf3c9ddc5df6b0202c96948f01d21cba85953881789eb7833e81996f75d66a49048ec654e6f13be775cf8d11bbe38d7251f8cd6d72ebe992ee5663357ca38cb1a2dccd54fc1ee07e51cccd8a8780a0d85ad63d1d672e0e5312b5c2a34afdb185019389acd8a68f0422c1afb9f8168213e48d4484dd2b1c0d030448c58dd191451ada6c33f98f4fc4e4f006a169a5362a3d06f30e078bc7c375bcbf7f9fd2c8bcd8f52b750e3de0ca60161dc700c066b3b3f022d4210488e424b849e541606675a8b1686a3572a67af4cef1e7d0d54980427a975cb00034344767f85cb0979bdc09f94b957aeda8a1cfbf47c92914a24081b60ee113279077e21519d12549848edcce91fdf1111399eedc13321ade8afbba40c4ed2d435146f6769263864a795db3a0cb98c26821a1d77e0566e025c3c63774bcd45cd71a8be6aa1c45bbf68acb03092d4656087162a036ae2c7d91005eb1bf918ca42942187c08f039c606f96995f5f387466e824a70f1104d470c314c59a96be689a145488ac3bb0d7e48bb2c6bbc12b1730801ebc70590a00d45bb9efcaad526200d3a6b9940fbd93def356d0757ed4b40ddde516dbde94aab4b44675314457a0c7198b9898ca284f8bbb7e94fabb564d7a76aa5ce97c0de0a97eb613ed3f5013bd540c8158fd639da9540384853138e78dab70bff844560864ceec222013d4b39d95e0d2e123e25003a5223542a00ab3911b9cdb75f3cadb0522a39985ed8c9e9ea50e9d1be712c61bee325d19536de571781f5a00f0e9c1be445765fa326c0047c160292ac1b77935fde6c5fd015f6c960022f528b4b234a002dec1de84a8836e2d1b73f8ee04c8c292cfd2313cf8c86da8987bcfc85f115fe0e077f8039baf4c6f8a48a2f68fe019a3b85257d16b69b3cf99662d6e806181e9db717c258f3c69faa3a03be5007bbfb3aa31e15a3ec0fb904d259daba389bc82f8d284786f44b537434c400f49a4ffe554ebaf7e5f667fd60274652a90160149934e4f7de047854e6e0abdeb97e5494bba2b13cd8ed5b9b7fc7b5a7df698e7d5bd8503441001161c14feacbbafb89b177f5a08f9936caa849dd98fce38c121e403efc78e30c80dd244ec68ee3942e69f55e828f0e0e5a21d3f703b2c4b35b9553adc4539a494c34d6a1d28f96d59a556ab4065f9408b6fb1626d7df6319438023bf7e40742f74af32982a9cb80516ebbae03c57dfd3da988c30b61f2b76641c3fac8aa94001e0f296cfd0c3addc63e708802ab1ae604ed0cdd72b3e4f58bc4927b810a19e40b5c4ee523cfce13110a9b292224ce0d4b80bfaecd654522a1dbaf1e09b9e67d05b17d3415b19d6d09342c412a97c2d5f296142af9df40662f831893645a60dcd259086c67a0e6a3645ab6d8a3a1efdfa2eb1d5a5e4e06efaaaac09e76ca0e0b030330461e421fb71ae7511395144a8ff2ccce552926492c550b5d811384779e165321552b0d7524f5be9f2fbe7867cc06f8ccc9b15fb9b2661a03d7e4cbce96a3403b391c93b7cd1074b83d9bd86de66f09f944f6b06fba468f29c41f9e0dd054344e3d873fc71bbcfabb2cd8a49949dba318ea9b9aa898972f0861f6886c525f41b86e90ab2e5ad431b896a9b8219a8b8d60bd27713d79465fee14f9025893cecf6904b6820256390cab868606b6a26fa710f1254b3c6b9413a5fe62f5fa867fef01e5f3a8e8749582861946215bab33f24fd43a7e26ad44fd0dd70813f6b7adaceb3ba4f59e8dc2de7c534ce8042017a44d11b7fe9a301cc3e6f92ec3840075920ba0972c43add71caba0be29f66803d5ba07f762181138318cb98c6a26eab14c34757aeaf0ef3374adc1824226888b79abec3b82f4140062e6e9d9591d32be3c7baa5e65b209d83597f3e779ea752a878c63cb3c3069ad419d887ac64849230f7401626a996bf7d50ce961437b29581c7fa8c3546111344c1232f7e0691aeef566148f0c0397ee669f299937ca7c50685333ee1e5515aa2b75f3e6e84aebd4473d19b959c9e8e63b5fe6b4783dd4c37c4d2b7fa1e4f09376a91a118e075939bbea0494812628e497c3553044c4aa19d558a87aee8500a7865384e9c60fb250d13fea90ad9817678ea55870c8f32e578b65aa4c5b70cc0283e8235e33e504afc7c0dc298032abf5dc0bf8a32a01e8f5966d6561778b98d250c598e13c9e04bcbbe886840076997826579e777eb5d40a16aac49a3353b166df682051df1a1491ac493047938e854a69bad0e39386635d7aa24bdb72ee85c5cdf5147c2e6b51f947ec1e360801149782e6a7476f800694a49bb625a271b04508370b29b9a7e45136c498516b0bcfa68c829e89fadf9bbcb39c2aa8ca1dcda49e8674daa2101ffa3426d814f504211b1d9950746928a0aee43860c7fe500d965cfd1fa3943953739ee39facf9f909617651df210774f70180e2a72139487dde1df1b78f94f13dc2d5c2177960038cdde94ac073ecdb38ca23ea64df41fd44e04897aae21900da7d115aa5cad1831fdc7ebe58aa696a38e66c3455e0d2bba4b73f3a52ea5566d1e5956b4291fd8ce2c509a2b9450c65e57f57b30ffedea94295a094e1cd263d9967d91016ddfba3218c8be806d9c990e41752c7862f8d0f68ec93643c8f69aee330030a8a01e4f7f248bc745eaec80289d95dcba1fba8033479cbc2ee3a129db17275253ca23aa555d9b3e07e9430f364d69801fca6ae03517f81d04e9cdd2e13a1e24f017d2bdc3396fc57b3c37b242f1124e7c18e5a2ef06e11c24198262877287b469fbc7111e74bf41dc1bf20763b9480a8026aec11419aed0614a056c5673a183bd718e63a0aa87b03dd88f2b9b671709055ab5eddd78d823ad4bea079d8b641fa11fa52f6aecf84df729427e1e3db86eb3bcdd0566fa26ab306ce87fed79c792b79b319a461bc409d413df2e81585e62a7ea8eb7082ba8fb826ba4d48ca06e791b197f7bb85273e80f72592df60272c86b939c1e6ab1b8ac75bedeca02caf65094c2f0208bf8d2b1a7636412fbbe7a0ca232e41cfbb38030f1462269d78c991089b8167cb34c6d84ef4a7143862261d101c03803a425cd53eba3f84a4fb10216111e9289b0d02f0794985c3262b9cced2af12fb5d5c87e86ad010fadab873b658261717e313f7a8df553aec1c499cf49b76813b9cf4f79a7f1a8f63f0f50c6ac92e76232ec26e850a904ba0513514420f18a981e841958e49b71ca3bf54c9373049bb8759c18497cb8a47a5b2c1f951704faafdbfb986da2e2f3a1bdb3fb72f0499a41123269e3d7f748b24ecc4148100d6caba624e87c769ba56d1cb2c66a03eb5515d40677b65a333ee86b217a4fd29b21b553774cadd39bd7dfebc74da260b77d96edc806fd88f871762cc49ad84ec0edb0e9a79ad67711542461dff320691e4d1fb5eba6260a502cb89dff50e825e0ec0dea567e472436857ad6963d937bae3527b405c02bb803361c599ea65dd6e794f0e6279eef08fa23229b99126f60bc285f2a7dcdebfaf8aa672fa02e365ec882d0eba6165bbb2519e6b33999b60dd72794b53dcfc305dfcf6f5a6696f18176047c6a79079b2464e212794eb2a0a5933185501d241d8d1e6b889d9db047899244571478c84fcf74f311656bbc6c558970bd8e868f3bdaec9562a1fe506f0de7682dcf92ee7332bee43416edea88f88a1e3d2fd235543d0b435abd9f603f74b0ff5bd4d7c41038f6d0b08500ca6a7c38d5ba861f6ef0dce4cda023fe7302455c079db7f4d49f87e74e1dc38da7dd592e8bf66355179fb891a6281d18f23be9938f00bc8fe7fedcbb7bde6b040835487e94b49fa76231c565e5c17ea4452676d5fc4ae6224a146d6c5841fdce2680c49317361aad603940b28ddc85507ae4cf9acbab85588f988053e8e79be7267bf10aae6d73f522182669c188343048193c4159e894afa13af473c9b85b22b17b2fb962ae8ccfddcd7b4c8c9534870307656700b8b1cf89c85bb59dcf56a87e036dece278735ff2fb72ed007ff7719b7d187e2d9767c1de554cfdce06f662231ca87bf8e343f0737999be7e5bcd4228cf03de944045db1ddc25383fe01a12bb5f739139f839a2e2d01fedbee6fed7478f794c0af5ff2a1183853aed8dea383afa0213727cff4008815f911bc0c9a217492f311819f1d85c5fa219eb29b62a6296871f005314419d0f9c5a147ffa63664ec744aef59b1ea6fa4be703610fc8886577051e98fa40cfe87309fc5c6d268f239791bf9e614d071bf32e8db6262387b935a4b2179e6f11b9914bd74df96d601f40e446d8927c2b97ac43da55acaa819b04eaa852316939a0ae8a4a9db25ba161d1d7bf0a04d3f616b952e1fc74f50cf75c02365bb71ba3735688178cf123832c0d51538e36d66d619c605c736661638a997eea7ca5a448d930adcc3308cddc124ec7c1217d01a3e6aba0c563292edd4ae5206bf76a16d9e2b064f6ec6d0c11c1536da058d4bd2cbd8e5d2a26e89d3244724306e04aa9721a7b960950d2c735a137e4e4f113cf9585b1eaa9db24a998b6be060db98219209d5e144ff6f05184036db78cd26cb42304ad72939cde0ebef5fd1556cd7b8f37a7ec95c5d09ae8214114d26e1163e3ae6f198990e388ebea9f4ab1a69c12f457cdbf51d50bae7c49ddc2e5d34437d8eea6e1b9b7010f5707873416aca740d08df84f87d1847b2e1bebf4e37333aa2ada47972dcc60d8788893fd990769ce26d99364d75b42c9e1a9bb9d524d441adab2c4957e0bd01fd8e12c75b6fff4be9d4c0c23ebdd3729ef45b6dadc1f794a649d15c580d98b9b5cd9387e423cdb63bdceeb221a0c9d785ac8f25c2a281c1854b44d55f8907ca4e25887f2a9c55f07840e7a3a5e89802defe9ce363c816184b4d7aba151eff786e23dae3c2d2575db71cd427a588d73684aa85c215e101c859f824e8caff8b82bae5b294449503e7bec3a7cd4bda8d5e6e0f6124bb5e2107110c104e70d2a3b8b4aa7f13043ca7db54f4681cc60b45ba862f03be5627dab946b25a71966f8d63ea978a0b917523f468320eae8102f65c432a60ec540a50aed2204ce97df39cdc9a310334901fb131beb9debf7f609f5c9a4c3bd4864480ff77222ea692584fa1637b1cc06158f7d5cbfe473bc7fe6464abac51c2609fc9e92a2328d1787d8ea340ae0c346ac7231462cba7550f7cf8662fb0986f9bcb788e685a73f8d954de4c5a80a49d57ab2b7a784ae01d1bad5968d72686f9853d1a997188d0e4ad293052b2202480f09e998e63bac87d22323d1b49d1dce4f40818e536bb6fea22a89fc83dece2a59b1a1cfc296bfb6eb5fd9f73c3a874edec63490da2382f506f8a02ed908d39f6d12ece0d3a3e0af79b42506a31ce5da92e057f58842af3b6703ae84abdfd757e71514a1102a1fd99b5cf0bc3cde6dcf92d1491365cdce46fddbeb45f676698dc40cafcd4e5b9ed05c8485527e735c1666a8cf2b7625c9a0d397c3eb6bf5643a18755652c01e233e707e7e3fe65d7d9c9b2657eeb3336b0eff86434bfba0395220ee8a205f5acee410c4da69b8acdae268f2a5b12d4273d61645c80782b7a51b2085c9e857e04ba4e9d98da11eb23ce59a346f00ca2ac281f878380ed2ce8eb612d24fe27fca30f8394c5611652e26fe5bdd8b6c8d50eb8adee6c8c1b4aed85c30a3d6d1661a6a3b9b4399432ae485992aa5792678ef3a7ad4dcbcf01772e686f6d24f2b81bf21cf74814e7e815673519a6cc938cde2de8471f9276513da342a0e1a00ff60525b50547054877c0d3b4bbe9cee36a84cdf5143e9995dcfc61bb444f8500a9407ba1c5e185b5840817574ef77c8e8f4ec1e475432ea626e209a8173c388df220e484b95e0982bb07734b7ef2c0d4b9df1e363d340605d39e8bf5f6e16f3e4f2071e7659204a57e07a8b208731ca8f789a154982e1976089f0a05a95fc293e5d3aaf9f34f485952b3863b9ceb5f97d06bb2845735ed6ded79a9f1c8ad4c84e511fd8b9bf3a09ae1a24d85d1ce28c752ca0723b1cb6b315da579ec83d6195a0b269d9d28e7af53acd751389d7e0f71fbf752cca7ffe6299b15df2992d5b83160e28d76b180946d5b4659e9f86789de0b34f8306c3a37799900af127bb0efa05a2ab3f1c15556b32563566392f87ce23b270ae4cb38c3e49b1b489737962a4f6107eddd974102f936c46949b4eb9c48158d595627edefd3934dad7e91cc292c46b319558bb27bd560cb60379e0e4c66311450e9c4e3da106299ebaca8fc0ae077e61b7ab95b57ff05201fca6bfac894ed2bd1f3dd12d8bb3cca5a0708c0c7078aac7bedfc1dcf1d2b596833074efa7c46d673d7fe0958ab3fa35124daf758be663b34fea44f786968ccec6a075875bb717590330637b429feaa376b8ebc639ecaf503b96f6c4fabf66fae377650cdadaad5a09fd64aedc5c435c45da27e26cb1a71164c15e0785651929fac2ddd1539bcdeade99b89ab48712064d857ee97fc9fbdd73086d4def6b393076f76d8017d172c74cb93514a24d1f52ea9340a02a1dd261a1d544f10be6fde93c1364dd7c578a42a0bd3503cb2eee0e6d41e533a2698a7ff7356d5e6d3abb080d35e708da234d52a6af7948bc9703a806908d301f01ed78c2e6d1e0e127eab94f8c90cd2eef86f0786cfad3704d6cddb9d69505621f01c7a919b75926f1badf8f02c629c84b81603608fd31807fe3bf90f79562c33958203d6c6ca575f1cd6523d9e4df6b285dbbd49330db80fb996dc0fea90caa61e4041debc1ae4b6f3f2a4d2d99624467fc49fb3c0878231eb52aced4487e3dbfd5e4adf39ac0de276c4f5d139979bd54946044cf3bd3dbf440e4ad5bbf3ed0a8bd25d9e16b02d5f5b2f7161fa96d8d2306c3c9f4e5858801e500018fb0332845418efed1e2f87b73db70c6b26bc6d4751654a2901c2fc7ef863de821841670d96baa0af84a7176b1631192087634826a3657f373c725e49fad4e8c10806940f379e879a8cbadc93337a1420303b3f0355a56ea169bae065f80b378d8dbbea451d8f8d3d3927e1893ae1b2d514dcbf0dce31001ed372e9de7c2de504664f0a2703a0f6de9ee3cdb6748cbf8013f20aa4f89f71d282994b36a8e0e6f68ef4623d0c1533470fc2883744cc0570542586b81da05ccc6e277f257b694725f0000120f63314a7968a0e3db0ad2e5cd2d11860c94af7f8bf4c1f3d8f76cce0eba428df99092c32292370aa8c825e378320957506d0e06307fe58242bed95c989a7ce3ecd6a23ee10b98aac61275c520516f12190be726efe0395f47130b597ce519edbebace226e7da8898d6e8bd5f6641527d8749a501e40d294713e8b77d252bc7a8a6b65972ffe4598ad8fca10a5c6483bd25e91c6b9289085c9ca4cdd46f197facab3ec8cf51d5c6acf89f30e7b2d5ee23e320f81e2ebad6697b8ade115552ac40d7f7543a2e63017da6a6b1f9f702edd4ab2dc6b47e6384ece3d46ce26698399fe4584bcd25163ae7663c3bf0813a9e72a54b4ac31e811dd3675afa60e13e6aebfe6fbbc17727d34b84a4c3d2e2a37508f4154118bfc0f418ff34bd9a71c0aeaccb72309de5eccd6cd0365038de365716266c57401850339c7373ae49795cd28315353bd977412408870a783feb74f8523bdac74895947643473cf76a5367daeb13c0bcccb749518e81e7e79bee045c5424baf7d77012a514dfdd1d7a15994f39a9655e6f0beb9063e64a92d57e66cc8bcadd2dcb0a82aab31d2f393ebd97c2b24752404dcb2e0155f0081253a57e0f630b569043f8b66c0048639cce668b89e693c73c653fe01ccfe754038a7c55e786048fb15689d8366d13f894d07bdf67d1d18a14d20aaf9f2d3d912982b00f85be912421e618705de8c387ba8b8d17883fa7caa72f9b4e258\n  \n    \n      \n      \n        Please enter your password\n      \n    \n  \n\n","tags":["TODO"]},{"title":"快速沃尔什变换/快速莫比乌斯变换","url":"/2022/04/10/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%20%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/","content":"\r\n笔者对快速沃尔什变换/快速莫比乌斯变换的理解也只是刚学阶段，本文只是写写自己的理解和一些其他博客略去的证明。(还没写完的部分可能会咕咕咕一段时间再写)\r\n前置知识：卷积\r\n对于多项式卷积，其思想是对于两个多项式，首先经过转换为点值表示得到，令，再对作一次转化为数组即为答案。\r\n那么类比多项式卷积，位运算卷积也可以类似定义，第项和第项的乘积贡献到第项，则，此处对应某种位运算，那么只需要构造一种转换满足就能实现时间复杂度的位运算卷积(论构造手为什么是神)，具体构造方法可以由数学推导得出+真值表+矩阵求逆得出，由于笔者处于初学阶段，暂不去推构造证明\r\n以下只讲与、或、异或三种位运算卷积且序列长度为的幂\r\n与\r\n\r\n\r\n构造  这样就可以在时间求出和的乘积，现在只需快速求出变换和\r\n设序列长度为，下标范围为，由于和位运算的特殊性，考虑对按位分治，设\r\n设是下标为的序列，是下标为的序列，如果已经求出了和，那么只要计算和相互的贡献就能求出\r\n对于，有，考虑二进制表示，则在二进制表示上比多一个最高位的，即，因此对于任意若满足，也一定满足，又和构成双射，那么对于，在上恰好对有一次贡献，在上不变，因此可以推出下式：\r\n在区间上为，在区间上为 那么的分治就完成了\r\n再对序列做就能得到答案序列经过变换后的序列\r\n对于，即为的反演，考虑矩阵\r\n 行变换后可得  (这部分矩阵证明反演笔者也不知道是否合理，凭感觉写的)\r\n那么可以推出下式： 在区间上为，在区间上为 就能得到最终的答案序列\r\nvoid mul(int n){    for (int i = 0; i &lt; n; i++)        a[i] = a[i] * b[i] % mod;}void AND(ll *f, ll x, int n){    for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1)        for (int i = 0; i &lt; n; i += o)            for (int j = 0; j &lt; k; j++)                f[i + j] = (f[i + j] + f[i + j + k] * x) % mod;}void FWT_AND(){    AND(a, 1, n), AND(b, 1, n), mul(n), AND(a, mod - 1, n)}\r\n剩下的部分咕咕咕\r\n","tags":["Math","FWT","FMT"]},{"title":"洛谷P4491 [HAOI2018]染色","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4491%20%5BHAOI2018%5D%E6%9F%93%E8%89%B2/","content":"\r\n设为钦定种颜色，每种颜色恰好出现了次的方案数，设为恰好种颜色，每种颜色恰好出现了次的方案数\r\n考虑钦定k种颜色能得到的方案数，可得\r\n\r\n阶乘预处理后即可时间内算出\r\n然后考虑和之间的关系，有 \r\n二项式反演后可得 \r\n差卷积后乘上对应值即可得出答案，总复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 10000005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    int s;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    poly W(m + 1);    for (int i = 0; i &lt;= m; i++)        scanf(\"%d\", &amp;W[i]);    poly F(m + 1);    for (int i = min(n / s, m); i &gt;= 0; i--)        F[i] = fac[m] * ifac[m - i] % mod * fac[n] % mod * fpow(ifac[s], i) % mod *               ifac[n - i * s] % mod * fpow(m - i, n - i * s) % mod;    poly H(m + 1);    for (int i = 0; i &lt;= m; i++)        H[m - i] = (i &amp; 1 ? mod - 1 : 1) * ifac[i] % mod;    poly G = F * H;    ll ans = 0;    for (int i = 0; i &lt;= m; i++)        ans = (ans + G[m + i] * ifac[i] % mod * W[i]) % mod;    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"洛谷P4389 付公主的背包","url":"/2022/04/03/%E6%B4%9B%E8%B0%B7P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","content":"\r\n设商品体积为的为， \r\n则所求答案为\r\n麦克劳林公式展开后可得 \r\n枚举倍数后可得系数，再求一次多项式即可得到答案，时间复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }        poly exp(int n)//需要保证f[0]=1        {            poly a{1};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * (poly{1} - a.ln(k) + modxk(k))).modxk(k);            }            return a.modxk(n);        }#undef T    };}using namespace polybase;int cnt[N];ll inv[N];int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        scanf(\"%d\", &amp;x), cnt[x]++;    for (int i = 1; i &lt;= m; i++)        inv[i] = fpow(i, mod - 2);    poly F(m + 1);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; i * j &lt;= m; j++)            F[i * j] = (F[i * j] + inv[j] * cnt[i]) % mod;    F = F.exp(m + 1);    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"\r\n设个点的简单有标号无向图的数目为,对应为\r\n个点的简单有标号无向连通图的数目为,对应为\r\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\r\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\r\n所以，答案即为\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"转置原理和多项式多点求值","url":"/2022/06/09/%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86%E5%92%8C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/","content":"这篇博客背后是阅读十数篇博客和高强度悟道\r\n矩阵的初等变换和初等矩阵:\r\n三种矩阵初等变换\r\n\r\n交换矩阵两行(列)\r\n对一行(列)乘\r\n将第行乘加给第行\r\n\r\n对单位矩阵实施一次初等变换得到的矩阵称为初等矩阵。\r\n一种初等变换对应一个初等矩阵\r\n一个可逆矩阵可分为多个初等矩阵相乘\r\n转置原理：\r\n转置定理：如果，可得\r\n线性算法的转置：\r\n\r\n已知矩阵，输入向量，向量为左乘的运算结果，求解的算法为线性算法\r\n称与互为转置\r\n若矩阵可逆，可分为若干个初等矩阵相乘 此时若算法较难求出，可先求解的优化方法即 的优化方法，求出的优化方法后以相反的运算顺序即可求出的优化方法，具体原理可以参考其他博客，笔者高强度悟道才理解此处\r\n\r\n多项式乘法\r\n对于一个多项式次多项式和次多项式,令，可知将看作向量，看作矩阵\r\n以举例，考虑矩阵形式：\r\n 该线性算法转置为  即，可见加法卷积的转置为减法卷积，加法卷积的转置标记为\r\n多项式多点求值\r\n给定一个次多项式，现在请你对于，求出 。\r\n不妨都将长度扩充到，长度不够的地方补充0，以下令\r\n考虑该算法的矩阵形式  求点值的过程为线性变换，矩阵A为范德蒙德矩阵，可分为若干个初等矩阵扩充为n阶方阵后运算得到，并不影响推导(应该吧)。\r\n考虑该算法的转置，易知\r\n 该式可用分治快速求出 令分子为，分母为，则\r\n\r\n以上为转置算法的解\r\n接下来考虑原算法，可知与多项式无关，可视为列向量，对应转置算法为\r\n\r\n线段树预处理数组\r\n由转置原理的第三条和多项式乘法的转置可知自顶向下求解，顶部求出\r\n由转置算法中分子的运算过程可得原算法的逆过程： \r\n叶子节点即为答案\r\n\r\n该算法常数小且易于实现，难点在于高强度悟道\r\n这篇博客中有很多东西并没有讲清楚，许多细节以笔者的水平难以表达出来，同时笔者对线代的理解非常浅显，暂时先写成这样\r\n以下是笔者写的递归代码\r\nconst int N = 100005;int n, m, k;poly mulT(const poly &amp;a){    if (a.empty())return poly();    return (T * a.rev()) &gt;&gt; (a.size() - 1);}poly a, F;poly c[N &lt;&lt; 2], h[N &lt;&lt; 2];int len;void build(int l, int r, int k){    if (l == r)c[k] = poly{1, mod - a[l]};    else    {        int m = (l + r) &gt;&gt; 1;        build(l, m, k &lt;&lt; 1);        build(m + 1, r, k &lt;&lt; 1 | 1);        c[k] = c[k &lt;&lt; 1] * c[k &lt;&lt; 1 | 1];    }}void solve(int l, int r, int k){    if (l == r)return;    else    {        int m = (l + r) &gt;&gt; 1;        h[k &lt;&lt; 1] = h[k].mulT(c[k &lt;&lt; 1 | 1]).modxk(m - l + 1);        h[k &lt;&lt; 1 | 1] = h[k].mulT(c[k &lt;&lt; 1]).modxk(r - m);        solve(l, m, k &lt;&lt; 1);        solve(m + 1, r, k &lt;&lt; 1 | 1);    }}void print(int l, int r, int k){    if (l == r)    {        if (l &lt; m)            printf(\"%lld\\n\", h[k][0]);    }    else    {        int m = (l + r) &gt;&gt; 1;        print(l, m, k &lt;&lt; 1);        print(m + 1, r, k &lt;&lt; 1 | 1);    }}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    F.resize(n + 1);    for (int i = 0; i &lt;= n; i++)        scanf(\"%lld\", &amp;F[i]);    a.resize(m);    for (int i = 0; i &lt; m; i++)        scanf(\"%d\", &amp;a[i]);    len = max(n + 1, m);    F.resize(len), a.resize(len);    build(0, len - 1, 1);    h[1] = F.mulT(c[1].inv(len));    solve(0, len - 1, 1);    print(0, len - 1, 1);    return 0;}\r\n","tags":["Generating Functions","Matrix","Poly"]}]