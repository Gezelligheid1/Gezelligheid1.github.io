[{"title":"2020牛客暑期多校训练营（第五场）C-Easy","url":"/2022/06/16/2020%E7%89%9B%E5%AE%A2%E6%9A%91%E6%9C%9F%E5%A4%9A%E6%A0%A1%E8%AE%AD%E7%BB%83%E8%90%A5%EF%BC%88%E7%AC%AC%E4%BA%94%E5%9C%BA%EF%BC%89C-Easy/","content":"\r\n2020牛客暑期多校训练营（第五场）C-Easy\r\n设所对应的二元生成函数为，则答案为\r\n由基本生成函数知识可知\r\n\r\n考虑 \r\n则\r\n因此\r\n时间复杂度\r\n","tags":["Generating Functions","Combinatorics"]},{"title":"2022杭电多校一1010 hdoj7147 Walk","url":"/2022/07/22/2022%E6%9D%AD%E7%94%B5%E5%A4%9A%E6%A0%A1%E4%B8%801010%20hdoj7147%20Walk/","content":" 的分界线分别为,\r\n对于下一层的纵坐标\r\n，，， 称满足上述条件为合法情况，不满足上述条件为不合法情况。\r\n设恰好有层不合法的方案数为，设恰好有i层合法的方案数为。\r\n考虑容斥求，钦定最后层（即到层）不合法，前层合法。（容斥部分感谢ywx的讲解和点化）\r\n那么从钦定最后层不合法和前层合法开始，当前情况数为，此时只钦定了前层和最后层，第层和第层之间的关系并未确定，可能第层和第层仍然构成不合法情况，那么就要把这种情况减去，也就是减掉，同理仍然有第层和第层可能构成不合法情况，但被减去了，所以要加上，一步步下去，可得如下式子\r\n\r\n合并后可得\r\n\r\n所以对应的生成函数和对应的生成函数之间的关系为  接下来考虑如何求\r\n连续层不合法，那么会使得\r\n设，那么需要相隔至少个数之后才能选，那么可以每选择一个数使得减，即线性变换，因此考虑矩阵\r\n设为输入的个权值\r\n时不需要偏移，所以矩阵为\r\n\r\n时偏移为格\r\n\r\n时偏移为格\r\n\r\n以时的矩阵为例进行解释，之后能选的数是，那么i移动就只能从第三列移动到一列之后才能加，在移动两格的过程中，和就没有被选在之后，而选择之后又需要停两次才能选，若不选则仍然停留在立即能选的状态，所以该矩阵的转移就是\r\n\r\n写出来就是的矩阵\r\n最后带回原式做一个多项式求逆即可\r\nstruct matrix{    poly a[4][4];    static constexpr int n = 3;    friend matrix operator*(const matrix &amp;u, const matrix &amp;v)    {        matrix ans;        for (int i = 1; i &lt;= n; i++)            for (int j = 1; j &lt;= n; j++)                for (int k = 1; k &lt;= n; k++)                    ans.a[i][j] = ans.a[i][j] + u.a[i][k] * v.a[k][j];        return ans;    }    poly *operator[](const int i)    {        return this-&gt;a[i];    }} s[N];matrix solve(int l, int r){    if (l == r)return s[l];    int m = (l + r) &gt;&gt; 1;    return solve(l, m) * solve(m + 1, r);}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= m; i++)    {        scanf(\"%d\", &amp;w);        if (i &lt; 16)            s[i][1][1] = poly{1, w};        else if (i &lt; 65536)            s[i][1][1] = s[i][2][1] = poly{1}, s[i][1][2] = poly{0, w};        else            s[i][1][1] = s[i][2][1] = s[i][3][2] = poly{1}, s[i][1][3] = poly{0, w};    }    matrix A = solve(1, m);    poly F = A[1][1] + A[1][2] + A[1][3];    for (int i = 1; i &lt; F.size(); i += 2)        F[i] = mod - F[i];    cout &lt;&lt; F.inv(n + 1)[n] &lt;&lt; endl;    return 0;}\r\n","tags":["Generating Functions","Matrix"]},{"title":"2022多校多项式做题记录","url":"/2022/07/26/2022%E5%A4%9A%E6%A0%A1%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%81%9A%E9%A2%98%E8%AE%B0%E5%BD%95/","content":"\r\n牛客多校1：H题\r\nFly，基础不牢没学过完全背包转二进制01背包，中档题，挺可惜。\r\n杭电多校1：1010\r\nwalk，容斥+矩阵维护多项式，压轴难度，完全没思路，补题见Blog。\r\n牛客多校2：E题 Falfa with\r\nSubstring，经典二项式反演，例题难度，场切。\r\n杭电多校2：无多项式。\r\n牛客多校3：I题Ice Drinking，压轴难度，数的touchard同余性质以及快速求5000个级别的第二类数，不会求这5000个斯特林数，比较可惜的是只差这一步，而这一步在翻混凝土数学的时候没去翻二阶欧拉数，二阶欧拉数能与转换，差临门一脚，可惜。\r\nPS：东京大学队伍有个神秘科技可以求单次的斯特林数，令人震惊\r\n\r\n杭电多校3:：1001 Equipment\r\nUpgrade，cdq分治fft优化期望dp，场切，中档题难度，但是过题人数和牛客多校2的E题差不多，人均会多项式？\r\n杭电多校4：无多项式。\r\n","tags":["record"]},{"title":"CF438E The Child and Binary Tree","url":"/2022/04/02/CF438E%20The%20Child%20and%20Binary%20Tree/","content":"\r\n设权值为的答案为，对应OGF为，集合对应的OGF为\r\n考虑，枚举二叉树左右子树的方案数和根的值，可得\r\n\r\n均大于0,所以只有为空树的一种情况即，可得\r\n\r\n，代入和 ，可得 \r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    poly C(m + 1);    for (int i = 1; i &lt;= n; i++)    {        scanf(\"%d\", &amp;x);        if (x &lt;= m)            C[x] = 1;    }    poly F = (poly{1} + (poly{1} - C * 4).sqrt(m + 1)).inv(m + 1) * 2;    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"NOI2018 屠龙勇士","url":"/2022/07/03/NOI2018%20%E5%B1%A0%E9%BE%99%E5%8B%87%E5%A3%AB/","content":"\r\n题目所求即为对所有有\r\n\r\n考虑以下同余方程的合并 \r\n\r\n\r\n令\r\n则\r\n设\r\n则通解，，可通过求解\r\n，注意此处不需要乘上系数\r\n\r\n最初添加一个方程即可做到\r\n此时可求出满足同余方程的答案，对于条件扫一遍处理即可 #include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;ll t[N], sword[N];ll exgcd(ll a, ll b, ll &amp;x, ll &amp;y){    if (!b)    {        x = 1;        y = 0;        return a;    }    ll gcd = exgcd(b, a % b, x, y);    ll t = x;    x = y;    y = t - a / b * y;    return gcd;}ll excrt(vector&lt;ll&gt; &amp;a, vector&lt;ll&gt; &amp;b, vector&lt;ll&gt; &amp;p){    assert(a.size() == b.size() &amp;&amp; a.size() == p.size());    ll A = 0, P = 1;    for (int i = 0; i &lt; a.size(); i++)    {        ll x, y;        ll p1 = P, p2 = p[i];        ll a1 = A, a2 = a[i];        ll b1 = 1, b2 = b[i];        ll m1 = p1 * b2, m2 = p2 * b1;        ll d = exgcd(m1, m2, x, y);        if ((-a1 * b2 + a2 * b1) % d)return -1;        ll lcm = p[i] / d * P;        __int128 k1 = ((__int128) -a1 * b2 + a2 * b1) / d % lcm * x % lcm;        A = (a1 + k1 * p1) % lcm;        P = lcm;    }    A = (A % P + P) % P;    for (int i = 0; i &lt; a.size(); i++)    {        ll now = (a[i] + b[i] - 1) / b[i];        if (A &lt; now)            A += (now - A + P - 1) / P * P;    }    return A;}int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; T;    while (T--)    {        scanf(\"%d%d\", &amp;n, &amp;m);        vector&lt;ll&gt; a(n), b(n), p(n);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;a[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;p[i]);        for (int i = 0; i &lt; n; i++)            scanf(\"%lld\", &amp;t[i]);        multiset&lt;ll&gt; st;        for (int i = 0; i &lt; m; i++)            scanf(\"%lld\", &amp;sword[i]), st.insert(sword[i]);        for (int i = 0; i &lt; n; i++)        {            auto p = st.upper_bound(a[i]);            if (p == st.begin())                b[i] = *p;            else b[i] = *--p;            st.erase(p);            st.insert(t[i]);        }        printf(\"%lld\\n\", excrt(a, b, p));    }    return 0;}\r\n","tags":["number theory"]},{"title":"P3746 组合数问题 循环卷积","url":"/2022/07/13/P3746%20%E7%BB%84%E5%90%88%E6%95%B0%E9%97%AE%E9%A2%98%20%E5%BE%AA%E7%8E%AF%E5%8D%B7%E7%A7%AF/","content":"\r\n给定四个整数 ，求\r\n\r\n\r\n转化为循环卷积\r\nconst int N = 300005;int n, m, k;ll mod;using poly = vector&lt;ll&gt;;poly operator*(const poly &amp;a, const poly &amp;b){    poly c(k);    for (int i = 0; i &lt; a.size(); i++)        for (int j = 0; j &lt; b.size(); j++)            c[(i + j) % k] = (c[(i + j) % k] + a[i] * b[j]) % mod;    return c;}poly fpow(poly x, ll r){    poly ans{1};    while (r)    {        if (r &amp; 1)ans = ans * x;        r &gt;&gt;= 1;        x = x * x;    }    return ans;}int main(){    int p, q, u, v, w, x, y, z, T;    int r;    cin &gt;&gt; n &gt;&gt; mod &gt;&gt; k &gt;&gt; r;    poly F{1, 1};    cout &lt;&lt; fpow(F, 1ll * n * k)[r];    return 0;}\r\n","tags":["Generating Functions","FFT"]},{"title":"P5293 [HNOI2019]白兔之舞","url":"/2022/07/05/P5293%20%5BHNOI2019%5D%E7%99%BD%E5%85%94%E4%B9%8B%E8%88%9E/","content":"\r\n设为白兔跳了次终点为的方案数 \r\n可以用矩阵优化，则跳次可以用矩阵表示为,为行向量，初始只有第列为1，为输入矩阵\r\n设，那么最终在第个点结束的答案为，即行向量的第列\r\n接下来求方案数 单位根反演\r\n令 可通过矩阵预处理得出，为次单位根，可通过求原根之后求出\r\n算法变换\r\n差卷积即可 ll get_r(){    vector&lt;int&gt; vec;    ll now = mod - 1;    for (int i = 2; i * i &lt;= now; i++)    {        if (now % i)continue;        vec.emplace_back(i);        while (now % i == 0)now /= i;    }    for (int g = 2;; g++)    {        bool flag = true;        for (auto p:vec)            if (fpow(g, (mod - 1) / p) == 1)            {                flag = false;                break;            }        if (flag)return g;    }}ll wk[N];int main(){    ll p, q, u, v, x, y, z, T;    ll L;    cin &gt;&gt; n &gt;&gt; k &gt;&gt; L &gt;&gt; x &gt;&gt; y &gt;&gt; mod;    matrix Z;    for (int i = 1; i &lt;= n; i++)        for (int j = 1; j &lt;= n; j++)            scanf(\"%lld\", &amp;Z.a[i][j]);    ll r = get_r();    ll w = fpow(r, (mod - 1) / k);    wk[0] = 1;    for (int i = 1; i &lt; k; i++)        wk[i] = wk[i - 1] * w % mod;    poly h(k);    for (int i = 0; i &lt; k; i++)    {        matrix f;        f.a[1][x] = 1;        f = f * (Z * wk[i] + matrix::E()).fpow(L);        h[i] = f.a[1][y];    }    poly F(2 * k - 1), G(k);    for (int i = 0; i &lt; k; i++)        G[i] = h[i] * fpow(w, 1ll * i * (i - 1) / 2) % mod;    for (int i = 0; i &lt; 2 * k - 1; i++)        F[i] = fpow(fpow(w, mod - 2), 1ll * i * (i - 1) / 2);    F = F * G.rev();    const ll invk = fpow(k, mod - 2);    for (int i = 0; i &lt; k; i++)        printf(\"%lld\\n\", fpow(w, 1ll * i * (i - 1) / 2) * invk % mod * F[k - 1 + i] % mod);    return 0;}\r\n","tags":["Generating Function","Bluestein"]},{"title":"洛谷P4389 付公主的背包","url":"/2022/04/03/%E6%B4%9B%E8%B0%B7P4389%20%E4%BB%98%E5%85%AC%E4%B8%BB%E7%9A%84%E8%83%8C%E5%8C%85/","content":"\r\n设商品体积为的为， \r\n则所求答案为\r\n麦克劳林公式展开后可得 \r\n枚举倍数后可得系数，再求一次多项式即可得到答案，时间复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 998244353;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }        poly exp(int n)//需要保证f[0]=1        {            poly a{1};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * (poly{1} - a.ln(k) + modxk(k))).modxk(k);            }            return a.modxk(n);        }#undef T    };}using namespace polybase;int cnt[N];ll inv[N];int main(){    int p, q, u, v, w, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    for (int i = 1; i &lt;= n; i++)        scanf(\"%d\", &amp;x), cnt[x]++;    for (int i = 1; i &lt;= m; i++)        inv[i] = fpow(i, mod - 2);    poly F(m + 1);    for (int i = 1; i &lt;= m; i++)        for (int j = 1; i * j &lt;= m; j++)            F[i * j] = (F[i * j] + inv[j] * cnt[i]) % mod;    F = F.exp(m + 1);    for (int i = 1; i &lt;= m; i++)        printf(\"%d\\n\", F[i]);    return 0;}\r\n","tags":["Generating Functions"]},{"title":"快速沃尔什变换/快速莫比乌斯变换","url":"/2022/04/10/%E5%BF%AB%E9%80%9F%E6%B2%83%E5%B0%94%E4%BB%80%E5%8F%98%E6%8D%A2%20%E5%BF%AB%E9%80%9F%E8%8E%AB%E6%AF%94%E4%B9%8C%E6%96%AF%E5%8F%98%E6%8D%A2/","content":"\r\n笔者对快速沃尔什变换/快速莫比乌斯变换的理解也只是刚学阶段，本文只是写写自己的理解和一些其他博客略去的证明。(还没写完的部分可能会咕咕咕一段时间再写)\r\n前置知识：卷积\r\n对于多项式卷积，其思想是对于两个多项式，首先经过转换为点值表示得到，令，再对作一次转化为数组即为答案。\r\n那么类比多项式卷积，位运算卷积也可以类似定义，第项和第项的乘积贡献到第项，则，此处对应某种位运算，那么只需要构造一种转换满足就能实现时间复杂度的位运算卷积(论构造手为什么是神)，具体构造方法可以由数学推导得出+真值表+矩阵求逆得出，由于笔者处于初学阶段，暂不去推构造证明\r\n以下只讲与、或、异或三种位运算卷积且序列长度为的幂\r\n与\r\n\r\n\r\n构造  这样就可以在时间求出和的乘积，现在只需快速求出变换和\r\n设序列长度为，下标范围为，由于和位运算的特殊性，考虑对按位分治，设\r\n设是下标为的序列，是下标为的序列，如果已经求出了和，那么只要计算和相互的贡献就能求出\r\n对于，有，考虑二进制表示，则在二进制表示上比多一个最高位的，即，因此对于任意若满足，也一定满足，又和构成双射，那么对于，在上恰好对有一次贡献，在上不变，因此可以推出下式：\r\n在区间上为，在区间上为 那么的分治就完成了\r\n再对序列做就能得到答案序列经过变换后的序列\r\n对于，即为的反演，考虑矩阵\r\n 行变换后可得  (这部分矩阵证明反演笔者也不知道是否合理，凭感觉写的)\r\n那么可以推出下式： 在区间上为，在区间上为 就能得到最终的答案序列\r\nvoid mul(int n){    for (int i = 0; i &lt; n; i++)        a[i] = a[i] * b[i] % mod;}void AND(ll *f, ll x, int n){    for (int o = 2, k = 1; o &lt;= n; o &lt;&lt;= 1, k &lt;&lt;= 1)        for (int i = 0; i &lt; n; i += o)            for (int j = 0; j &lt; k; j++)                f[i + j] = (f[i + j] + f[i + j + k] * x) % mod;}void FWT_AND(){    AND(a, 1, n), AND(b, 1, n), mul(n), AND(a, mod - 1, n)}\r\n剩下的部分咕咕咕\r\n","tags":["math","FWT","FMT"]},{"title":"洛谷P4491 [HAOI2018]染色","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4491%20%5BHAOI2018%5D%E6%9F%93%E8%89%B2/","content":"\r\n设为钦定种颜色，每种颜色恰好出现了次的方案数，设为恰好种颜色，每种颜色恰好出现了次的方案数\r\n考虑钦定k种颜色能得到的方案数，可得\r\n\r\n阶乘预处理后即可时间内算出\r\n然后考虑和之间的关系，有 \r\n二项式反演后可得 \r\n差卷积后乘上对应值即可得出答案，总复杂度\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 10000005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly sqrt(int n)//f[0]必须等于1        {            poly a{1};            int k = 1;            const ll inv2 = fpow(2, mod - 2);            while (k &lt; n)            {                k &lt;&lt;= 1;                a = ((modxk(k) * a.inv(k)).modxk(k) + a) * inv2;            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    int s;    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;    poly W(m + 1);    for (int i = 0; i &lt;= m; i++)        scanf(\"%d\", &amp;W[i]);    poly F(m + 1);    for (int i = min(n / s, m); i &gt;= 0; i--)        F[i] = fac[m] * ifac[m - i] % mod * fac[n] % mod * fpow(ifac[s], i) % mod *               ifac[n - i * s] % mod * fpow(m - i, n - i * s) % mod;    poly H(m + 1);    for (int i = 0; i &lt;= m; i++)        H[m - i] = (i &amp; 1 ? mod - 1 : 1) * ifac[i] % mod;    poly G = F * H;    ll ans = 0;    for (int i = 0; i &lt;= m; i++)        ans = (ans + G[m + i] * ifac[i] % mod * W[i]) % mod;    cout &lt;&lt; ans;    return 0;}\r\n","tags":["Generating Functions"]},{"title":"转置原理和多项式多点求值","url":"/2022/06/09/%E8%BD%AC%E7%BD%AE%E5%8E%9F%E7%90%86%E5%92%8C%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%A4%9A%E7%82%B9%E6%B1%82%E5%80%BC/","content":"这篇博客背后是阅读十数篇博客和高强度悟道\r\n矩阵的初等变换和初等矩阵:\r\n三种矩阵初等变换\r\n\r\n交换矩阵两行(列)\r\n对一行(列)乘\r\n将第行乘加给第行\r\n\r\n对单位矩阵实施一次初等变换得到的矩阵称为初等矩阵。\r\n一种初等变换对应一个初等矩阵\r\n一个可逆矩阵可分为多个初等矩阵相乘\r\n转置原理：\r\n转置定理：如果，可得\r\n线性算法的转置：\r\n\r\n已知矩阵，输入向量，向量为左乘的运算结果，求解的算法为线性算法\r\n称与互为转置\r\n若矩阵可逆，可分为若干个初等矩阵相乘 此时若算法较难求出，可先求解的优化方法即 的优化方法，求出的优化方法后以相反的运算顺序即可求出的优化方法，具体原理可以参考其他博客，笔者高强度悟道才理解此处\r\n\r\n多项式乘法\r\n对于一个多项式次多项式和次多项式,令，可知将看作向量，看作矩阵\r\n以举例，考虑矩阵形式：\r\n 该线性算法转置为  即，可见加法卷积的转置为减法卷积，加法卷积的转置标记为\r\n多项式多点求值\r\n给定一个次多项式，现在请你对于，求出 。\r\n不妨都将长度扩充到，长度不够的地方补充0，以下令\r\n考虑该算法的矩阵形式  求点值的过程为线性变换，矩阵A为范德蒙德矩阵，可分为若干个初等矩阵扩充为n阶方阵后运算得到，并不影响推导(应该吧)。\r\n考虑该算法的转置，易知\r\n 该式可用分治快速求出 令分子为，分母为，则\r\n\r\n以上为转置算法的解\r\n接下来考虑原算法，可知与多项式无关，可视为列向量，对应转置算法为\r\n\r\n线段树预处理数组\r\n由转置原理的第三条和多项式乘法的转置可知自顶向下求解，顶部求出\r\n由转置算法中分子的运算过程可得原算法的逆过程： \r\n叶子节点即为答案\r\n\r\n该算法常数小且易于实现，难点在于高强度悟道\r\n这篇博客中有很多东西并没有讲清楚，许多细节以笔者的水平难以表达出来，同时笔者对线代的理解非常浅显，暂时先写成这样\r\n以下是笔者写的递归代码\r\nconst int N = 100005;int n, m, k;poly mulT(const poly &amp;a){    if (a.empty())return poly();    return (T * a.rev()) &gt;&gt; (a.size() - 1);}poly a, F;poly c[N &lt;&lt; 2], h[N &lt;&lt; 2];int len;void build(int l, int r, int k){    if (l == r)c[k] = poly{1, mod - a[l]};    else    {        int m = (l + r) &gt;&gt; 1;        build(l, m, k &lt;&lt; 1);        build(m + 1, r, k &lt;&lt; 1 | 1);        c[k] = c[k &lt;&lt; 1] * c[k &lt;&lt; 1 | 1];    }}void solve(int l, int r, int k){    if (l == r)return;    else    {        int m = (l + r) &gt;&gt; 1;        h[k &lt;&lt; 1] = h[k].mulT(c[k &lt;&lt; 1 | 1]).modxk(m - l + 1);        h[k &lt;&lt; 1 | 1] = h[k].mulT(c[k &lt;&lt; 1]).modxk(r - m);        solve(l, m, k &lt;&lt; 1);        solve(m + 1, r, k &lt;&lt; 1 | 1);    }}void print(int l, int r, int k){    if (l == r)    {        if (l &lt; m)            printf(\"%lld\\n\", h[k][0]);    }    else    {        int m = (l + r) &gt;&gt; 1;        print(l, m, k &lt;&lt; 1);        print(m + 1, r, k &lt;&lt; 1 | 1);    }}int main(){    int p, q, u, v, x, y, z, T;    cin &gt;&gt; n &gt;&gt; m;    F.resize(n + 1);    for (int i = 0; i &lt;= n; i++)        scanf(\"%lld\", &amp;F[i]);    a.resize(m);    for (int i = 0; i &lt; m; i++)        scanf(\"%d\", &amp;a[i]);    len = max(n + 1, m);    F.resize(len), a.resize(len);    build(0, len - 1, 1);    h[1] = F.mulT(c[1].inv(len));    solve(0, len - 1, 1);    print(0, len - 1, 1);    return 0;}\r\n","tags":["Generating Functions","Matrix","Poly"]},{"title":"洛谷P4841 [集训队作业2013]城市规划","url":"/2022/04/02/%E6%B4%9B%E8%B0%B7P4841%20%5B%E9%9B%86%E8%AE%AD%E9%98%9F%E4%BD%9C%E4%B8%9A2013%5D%E5%9F%8E%E5%B8%82%E8%A7%84%E5%88%92/","content":"\r\n设个点的简单有标号无向图的数目为,对应为\r\n个点的简单有标号无向连通图的数目为,对应为\r\n考虑,个点的简单无向图一共有条边，有连与不连两种选择，因此\r\n考虑组合意义，代表把一个有标号无向图分为任意个有标号无向连通图，\r\n所以，答案即为\r\n#include &lt;bits/stdc++.h&gt;#include &lt;ext/pb_ds/tree_policy.hpp&gt;#include &lt;ext/pb_ds/trie_policy.hpp&gt;#include &lt;ext/pb_ds/assoc_container.hpp&gt;#include &lt;ext/pb_ds/priority_queue.hpp&gt;using namespace std;using namespace __gnu_pbds;using namespace __gnu_cxx;typedef long long ll;//tree&lt;int, null_type, less&lt;int&gt;, rb_tree_tag, tree_order_statistics_node_update&gt; tr;//__gnu_pbds::priority_queue&lt;int, greater&lt;int&gt;, pairing_heap_tag&gt; qu;//typedef trie&lt;string, null_type, trie_string_access_traits&lt;&gt;, pat_trie_tag, trie_prefix_search_node_update&gt; pref_trie;const int N = 200005;int n, m, k;namespace polybase {//范围为1e9需要先取模,别忘记改模数    const ll mod = 1004535809;    int limit;    ll _wn[25];    ll fpow(ll x, ll r)    {        ll result = 1;        while (r)        {            if (r &amp; 1)result = result * x % mod;            r &gt;&gt;= 1;            x = x * x % mod;        }        return result;    }    int _ = []    {        for (int i = 0; i &lt;= 23; i++)_wn[i] = fpow(3, (mod - 1) &gt;&gt; i);        return 0;    }();    inline int norm(int n) { return 1 &lt;&lt; __lg(n * 2 - 1); }    void NTT(ll *A, int type)    {        int i, j = limit &gt;&gt; 1, k, l, c = 0;        ll u, v, w, wn;        for (i = 1; i &lt; limit - 1; i++)        {            if (i &lt; j)swap(A[i], A[j]);            for (k = limit &gt;&gt; 1; (j ^= k) &lt; k; k &gt;&gt;= 1);        }        for (l = 2; l &lt;= limit; l &lt;&lt;= 1)        {            i = l &gt;&gt; 1, wn = _wn[++c];            for (j = 0; j &lt; limit; j += l)            {                w = 1;                for (k = j; k &lt; j + i; k++)                {                    u = A[k], v = A[k + i] * w % mod;                    A[k] = u + v;                    if (A[k] &gt;= mod)A[k] -= mod;                    A[k + i] = u - v;                    if (A[k + i] &lt; 0)A[k + i] += mod;                    w = w * wn % mod;                }            }        }        if (type == -1)        {            ll inv = fpow(limit, mod - 2);            for (i = 0; i &lt; limit; i++)A[i] = A[i] * inv % mod;            for (i = 1; i &lt; limit / 2; i++)swap(A[i], A[limit - i]);        }    }    struct poly : public vector&lt;ll&gt;    {        using vector&lt;ll&gt;::vector;#define T (*this)        poly modxk(int k) const        {            k = min(k, (int) size());            return poly(begin(), begin() + k);        }        poly rev() const { return poly(rbegin(), rend()); }        friend void NTT(poly &amp;a, const int type) { NTT(a.data(), type); }        friend poly operator*(const poly &amp;x, const poly &amp;y)        {            if (x.empty() || y.empty())return poly();            poly a(x), b(y);            int len = a.size() + b.size() - 1;            limit = norm(len);            a.resize(limit), b.resize(limit);            NTT(a, 1);            NTT(b, 1);            for (int i = 0; i &lt; limit; i++)                a[i] = a[i] * b[i] % mod;            NTT(a, -1);            a.resize(len);            return a;        }        poly operator+(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)//用b.size()防止越界            {                a[i] += b[i];                if (a[i] &gt;= mod)a[i] -= mod;            }            return a;        }        poly operator-(const poly &amp;b)        {            poly a(T);            if (a.size() &lt; b.size())                a.resize(b.size());            for (int i = 0; i &lt; b.size(); i++)            {                a[i] -= b[i];                if (a[i] &lt; 0)a[i] += mod;            }            return a;        }        poly operator*(const ll p)        {            poly a(T);            for (auto &amp;x:a)                x = x * p % mod;            return a;        }        poly &amp;operator&lt;&lt;=(int r) { return insert(begin(), r, 0), T; }//注意逗号,F(x)*(x^r)        poly operator&lt;&lt;(int r) const { return poly(T) &lt;&lt;= r; }        poly operator&gt;&gt;(int r) const { return r &gt;= size() ? poly() : poly(begin() + r, end()); }        poly &amp;operator&gt;&gt;=(int r) { return T = T &gt;&gt; r; }//F[x]/(x^r)        poly deriv()//求导        {            if (empty())return T;            poly a(size() - 1);            for (int i = 1; i &lt; size(); i++)//注意是size()                a[i - 1] = T[i] * i % mod;            return a;        }        poly integ()//积分        {            poly a(size() + 1);            for (int i = 1; i &lt; a.size(); i++)//注意是a.size()                a[i] = T[i - 1] * fpow(i, mod - 2) % mod;            return a;        }        poly inv(int n)        {            poly a{fpow(T[0], mod - 2)};            int k = 1;            while (k &lt; n)            {                k &lt;&lt;= 1;                a = (a * 2 - modxk(k) * a * a).modxk(k);            }            return a.modxk(n);        }        poly ln(int n)//需要保证f[0]=1        {            return (deriv() * inv(n)).integ().modxk(n);        }#undef T    };}using namespace polybase;ll fac[N], ifac[N];int main(){    int p, q, u, v, w, x, y, z, T;    fac[0] = 1;    for (int i = 1; i &lt;= N - 5; i++)        fac[i] = fac[i - 1] * i % mod;    ifac[N - 5] = fpow(fac[N - 5], mod - 2);    for (int i = N - 5; i; i--)        ifac[i - 1] = ifac[i] * i % mod;    cin &gt;&gt; n;    poly F(n + 1);    for (int i = 0; i &lt;= n; i++)        F[i] = fpow(2, 1ll * i * (i - 1) / 2) * ifac[i] % mod;    poly G = F.ln(n + 1);    cout &lt;&lt; G[n] * fac[n] % mod;    return 0;}\r\n","tags":["Generating Functions"]}]